/*
Lonestar Benchmark Suite for irregular applications that exhibit 
amorphous data-parallelism.

Center for Grid and Distributed Computing
The University of Texas at Austin

Copyright (C) 2007, 2008, 2009 The University of Texas at Austin

Licensed under the Eclipse Public License, Version 1.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.eclipse.org/legal/epl-v10.html

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

File: Time.java 

*/



package util;

import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * Class that implements alternative timing methods, such as measuring the interval
 * between two events without considering any time spent in garbage collection. The
 * implementation is not thread-safe.
 */
public final class Time {

  private final static List<GarbageCollectorMXBean> garbageCollectorMXBeans;
  private static long counter;
  private static Map<Long, Pair<Long, Long>> times;

  static {
    garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();
    counter = Long.MIN_VALUE;
    times = new HashMap<Long, Pair<Long, Long>>();
  }

  /**
   * Starts a new time counter, returning its identifier.
   * @return An id identifying the current counter.
   */
  public static long getNewTimeId() {
    return getNewTimeId(5);
  }

  /**
   * Starts a new time counter, returning its identifier.
   * @param collections Number of invocations to System.gc() prior to start the timer.
   * @return An id identifying the current counter.
   */
  public static long getNewTimeId(int collections) {
    // Before gathering any time statistics, it is useful to run the garbage collector
    // so it does not interfere with the results.
    for (int i = 0; i < collections; i++) {
      System.gc();
    }
    counter++;
    times.put(counter, new Pair<Long, Long>(milliTime(), milliGcTime()));
    return counter;
  }

  /**
   * Returns the elapsed time since the given counter was created. The returned value
   * does not include any time spent by the JVM in garbage collection.
   * @param id Id generated by getNewTimeId.
   * @return Elapsed time, in milliseconds.
   */
  public static long elapsedTime(long id) {
    Pair<Long, Long> startTimes = times.get(id);
    return elapsedTime(startTimes.getFirst(), startTimes.getSecond());
  }

  private static long elapsedTime(long startTime, long startGcTime) {
    return milliTime() - startTime - milliGcTime() + startGcTime;
  }

  /**
   * Returns the elapsed time since the given counter was created. The user can choose whether to
   * include the time spent by the JVM in garbage collection or not.
   * @param id Id generated by getNewTimeId.
   * @param Whether to include the time spent in garbage collection in the result or not.
   * @return Elapsed time, in milliseconds.
   */
  public static long elapsedTime(long id, boolean includeGc) {
    Pair<Long, Long> elapsedGcTimes = elapsedAndGcTime(id);
    long elapsedTime = elapsedGcTimes.getFirst();
    long gcTime = elapsedGcTimes.getSecond();
    return includeGc ? elapsedTime : elapsedTime - gcTime;
  }

  /**
   * Returns both the total and the GC elapsed times since the counter was created.
   * @param id Id generated by getNewTimeId.
   * @return Total and GC elapsed times, in milliseconds. The GC time is always smaller or equal
   * than the total time.
   */
  public static Pair<Long, Long> elapsedAndGcTime(long id) {
    // first take times
    long milliTime = milliTime();
    long milliGcTime = milliGcTime();
    // now do the calculations
    Pair<Long, Long> startTimes = times.get(id);
    long startTime = startTimes.getFirst();
    long startGcTime = startTimes.getSecond();
    return new Pair<Long, Long>(milliTime - startTime, milliGcTime - startGcTime);
  }

  private static long milliTime() {
    return System.nanoTime() / 1000000;
  }

  public static long milliGcTime() {
    long result = 0;
    for (GarbageCollectorMXBean garbageCollectorMXBean : garbageCollectorMXBeans) {
      // the collection time is already in milliseconds,
      result += Math.max(0, garbageCollectorMXBean.getCollectionTime());
    }
    return result;
  }
}
