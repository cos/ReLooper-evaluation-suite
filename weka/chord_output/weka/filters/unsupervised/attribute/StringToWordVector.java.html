<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">
<META NAME="GENERATOR" CONTENT="Java2HTML Version 1.5">
<TITLE>weka.filters.unsupervised.attribute.StringToWordVector (Java2HTML)</TITLE>
</HEAD>
<BODY><TABLE id="Header" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td colspan="2" width="33%">&nbsp;</td>
<td align="center" colspan="2" width="33%">
<font size="4">StringToWordVector.java</font>
</td>
<td align="right" colspan="2" width="33%">&nbsp;</td>
</tr>
</TABLE>
<pre ID="Classes">
<FONT ID="LN">1   </FONT><A NAME="1"></A><FONT ID="MultiLineComment">/*
<FONT ID="LN">2   </FONT><A NAME="2"></A> *    This program is free software; you can redistribute it and/or modify
<FONT ID="LN">3   </FONT><A NAME="3"></A> *    it under the terms of the GNU General Public License as published by
<FONT ID="LN">4   </FONT><A NAME="4"></A> *    the Free Software Foundation; either version 2 of the License, or
<FONT ID="LN">5   </FONT><A NAME="5"></A> *    (at your option) any later version.
<FONT ID="LN">6   </FONT><A NAME="6"></A> *
<FONT ID="LN">7   </FONT><A NAME="7"></A> *    This program is distributed in the hope that it will be useful,
<FONT ID="LN">8   </FONT><A NAME="8"></A> *    but WITHOUT ANY WARRANTY; without even the implied warranty of
<FONT ID="LN">9   </FONT><A NAME="9"></A> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<FONT ID="LN">10  </FONT><A NAME="10"></A> *    GNU General Public License for more details.
<FONT ID="LN">11  </FONT><A NAME="11"></A> *
<FONT ID="LN">12  </FONT><A NAME="12"></A> *    You should have received a copy of the GNU General Public License
<FONT ID="LN">13  </FONT><A NAME="13"></A> *    along with this program; if not, write to the Free Software
<FONT ID="LN">14  </FONT><A NAME="14"></A> *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<FONT ID="LN">15  </FONT><A NAME="15"></A> */</FONT>
<FONT ID="LN">16  </FONT><A NAME="16"></A>
<FONT ID="LN">17  </FONT><A NAME="17"></A><FONT ID="MultiLineComment">/*
<FONT ID="LN">18  </FONT><A NAME="18"></A> *    StringToWordVector.java
<FONT ID="LN">19  </FONT><A NAME="19"></A> *    Copyright (C) 2002 University of Waikato, Hamilton, New Zealand
<FONT ID="LN">20  </FONT><A NAME="20"></A> *
<FONT ID="LN">21  </FONT><A NAME="21"></A> */</FONT>
<FONT ID="LN">22  </FONT><A NAME="22"></A>
<FONT ID="LN">23  </FONT><A NAME="23"></A><FONT ID="Package">package</FONT> weka.filters.unsupervised.attribute;
<FONT ID="LN">24  </FONT><A NAME="24"></A>
<FONT ID="LN">25  </FONT><A NAME="25"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Attribute.java.html">weka.core.Attribute</A>;
<FONT ID="LN">26  </FONT><A NAME="26"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Capabilities.java.html">weka.core.Capabilities</A>;
<FONT ID="LN">27  </FONT><A NAME="27"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/FastVector.java.html">weka.core.FastVector</A>;
<FONT ID="LN">28  </FONT><A NAME="28"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Instance.java.html">weka.core.Instance</A>; 
<FONT ID="LN">29  </FONT><A NAME="29"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/DenseInstance.java.html">weka.core.DenseInstance</A>;
<FONT ID="LN">30  </FONT><A NAME="30"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Instances.java.html">weka.core.Instances</A>;
<FONT ID="LN">31  </FONT><A NAME="31"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Option.java.html">weka.core.Option</A>;
<FONT ID="LN">32  </FONT><A NAME="32"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/OptionHandler.java.html">weka.core.OptionHandler</A>;
<FONT ID="LN">33  </FONT><A NAME="33"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Range.java.html">weka.core.Range</A>;
<FONT ID="LN">34  </FONT><A NAME="34"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/RevisionHandler.java.html">weka.core.RevisionHandler</A>;
<FONT ID="LN">35  </FONT><A NAME="35"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/RevisionUtils.java.html">weka.core.RevisionUtils</A>;
<FONT ID="LN">36  </FONT><A NAME="36"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">weka.core.SelectedTag</A>;
<FONT ID="LN">37  </FONT><A NAME="37"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/SparseInstance.java.html">weka.core.SparseInstance</A>;
<FONT ID="LN">38  </FONT><A NAME="38"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Stopwords.java.html">weka.core.Stopwords</A>;
<FONT ID="LN">39  </FONT><A NAME="39"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Tag.java.html">weka.core.Tag</A>;
<FONT ID="LN">40  </FONT><A NAME="40"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Utils.java.html">weka.core.Utils</A>;
<FONT ID="LN">41  </FONT><A NAME="41"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/Capabilities.java.html">weka.core.Capabilities.Capability</A>;
<FONT ID="LN">42  </FONT><A NAME="42"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">weka.core.stemmers.NullStemmer</A>;
<FONT ID="LN">43  </FONT><A NAME="43"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/stemmers/Stemmer.java.html">weka.core.stemmers.Stemmer</A>;
<FONT ID="LN">44  </FONT><A NAME="44"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">weka.core.tokenizers.Tokenizer</A>;
<FONT ID="LN">45  </FONT><A NAME="45"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/core/tokenizers/WordTokenizer.java.html">weka.core.tokenizers.WordTokenizer</A>;
<FONT ID="LN">46  </FONT><A NAME="46"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/filters/Filter.java.html">weka.filters.Filter</A>;
<FONT ID="LN">47  </FONT><A NAME="47"></A><FONT ID="Import">import</FONT> <A HREF="../../../../weka/filters/UnsupervisedFilter.java.html">weka.filters.UnsupervisedFilter</A>;
<FONT ID="LN">48  </FONT><A NAME="48"></A>
<FONT ID="LN">49  </FONT><A NAME="49"></A><FONT ID="Import">import</FONT> java.io.File;
<FONT ID="LN">50  </FONT><A NAME="50"></A><FONT ID="Import">import</FONT> java.io.Serializable;
<FONT ID="LN">51  </FONT><A NAME="51"></A><FONT ID="Import">import</FONT> java.util.Enumeration;
<FONT ID="LN">52  </FONT><A NAME="52"></A><FONT ID="Import">import</FONT> java.util.Hashtable;
<FONT ID="LN">53  </FONT><A NAME="53"></A><FONT ID="Import">import</FONT> java.util.Iterator;
<FONT ID="LN">54  </FONT><A NAME="54"></A><FONT ID="Import">import</FONT> java.util.TreeMap;
<FONT ID="LN">55  </FONT><A NAME="55"></A><FONT ID="Import">import</FONT> java.util.Vector;
<FONT ID="LN">56  </FONT><A NAME="56"></A>
<FONT ID="LN">57  </FONT><A NAME="57"></A><FONT ID="FormalComment">/** 
<FONT ID="LN">58  </FONT><A NAME="58"></A> &lt;!-- globalinfo-start --&gt;
<FONT ID="LN">59  </FONT><A NAME="59"></A> * Converts String attributes into a set of attributes representing word occurrence (depending on the tokenizer) information from the text contained in the strings. The set of words (attributes) is determined by the first batch filtered (typically training data).
<FONT ID="LN">60  </FONT><A NAME="60"></A> * &lt;p/&gt;
<FONT ID="LN">61  </FONT><A NAME="61"></A> &lt;!-- globalinfo-end --&gt;
<FONT ID="LN">62  </FONT><A NAME="62"></A> * 
<FONT ID="LN">63  </FONT><A NAME="63"></A> &lt;!-- options-start --&gt;
<FONT ID="LN">64  </FONT><A NAME="64"></A> * Valid options are: &lt;p/&gt;
<FONT ID="LN">65  </FONT><A NAME="65"></A> * 
<FONT ID="LN">66  </FONT><A NAME="66"></A> * &lt;pre&gt; -C
<FONT ID="LN">67  </FONT><A NAME="67"></A> *  Output word counts rather than boolean word presence.
<FONT ID="LN">68  </FONT><A NAME="68"></A> * &lt;/pre&gt;
<FONT ID="LN">69  </FONT><A NAME="69"></A> * 
<FONT ID="LN">70  </FONT><A NAME="70"></A> * &lt;pre&gt; -R &amp;lt;index1,index2-index4,...&amp;gt;
<FONT ID="LN">71  </FONT><A NAME="71"></A> *  Specify list of string attributes to convert to words (as weka Range).
<FONT ID="LN">72  </FONT><A NAME="72"></A> *  (default: select all string attributes)&lt;/pre&gt;
<FONT ID="LN">73  </FONT><A NAME="73"></A> * 
<FONT ID="LN">74  </FONT><A NAME="74"></A> * &lt;pre&gt; -V
<FONT ID="LN">75  </FONT><A NAME="75"></A> *  Invert matching sense of column indexes.&lt;/pre&gt;
<FONT ID="LN">76  </FONT><A NAME="76"></A> * 
<FONT ID="LN">77  </FONT><A NAME="77"></A> * &lt;pre&gt; -P &amp;lt;attribute name prefix&amp;gt;
<FONT ID="LN">78  </FONT><A NAME="78"></A> *  Specify a prefix for the created attribute names.
<FONT ID="LN">79  </FONT><A NAME="79"></A> *  (default: "")&lt;/pre&gt;
<FONT ID="LN">80  </FONT><A NAME="80"></A> * 
<FONT ID="LN">81  </FONT><A NAME="81"></A> * &lt;pre&gt; -W &amp;lt;number of words to keep&amp;gt;
<FONT ID="LN">82  </FONT><A NAME="82"></A> *  Specify approximate number of word fields to create.
<FONT ID="LN">83  </FONT><A NAME="83"></A> *  Surplus words will be discarded..
<FONT ID="LN">84  </FONT><A NAME="84"></A> *  (default: 1000)&lt;/pre&gt;
<FONT ID="LN">85  </FONT><A NAME="85"></A> * 
<FONT ID="LN">86  </FONT><A NAME="86"></A> * &lt;pre&gt; -prune-rate &amp;lt;rate as a percentage of dataset&amp;gt;
<FONT ID="LN">87  </FONT><A NAME="87"></A> *  Specify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.
<FONT ID="LN">88  </FONT><A NAME="88"></A> *  -W prunes after creating a full dictionary. You may not have enough memory for this approach.
<FONT ID="LN">89  </FONT><A NAME="89"></A> *  (default: no periodic pruning)&lt;/pre&gt;
<FONT ID="LN">90  </FONT><A NAME="90"></A> * 
<FONT ID="LN">91  </FONT><A NAME="91"></A> * &lt;pre&gt; -T
<FONT ID="LN">92  </FONT><A NAME="92"></A> *  Transform the word frequencies into log(1+fij)
<FONT ID="LN">93  </FONT><A NAME="93"></A> *  where fij is the frequency of word i in jth document(instance).
<FONT ID="LN">94  </FONT><A NAME="94"></A> * &lt;/pre&gt;
<FONT ID="LN">95  </FONT><A NAME="95"></A> * 
<FONT ID="LN">96  </FONT><A NAME="96"></A> * &lt;pre&gt; -I
<FONT ID="LN">97  </FONT><A NAME="97"></A> *  Transform each word frequency into:
<FONT ID="LN">98  </FONT><A NAME="98"></A> *  fij*log(num of Documents/num of documents containing word i)
<FONT ID="LN">99  </FONT><A NAME="99"></A> *    where fij if frequency of word i in jth document(instance)&lt;/pre&gt;
<FONT ID="LN">100 </FONT><A NAME="100"></A> * 
<FONT ID="LN">101 </FONT><A NAME="101"></A> * &lt;pre&gt; -N
<FONT ID="LN">102 </FONT><A NAME="102"></A> *  Whether to 0=not normalize/1=normalize all data/2=normalize test data only
<FONT ID="LN">103 </FONT><A NAME="103"></A> *  to average length of training documents (default 0=don't normalize).&lt;/pre&gt;
<FONT ID="LN">104 </FONT><A NAME="104"></A> * 
<FONT ID="LN">105 </FONT><A NAME="105"></A> * &lt;pre&gt; -L
<FONT ID="LN">106 </FONT><A NAME="106"></A> *  Convert all tokens to lowercase before adding to the dictionary.&lt;/pre&gt;
<FONT ID="LN">107 </FONT><A NAME="107"></A> * 
<FONT ID="LN">108 </FONT><A NAME="108"></A> * &lt;pre&gt; -S
<FONT ID="LN">109 </FONT><A NAME="109"></A> *  Ignore words that are in the stoplist.&lt;/pre&gt;
<FONT ID="LN">110 </FONT><A NAME="110"></A> * 
<FONT ID="LN">111 </FONT><A NAME="111"></A> * &lt;pre&gt; -stemmer &amp;lt;spec&amp;gt;
<FONT ID="LN">112 </FONT><A NAME="112"></A> *  The stemmering algorihtm (classname plus parameters) to use.&lt;/pre&gt;
<FONT ID="LN">113 </FONT><A NAME="113"></A> * 
<FONT ID="LN">114 </FONT><A NAME="114"></A> * &lt;pre&gt; -M &amp;lt;int&amp;gt;
<FONT ID="LN">115 </FONT><A NAME="115"></A> *  The minimum term frequency (default = 1).&lt;/pre&gt;
<FONT ID="LN">116 </FONT><A NAME="116"></A> * 
<FONT ID="LN">117 </FONT><A NAME="117"></A> * &lt;pre&gt; -O
<FONT ID="LN">118 </FONT><A NAME="118"></A> *  If this is set, the maximum number of words and the 
<FONT ID="LN">119 </FONT><A NAME="119"></A> *  minimum term frequency is not enforced on a per-class 
<FONT ID="LN">120 </FONT><A NAME="120"></A> *  basis but based on the documents in all the classes 
<FONT ID="LN">121 </FONT><A NAME="121"></A> *  (even if a class attribute is set).&lt;/pre&gt;
<FONT ID="LN">122 </FONT><A NAME="122"></A> * 
<FONT ID="LN">123 </FONT><A NAME="123"></A> * &lt;pre&gt; -stopwords &amp;lt;file&amp;gt;
<FONT ID="LN">124 </FONT><A NAME="124"></A> *  A file containing stopwords to override the default ones.
<FONT ID="LN">125 </FONT><A NAME="125"></A> *  Using this option automatically sets the flag ('-S') to use the
<FONT ID="LN">126 </FONT><A NAME="126"></A> *  stoplist if the file exists.
<FONT ID="LN">127 </FONT><A NAME="127"></A> *  Format: one stopword per line, lines starting with '#'
<FONT ID="LN">128 </FONT><A NAME="128"></A> *  are interpreted as comments and ignored.&lt;/pre&gt;
<FONT ID="LN">129 </FONT><A NAME="129"></A> * 
<FONT ID="LN">130 </FONT><A NAME="130"></A> * &lt;pre&gt; -tokenizer &amp;lt;spec&amp;gt;
<FONT ID="LN">131 </FONT><A NAME="131"></A> *  The tokenizing algorihtm (classname plus parameters) to use.
<FONT ID="LN">132 </FONT><A NAME="132"></A> *  (default: weka.core.tokenizers.WordTokenizer)&lt;/pre&gt;
<FONT ID="LN">133 </FONT><A NAME="133"></A> * 
<FONT ID="LN">134 </FONT><A NAME="134"></A> &lt;!-- options-end --&gt;
<FONT ID="LN">135 </FONT><A NAME="135"></A> *
<FONT ID="LN">136 </FONT><A NAME="136"></A> * @author Len Trigg (len@reeltwo.com)
<FONT ID="LN">137 </FONT><A NAME="137"></A> * @author Stuart Inglis (stuart@reeltwo.com)
<FONT ID="LN">138 </FONT><A NAME="138"></A> * @author Gordon Paynter (gordon.paynter@ucr.edu)
<FONT ID="LN">139 </FONT><A NAME="139"></A> * @author Asrhaf M. Kibriya (amk14@cs.waikato.ac.nz)
<FONT ID="LN">140 </FONT><A NAME="140"></A> * @version $Revision: 5987 $ 
<FONT ID="LN">141 </FONT><A NAME="141"></A> * @see Stopwords
<FONT ID="LN">142 </FONT><A NAME="142"></A> */</FONT>
<FONT ID="LN">143 </FONT><A NAME="143"></A><FONT ID="Public">public</FONT> <FONT ID="Class">class</FONT> StringToWordVector 
<FONT ID="LN">144 </FONT><A NAME="144"></A>  <FONT ID="Extends">extends</FONT> <A HREF="../../../../weka/filters/Filter.java.html">Filter</A>
<FONT ID="LN">145 </FONT><A NAME="145"></A>  <FONT ID="Implements">implements</FONT> <A HREF="../../../../weka/filters/UnsupervisedFilter.java.html">UnsupervisedFilter</A>, <A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A> {
<FONT ID="LN">146 </FONT><A NAME="146"></A>
<FONT ID="LN">147 </FONT><A NAME="147"></A>  <FONT ID="FormalComment">/** for serialization. */</FONT>
<FONT ID="LN">148 </FONT><A NAME="148"></A>  <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = <FONT ID="IntegerLiteral">8249106275278565424L</FONT>;
<FONT ID="LN">149 </FONT><A NAME="149"></A>
<FONT ID="LN">150 </FONT><A NAME="150"></A>  <FONT ID="FormalComment">/** Range of columns to convert to word vectors. */</FONT>
<FONT ID="LN">151 </FONT><A NAME="151"></A>  <FONT ID="Protected">protected</FONT> <A HREF="../../../../weka/core/Range.java.html">Range</A> m_SelectedRange = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Range.java.html">Range</A>(<FONT ID="StringLiteral">"first-last"</FONT>);
<FONT ID="LN">152 </FONT><A NAME="152"></A>
<FONT ID="LN">153 </FONT><A NAME="153"></A>  <FONT ID="FormalComment">/** Contains a mapping of valid words to attribute indexes. */</FONT>
<FONT ID="LN">154 </FONT><A NAME="154"></A>  <FONT ID="Private">private</FONT> TreeMap m_Dictionary = <FONT ID="New">new</FONT> TreeMap();
<FONT ID="LN">155 </FONT><A NAME="155"></A>
<FONT ID="LN">156 </FONT><A NAME="156"></A>  <FONT ID="FormalComment">/** True if output instances should contain word frequency rather than boolean 0 or 1. */</FONT>
<FONT ID="LN">157 </FONT><A NAME="157"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_OutputCounts = <FONT ID="False">false</FONT>;
<FONT ID="LN">158 </FONT><A NAME="158"></A>
<FONT ID="LN">159 </FONT><A NAME="159"></A>  <FONT ID="FormalComment">/** A String prefix for the attribute names. */</FONT>
<FONT ID="LN">160 </FONT><A NAME="160"></A>  <FONT ID="Private">private</FONT> String m_Prefix = <FONT ID="StringLiteral">""</FONT>;
<FONT ID="LN">161 </FONT><A NAME="161"></A>
<FONT ID="LN">162 </FONT><A NAME="162"></A>  <FONT ID="FormalComment">/** Contains the number of documents (instances) a particular word appears in.
<FONT ID="LN">163 </FONT><A NAME="163"></A>          The counts are stored with the same indexing as given by m_Dictionary.  */</FONT>
<FONT ID="LN">164 </FONT><A NAME="164"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> [] m_DocsCounts;
<FONT ID="LN">165 </FONT><A NAME="165"></A>
<FONT ID="LN">166 </FONT><A NAME="166"></A>  <FONT ID="FormalComment">/** Contains the number of documents (instances) in the input format from 
<FONT ID="LN">167 </FONT><A NAME="167"></A>          which the dictionary is created. It is used in IDF transform. */</FONT>
<FONT ID="LN">168 </FONT><A NAME="168"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_NumInstances = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">169 </FONT><A NAME="169"></A>
<FONT ID="LN">170 </FONT><A NAME="170"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">171 </FONT><A NAME="171"></A>   * Contains the average length of documents (among the first batch of 
<FONT ID="LN">172 </FONT><A NAME="172"></A>   * instances aka training data). This is used in length normalization of 
<FONT ID="LN">173 </FONT><A NAME="173"></A>   * documents which will be normalized to average document length.
<FONT ID="LN">174 </FONT><A NAME="174"></A>   */</FONT>
<FONT ID="LN">175 </FONT><A NAME="175"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_AvgDocLength = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">176 </FONT><A NAME="176"></A>
<FONT ID="LN">177 </FONT><A NAME="177"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">178 </FONT><A NAME="178"></A>   * The default number of words (per class if there is a class attribute
<FONT ID="LN">179 </FONT><A NAME="179"></A>   * assigned) to attempt to keep.
<FONT ID="LN">180 </FONT><A NAME="180"></A>   */</FONT>
<FONT ID="LN">181 </FONT><A NAME="181"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_WordsToKeep = <FONT ID="IntegerLiteral">1000</FONT>;
<FONT ID="LN">182 </FONT><A NAME="182"></A>
<FONT ID="LN">183 </FONT><A NAME="183"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">184 </FONT><A NAME="184"></A>   * The percentage at which to periodically prune the dictionary.
<FONT ID="LN">185 </FONT><A NAME="185"></A>   */</FONT>
<FONT ID="LN">186 </FONT><A NAME="186"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_PeriodicPruningRate = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">187 </FONT><A NAME="187"></A>
<FONT ID="LN">188 </FONT><A NAME="188"></A>  <FONT ID="FormalComment">/** True if word frequencies should be transformed into log(1+fi) 
<FONT ID="LN">189 </FONT><A NAME="189"></A>          where fi is the frequency of word i.
<FONT ID="LN">190 </FONT><A NAME="190"></A>   */</FONT>
<FONT ID="LN">191 </FONT><A NAME="191"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_TFTransform;
<FONT ID="LN">192 </FONT><A NAME="192"></A>
<FONT ID="LN">193 </FONT><A NAME="193"></A>  <FONT ID="FormalComment">/** The normalization to apply. */</FONT>
<FONT ID="LN">194 </FONT><A NAME="194"></A>  <FONT ID="Protected">protected</FONT> <FONT ID="Int">int</FONT> m_filterType = FILTER_NONE;
<FONT ID="LN">195 </FONT><A NAME="195"></A>
<FONT ID="LN">196 </FONT><A NAME="196"></A>  <FONT ID="FormalComment">/** normalization: No normalization. */</FONT>
<FONT ID="LN">197 </FONT><A NAME="197"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Int">int</FONT> FILTER_NONE = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">198 </FONT><A NAME="198"></A>  <FONT ID="FormalComment">/** normalization: Normalize all data. */</FONT>
<FONT ID="LN">199 </FONT><A NAME="199"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Int">int</FONT> FILTER_NORMALIZE_ALL = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">200 </FONT><A NAME="200"></A>  <FONT ID="FormalComment">/** normalization: Normalize test data only. */</FONT>
<FONT ID="LN">201 </FONT><A NAME="201"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Int">int</FONT> FILTER_NORMALIZE_TEST_ONLY = <FONT ID="IntegerLiteral">2</FONT>;
<FONT ID="LN">202 </FONT><A NAME="202"></A>
<FONT ID="LN">203 </FONT><A NAME="203"></A>  <FONT ID="FormalComment">/** Specifies whether document's (instance's) word frequencies are
<FONT ID="LN">204 </FONT><A NAME="204"></A>   * to be normalized.  The are normalized to average length of
<FONT ID="LN">205 </FONT><A NAME="205"></A>   * documents specified as input format. */</FONT>
<FONT ID="LN">206 </FONT><A NAME="206"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">Tag</A> [] TAGS_FILTER = {
<FONT ID="LN">207 </FONT><A NAME="207"></A>    <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">Tag</A>(FILTER_NONE, <FONT ID="StringLiteral">"No normalization"</FONT>),
<FONT ID="LN">208 </FONT><A NAME="208"></A>    <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">Tag</A>(FILTER_NORMALIZE_ALL, <FONT ID="StringLiteral">"Normalize all data"</FONT>),
<FONT ID="LN">209 </FONT><A NAME="209"></A>    <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">Tag</A>(FILTER_NORMALIZE_TEST_ONLY, <FONT ID="StringLiteral">"Normalize test data only"</FONT>),
<FONT ID="LN">210 </FONT><A NAME="210"></A>  };
<FONT ID="LN">211 </FONT><A NAME="211"></A>
<FONT ID="LN">212 </FONT><A NAME="212"></A>  <FONT ID="FormalComment">/** True if word frequencies should be transformed into 
<FONT ID="LN">213 </FONT><A NAME="213"></A>          fij*log(numOfDocs/numOfDocsWithWordi). */</FONT>
<FONT ID="LN">214 </FONT><A NAME="214"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_IDFTransform;
<FONT ID="LN">215 </FONT><A NAME="215"></A>
<FONT ID="LN">216 </FONT><A NAME="216"></A>  <FONT ID="FormalComment">/** True if all tokens should be downcased. */</FONT>
<FONT ID="LN">217 </FONT><A NAME="217"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_lowerCaseTokens;
<FONT ID="LN">218 </FONT><A NAME="218"></A>
<FONT ID="LN">219 </FONT><A NAME="219"></A>  <FONT ID="FormalComment">/** True if tokens that are on a stoplist are to be ignored. */</FONT>
<FONT ID="LN">220 </FONT><A NAME="220"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_useStoplist;  
<FONT ID="LN">221 </FONT><A NAME="221"></A>
<FONT ID="LN">222 </FONT><A NAME="222"></A>  <FONT ID="FormalComment">/** the stemming algorithm. */</FONT>
<FONT ID="LN">223 </FONT><A NAME="223"></A>  <FONT ID="Private">private</FONT> <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">Stemmer</A> m_Stemmer = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">NullStemmer</A>();
<FONT ID="LN">224 </FONT><A NAME="224"></A>
<FONT ID="LN">225 </FONT><A NAME="225"></A>  <FONT ID="FormalComment">/** the minimum (per-class) word frequency. */</FONT>
<FONT ID="LN">226 </FONT><A NAME="226"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_minTermFreq = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">227 </FONT><A NAME="227"></A>
<FONT ID="LN">228 </FONT><A NAME="228"></A>  <FONT ID="FormalComment">/** whether to operate on a per-class basis. */</FONT>
<FONT ID="LN">229 </FONT><A NAME="229"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_doNotOperateOnPerClassBasis = <FONT ID="False">false</FONT>;
<FONT ID="LN">230 </FONT><A NAME="230"></A>
<FONT ID="LN">231 </FONT><A NAME="231"></A>  <FONT ID="FormalComment">/** a file containing stopwords for using others than the default Rainbow 
<FONT ID="LN">232 </FONT><A NAME="232"></A>   * ones. */</FONT>
<FONT ID="LN">233 </FONT><A NAME="233"></A>  <FONT ID="Private">private</FONT> File m_Stopwords = <FONT ID="New">new</FONT> File(System.getProperty(<FONT ID="StringLiteral">"user.dir"</FONT>));
<FONT ID="LN">234 </FONT><A NAME="234"></A>
<FONT ID="LN">235 </FONT><A NAME="235"></A>  <FONT ID="FormalComment">/** the tokenizer algorithm to use. */</FONT>
<FONT ID="LN">236 </FONT><A NAME="236"></A>  <FONT ID="Private">private</FONT> <A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">Tokenizer</A> m_Tokenizer = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/tokenizers/WordTokenizer.java.html">WordTokenizer</A>();
<FONT ID="LN">237 </FONT><A NAME="237"></A>
<FONT ID="LN">238 </FONT><A NAME="238"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">239 </FONT><A NAME="239"></A>   * Default constructor. Targets 1000 words in the output.
<FONT ID="LN">240 </FONT><A NAME="240"></A>   */</FONT>
<FONT ID="LN">241 </FONT><A NAME="241"></A>  <FONT ID="Public">public</FONT> StringToWordVector() {
<FONT ID="LN">242 </FONT><A NAME="242"></A>  }
<FONT ID="LN">243 </FONT><A NAME="243"></A>
<FONT ID="LN">244 </FONT><A NAME="244"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">245 </FONT><A NAME="245"></A>   * Returns an enumeration describing the available options.
<FONT ID="LN">246 </FONT><A NAME="246"></A>   *
<FONT ID="LN">247 </FONT><A NAME="247"></A>   * @return an enumeration of all the available options
<FONT ID="LN">248 </FONT><A NAME="248"></A>   */</FONT>
<FONT ID="LN">249 </FONT><A NAME="249"></A>  <FONT ID="Public">public</FONT> Enumeration listOptions() {
<FONT ID="LN">250 </FONT><A NAME="250"></A>    <A HREF="../../../../weka/core/FastVector.java.html">Vector</A> result = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">Vector</A>();
<FONT ID="LN">251 </FONT><A NAME="251"></A>
<FONT ID="LN">252 </FONT><A NAME="252"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">253 </FONT><A NAME="253"></A>    <FONT ID="StringLiteral">"\tOutput word counts rather than boolean word presence.\n"</FONT>,
<FONT ID="LN">254 </FONT><A NAME="254"></A>    <FONT ID="StringLiteral">"C"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-C"</FONT>));
<FONT ID="LN">255 </FONT><A NAME="255"></A>
<FONT ID="LN">256 </FONT><A NAME="256"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">257 </FONT><A NAME="257"></A>    <FONT ID="StringLiteral">"\tSpecify list of string attributes to convert to words (as weka Range).\n"</FONT>
<FONT ID="LN">258 </FONT><A NAME="258"></A>    + <FONT ID="StringLiteral">"\t(default: select all string attributes)"</FONT>,
<FONT ID="LN">259 </FONT><A NAME="259"></A>    <FONT ID="StringLiteral">"R"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-R &lt;index1,index2-index4,...&gt;"</FONT>));
<FONT ID="LN">260 </FONT><A NAME="260"></A>
<FONT ID="LN">261 </FONT><A NAME="261"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">262 </FONT><A NAME="262"></A>    <FONT ID="StringLiteral">"\tInvert matching sense of column indexes."</FONT>,
<FONT ID="LN">263 </FONT><A NAME="263"></A>    <FONT ID="StringLiteral">"V"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-V"</FONT>));
<FONT ID="LN">264 </FONT><A NAME="264"></A>
<FONT ID="LN">265 </FONT><A NAME="265"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">266 </FONT><A NAME="266"></A>    <FONT ID="StringLiteral">"\tSpecify a prefix for the created attribute names.\n"</FONT>
<FONT ID="LN">267 </FONT><A NAME="267"></A>    + <FONT ID="StringLiteral">"\t(default: \"\")"</FONT>,
<FONT ID="LN">268 </FONT><A NAME="268"></A>    <FONT ID="StringLiteral">"P"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-P &lt;attribute name prefix&gt;"</FONT>));
<FONT ID="LN">269 </FONT><A NAME="269"></A>
<FONT ID="LN">270 </FONT><A NAME="270"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">271 </FONT><A NAME="271"></A>    <FONT ID="StringLiteral">"\tSpecify approximate number of word fields to create.\n"</FONT>
<FONT ID="LN">272 </FONT><A NAME="272"></A>    + <FONT ID="StringLiteral">"\tSurplus words will be discarded..\n"</FONT>
<FONT ID="LN">273 </FONT><A NAME="273"></A>    + <FONT ID="StringLiteral">"\t(default: 1000)"</FONT>,
<FONT ID="LN">274 </FONT><A NAME="274"></A>    <FONT ID="StringLiteral">"W"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-W &lt;number of words to keep&gt;"</FONT>));
<FONT ID="LN">275 </FONT><A NAME="275"></A>
<FONT ID="LN">276 </FONT><A NAME="276"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">277 </FONT><A NAME="277"></A>    <FONT ID="StringLiteral">"\tSpecify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.\n"</FONT>
<FONT ID="LN">278 </FONT><A NAME="278"></A>    + <FONT ID="StringLiteral">"\t-W prunes after creating a full dictionary. You may not have enough memory for this approach.\n"</FONT>
<FONT ID="LN">279 </FONT><A NAME="279"></A>    + <FONT ID="StringLiteral">"\t(default: no periodic pruning)"</FONT>,
<FONT ID="LN">280 </FONT><A NAME="280"></A>    <FONT ID="StringLiteral">"prune-rate"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-prune-rate &lt;rate as a percentage of dataset&gt;"</FONT>));
<FONT ID="LN">281 </FONT><A NAME="281"></A>
<FONT ID="LN">282 </FONT><A NAME="282"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">283 </FONT><A NAME="283"></A>    <FONT ID="StringLiteral">"\tTransform the word frequencies into log(1+fij)\n"</FONT>+
<FONT ID="LN">284 </FONT><A NAME="284"></A>    <FONT ID="StringLiteral">"\twhere fij is the frequency of word i in jth document(instance).\n"</FONT>,
<FONT ID="LN">285 </FONT><A NAME="285"></A>    <FONT ID="StringLiteral">"T"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-T"</FONT>));
<FONT ID="LN">286 </FONT><A NAME="286"></A>
<FONT ID="LN">287 </FONT><A NAME="287"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">288 </FONT><A NAME="288"></A>    <FONT ID="StringLiteral">"\tTransform each word frequency into:\n"</FONT>+
<FONT ID="LN">289 </FONT><A NAME="289"></A>    <FONT ID="StringLiteral">"\tfij*log(num of Documents/num of documents containing word i)\n"</FONT>+
<FONT ID="LN">290 </FONT><A NAME="290"></A>    <FONT ID="StringLiteral">"\t  where fij if frequency of word i in jth document(instance)"</FONT>,
<FONT ID="LN">291 </FONT><A NAME="291"></A>    <FONT ID="StringLiteral">"I"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-I"</FONT>));
<FONT ID="LN">292 </FONT><A NAME="292"></A>
<FONT ID="LN">293 </FONT><A NAME="293"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">294 </FONT><A NAME="294"></A>    <FONT ID="StringLiteral">"\tWhether to 0=not normalize/1=normalize all data/2=normalize test data only\n"</FONT> 
<FONT ID="LN">295 </FONT><A NAME="295"></A>    + <FONT ID="StringLiteral">"\tto average length of training documents "</FONT>
<FONT ID="LN">296 </FONT><A NAME="296"></A>    + <FONT ID="StringLiteral">"(default 0=don\'t normalize)."</FONT>,
<FONT ID="LN">297 </FONT><A NAME="297"></A>    <FONT ID="StringLiteral">"N"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-N"</FONT>));
<FONT ID="LN">298 </FONT><A NAME="298"></A>
<FONT ID="LN">299 </FONT><A NAME="299"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">300 </FONT><A NAME="300"></A>    <FONT ID="StringLiteral">"\tConvert all tokens to lowercase before "</FONT>+
<FONT ID="LN">301 </FONT><A NAME="301"></A>    <FONT ID="StringLiteral">"adding to the dictionary."</FONT>,
<FONT ID="LN">302 </FONT><A NAME="302"></A>    <FONT ID="StringLiteral">"L"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-L"</FONT>));
<FONT ID="LN">303 </FONT><A NAME="303"></A>
<FONT ID="LN">304 </FONT><A NAME="304"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">305 </FONT><A NAME="305"></A>    <FONT ID="StringLiteral">"\tIgnore words that are in the stoplist."</FONT>,
<FONT ID="LN">306 </FONT><A NAME="306"></A>    <FONT ID="StringLiteral">"S"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-S"</FONT>));
<FONT ID="LN">307 </FONT><A NAME="307"></A>
<FONT ID="LN">308 </FONT><A NAME="308"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">309 </FONT><A NAME="309"></A>    <FONT ID="StringLiteral">"\tThe stemmering algorihtm (classname plus parameters) to use."</FONT>,
<FONT ID="LN">310 </FONT><A NAME="310"></A>    <FONT ID="StringLiteral">"stemmer"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-stemmer &lt;spec&gt;"</FONT>));
<FONT ID="LN">311 </FONT><A NAME="311"></A>
<FONT ID="LN">312 </FONT><A NAME="312"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">313 </FONT><A NAME="313"></A>    <FONT ID="StringLiteral">"\tThe minimum term frequency (default = 1)."</FONT>,
<FONT ID="LN">314 </FONT><A NAME="314"></A>    <FONT ID="StringLiteral">"M"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-M &lt;int&gt;"</FONT>));
<FONT ID="LN">315 </FONT><A NAME="315"></A>
<FONT ID="LN">316 </FONT><A NAME="316"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">317 </FONT><A NAME="317"></A>    <FONT ID="StringLiteral">"\tIf this is set, the maximum number of words and the \n"</FONT>
<FONT ID="LN">318 </FONT><A NAME="318"></A>    + <FONT ID="StringLiteral">"\tminimum term frequency is not enforced on a per-class \n"</FONT>
<FONT ID="LN">319 </FONT><A NAME="319"></A>    + <FONT ID="StringLiteral">"\tbasis but based on the documents in all the classes \n"</FONT>
<FONT ID="LN">320 </FONT><A NAME="320"></A>    + <FONT ID="StringLiteral">"\t(even if a class attribute is set)."</FONT>,
<FONT ID="LN">321 </FONT><A NAME="321"></A>    <FONT ID="StringLiteral">"O"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-O"</FONT>));
<FONT ID="LN">322 </FONT><A NAME="322"></A>
<FONT ID="LN">323 </FONT><A NAME="323"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">324 </FONT><A NAME="324"></A>    <FONT ID="StringLiteral">"\tA file containing stopwords to override the default ones.\n"</FONT>
<FONT ID="LN">325 </FONT><A NAME="325"></A>    + <FONT ID="StringLiteral">"\tUsing this option automatically sets the flag ('-S') to use the\n"</FONT>
<FONT ID="LN">326 </FONT><A NAME="326"></A>    + <FONT ID="StringLiteral">"\tstoplist if the file exists.\n"</FONT>
<FONT ID="LN">327 </FONT><A NAME="327"></A>    + <FONT ID="StringLiteral">"\tFormat: one stopword per line, lines starting with '#'\n"</FONT>
<FONT ID="LN">328 </FONT><A NAME="328"></A>    + <FONT ID="StringLiteral">"\tare interpreted as comments and ignored."</FONT>,
<FONT ID="LN">329 </FONT><A NAME="329"></A>    <FONT ID="StringLiteral">"stopwords"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-stopwords &lt;file&gt;"</FONT>));
<FONT ID="LN">330 </FONT><A NAME="330"></A>
<FONT ID="LN">331 </FONT><A NAME="331"></A>    result.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Option.java.html">Option</A>(
<FONT ID="LN">332 </FONT><A NAME="332"></A>    <FONT ID="StringLiteral">"\tThe tokenizing algorihtm (classname plus parameters) to use.\n"</FONT>
<FONT ID="LN">333 </FONT><A NAME="333"></A>    + <FONT ID="StringLiteral">"\t(default: "</FONT> + <A HREF="../../../../weka/core/tokenizers/WordTokenizer.java.html">WordTokenizer</A>.<FONT ID="Class">class</FONT>.getName() + <FONT ID="StringLiteral">")"</FONT>,
<FONT ID="LN">334 </FONT><A NAME="334"></A>    <FONT ID="StringLiteral">"tokenizer"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-tokenizer &lt;spec&gt;"</FONT>));
<FONT ID="LN">335 </FONT><A NAME="335"></A>
<FONT ID="LN">336 </FONT><A NAME="336"></A>    <FONT ID="Return">return</FONT> result.elements();
<FONT ID="LN">337 </FONT><A NAME="337"></A>  }
<FONT ID="LN">338 </FONT><A NAME="338"></A>
<FONT ID="LN">339 </FONT><A NAME="339"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">340 </FONT><A NAME="340"></A>   * Parses a given list of options. &lt;p/&gt;
<FONT ID="LN">341 </FONT><A NAME="341"></A>   * 
<FONT ID="LN">342 </FONT><A NAME="342"></A>         &lt;!-- options-start --&gt;
<FONT ID="LN">343 </FONT><A NAME="343"></A>         * Valid options are: &lt;p/&gt;
<FONT ID="LN">344 </FONT><A NAME="344"></A>         * 
<FONT ID="LN">345 </FONT><A NAME="345"></A>         * &lt;pre&gt; -C
<FONT ID="LN">346 </FONT><A NAME="346"></A>         *  Output word counts rather than boolean word presence.
<FONT ID="LN">347 </FONT><A NAME="347"></A>         * &lt;/pre&gt;
<FONT ID="LN">348 </FONT><A NAME="348"></A>         * 
<FONT ID="LN">349 </FONT><A NAME="349"></A>         * &lt;pre&gt; -R &amp;lt;index1,index2-index4,...&amp;gt;
<FONT ID="LN">350 </FONT><A NAME="350"></A>         *  Specify list of string attributes to convert to words (as weka Range).
<FONT ID="LN">351 </FONT><A NAME="351"></A>         *  (default: select all string attributes)&lt;/pre&gt;
<FONT ID="LN">352 </FONT><A NAME="352"></A>         * 
<FONT ID="LN">353 </FONT><A NAME="353"></A>         * &lt;pre&gt; -V
<FONT ID="LN">354 </FONT><A NAME="354"></A>         *  Invert matching sense of column indexes.&lt;/pre&gt;
<FONT ID="LN">355 </FONT><A NAME="355"></A>         * 
<FONT ID="LN">356 </FONT><A NAME="356"></A>         * &lt;pre&gt; -P &amp;lt;attribute name prefix&amp;gt;
<FONT ID="LN">357 </FONT><A NAME="357"></A>         *  Specify a prefix for the created attribute names.
<FONT ID="LN">358 </FONT><A NAME="358"></A>         *  (default: "")&lt;/pre&gt;
<FONT ID="LN">359 </FONT><A NAME="359"></A>         * 
<FONT ID="LN">360 </FONT><A NAME="360"></A>         * &lt;pre&gt; -W &amp;lt;number of words to keep&amp;gt;
<FONT ID="LN">361 </FONT><A NAME="361"></A>         *  Specify approximate number of word fields to create.
<FONT ID="LN">362 </FONT><A NAME="362"></A>         *  Surplus words will be discarded..
<FONT ID="LN">363 </FONT><A NAME="363"></A>         *  (default: 1000)&lt;/pre&gt;
<FONT ID="LN">364 </FONT><A NAME="364"></A>         * 
<FONT ID="LN">365 </FONT><A NAME="365"></A>         * &lt;pre&gt; -prune-rate &amp;lt;rate as a percentage of dataset&amp;gt;
<FONT ID="LN">366 </FONT><A NAME="366"></A>         *  Specify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.
<FONT ID="LN">367 </FONT><A NAME="367"></A>         *  -W prunes after creating a full dictionary. You may not have enough memory for this approach.
<FONT ID="LN">368 </FONT><A NAME="368"></A>         *  (default: no periodic pruning)&lt;/pre&gt;
<FONT ID="LN">369 </FONT><A NAME="369"></A>         * 
<FONT ID="LN">370 </FONT><A NAME="370"></A>         * &lt;pre&gt; -T
<FONT ID="LN">371 </FONT><A NAME="371"></A>         *  Transform the word frequencies into log(1+fij)
<FONT ID="LN">372 </FONT><A NAME="372"></A>         *  where fij is the frequency of word i in jth document(instance).
<FONT ID="LN">373 </FONT><A NAME="373"></A>         * &lt;/pre&gt;
<FONT ID="LN">374 </FONT><A NAME="374"></A>         * 
<FONT ID="LN">375 </FONT><A NAME="375"></A>         * &lt;pre&gt; -I
<FONT ID="LN">376 </FONT><A NAME="376"></A>         *  Transform each word frequency into:
<FONT ID="LN">377 </FONT><A NAME="377"></A>         *  fij*log(num of Documents/num of documents containing word i)
<FONT ID="LN">378 </FONT><A NAME="378"></A>         *    where fij if frequency of word i in jth document(instance)&lt;/pre&gt;
<FONT ID="LN">379 </FONT><A NAME="379"></A>         * 
<FONT ID="LN">380 </FONT><A NAME="380"></A>         * &lt;pre&gt; -N
<FONT ID="LN">381 </FONT><A NAME="381"></A>         *  Whether to 0=not normalize/1=normalize all data/2=normalize test data only
<FONT ID="LN">382 </FONT><A NAME="382"></A>         *  to average length of training documents (default 0=don't normalize).&lt;/pre&gt;
<FONT ID="LN">383 </FONT><A NAME="383"></A>         * 
<FONT ID="LN">384 </FONT><A NAME="384"></A>         * &lt;pre&gt; -L
<FONT ID="LN">385 </FONT><A NAME="385"></A>         *  Convert all tokens to lowercase before adding to the dictionary.&lt;/pre&gt;
<FONT ID="LN">386 </FONT><A NAME="386"></A>         * 
<FONT ID="LN">387 </FONT><A NAME="387"></A>         * &lt;pre&gt; -S
<FONT ID="LN">388 </FONT><A NAME="388"></A>         *  Ignore words that are in the stoplist.&lt;/pre&gt;
<FONT ID="LN">389 </FONT><A NAME="389"></A>         * 
<FONT ID="LN">390 </FONT><A NAME="390"></A>         * &lt;pre&gt; -stemmer &amp;lt;spec&amp;gt;
<FONT ID="LN">391 </FONT><A NAME="391"></A>         *  The stemmering algorihtm (classname plus parameters) to use.&lt;/pre&gt;
<FONT ID="LN">392 </FONT><A NAME="392"></A>         * 
<FONT ID="LN">393 </FONT><A NAME="393"></A>         * &lt;pre&gt; -M &amp;lt;int&amp;gt;
<FONT ID="LN">394 </FONT><A NAME="394"></A>         *  The minimum term frequency (default = 1).&lt;/pre&gt;
<FONT ID="LN">395 </FONT><A NAME="395"></A>         * 
<FONT ID="LN">396 </FONT><A NAME="396"></A>         * &lt;pre&gt; -O
<FONT ID="LN">397 </FONT><A NAME="397"></A>         *  If this is set, the maximum number of words and the 
<FONT ID="LN">398 </FONT><A NAME="398"></A>         *  minimum term frequency is not enforced on a per-class 
<FONT ID="LN">399 </FONT><A NAME="399"></A>         *  basis but based on the documents in all the classes 
<FONT ID="LN">400 </FONT><A NAME="400"></A>         *  (even if a class attribute is set).&lt;/pre&gt;
<FONT ID="LN">401 </FONT><A NAME="401"></A>         * 
<FONT ID="LN">402 </FONT><A NAME="402"></A>         * &lt;pre&gt; -stopwords &amp;lt;file&amp;gt;
<FONT ID="LN">403 </FONT><A NAME="403"></A>         *  A file containing stopwords to override the default ones.
<FONT ID="LN">404 </FONT><A NAME="404"></A>         *  Using this option automatically sets the flag ('-S') to use the
<FONT ID="LN">405 </FONT><A NAME="405"></A>         *  stoplist if the file exists.
<FONT ID="LN">406 </FONT><A NAME="406"></A>         *  Format: one stopword per line, lines starting with '#'
<FONT ID="LN">407 </FONT><A NAME="407"></A>         *  are interpreted as comments and ignored.&lt;/pre&gt;
<FONT ID="LN">408 </FONT><A NAME="408"></A>         * 
<FONT ID="LN">409 </FONT><A NAME="409"></A>         * &lt;pre&gt; -tokenizer &amp;lt;spec&amp;gt;
<FONT ID="LN">410 </FONT><A NAME="410"></A>         *  The tokenizing algorihtm (classname plus parameters) to use.
<FONT ID="LN">411 </FONT><A NAME="411"></A>         *  (default: weka.core.tokenizers.WordTokenizer)&lt;/pre&gt;
<FONT ID="LN">412 </FONT><A NAME="412"></A>         * 
<FONT ID="LN">413 </FONT><A NAME="413"></A>         &lt;!-- options-end --&gt;
<FONT ID="LN">414 </FONT><A NAME="414"></A>   *
<FONT ID="LN">415 </FONT><A NAME="415"></A>   * @param options the list of options as an array of strings
<FONT ID="LN">416 </FONT><A NAME="416"></A>   * @throws Exception if an option is not supported
<FONT ID="LN">417 </FONT><A NAME="417"></A>   */</FONT>
<FONT ID="LN">418 </FONT><A NAME="418"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setOptions(String[] options) <FONT ID="Throws">throws</FONT> Exception {
<FONT ID="LN">419 </FONT><A NAME="419"></A>    String  value;
<FONT ID="LN">420 </FONT><A NAME="420"></A>
<FONT ID="LN">421 </FONT><A NAME="421"></A>    value = Utils.getOption(<FONT ID="CharacerLiteral">'R'</FONT>, options);
<FONT ID="LN">422 </FONT><A NAME="422"></A>    <FONT ID="If">if</FONT> (value.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">423 </FONT><A NAME="423"></A>      setSelectedRange(value);
<FONT ID="LN">424 </FONT><A NAME="424"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">425 </FONT><A NAME="425"></A>      setSelectedRange(<FONT ID="StringLiteral">"first-last"</FONT>);
<FONT ID="LN">426 </FONT><A NAME="426"></A>
<FONT ID="LN">427 </FONT><A NAME="427"></A>    setInvertSelection(Utils.getFlag(<FONT ID="CharacerLiteral">'V'</FONT>, options));
<FONT ID="LN">428 </FONT><A NAME="428"></A>
<FONT ID="LN">429 </FONT><A NAME="429"></A>    value = Utils.getOption(<FONT ID="CharacerLiteral">'P'</FONT>, options);
<FONT ID="LN">430 </FONT><A NAME="430"></A>    <FONT ID="If">if</FONT> (value.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">431 </FONT><A NAME="431"></A>      setAttributeNamePrefix(value);
<FONT ID="LN">432 </FONT><A NAME="432"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">433 </FONT><A NAME="433"></A>      setAttributeNamePrefix(<FONT ID="StringLiteral">""</FONT>);
<FONT ID="LN">434 </FONT><A NAME="434"></A>
<FONT ID="LN">435 </FONT><A NAME="435"></A>    value = Utils.getOption(<FONT ID="CharacerLiteral">'W'</FONT>, options);
<FONT ID="LN">436 </FONT><A NAME="436"></A>    <FONT ID="If">if</FONT> (value.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">437 </FONT><A NAME="437"></A>      setWordsToKeep(Integer.valueOf(value).intValue());
<FONT ID="LN">438 </FONT><A NAME="438"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">439 </FONT><A NAME="439"></A>      setWordsToKeep(<FONT ID="IntegerLiteral">1000</FONT>);
<FONT ID="LN">440 </FONT><A NAME="440"></A>
<FONT ID="LN">441 </FONT><A NAME="441"></A>    value = Utils.getOption(<FONT ID="StringLiteral">"prune-rate"</FONT>, options);
<FONT ID="LN">442 </FONT><A NAME="442"></A>    <FONT ID="If">if</FONT> (value.length() &gt; <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">443 </FONT><A NAME="443"></A>      setPeriodicPruning(Double.parseDouble(value));
<FONT ID="LN">444 </FONT><A NAME="444"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">445 </FONT><A NAME="445"></A>      setPeriodicPruning(-<FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">446 </FONT><A NAME="446"></A>
<FONT ID="LN">447 </FONT><A NAME="447"></A>    value = Utils.getOption(<FONT ID="CharacerLiteral">'M'</FONT>, options);
<FONT ID="LN">448 </FONT><A NAME="448"></A>    <FONT ID="If">if</FONT> (value.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">449 </FONT><A NAME="449"></A>      setMinTermFreq(Integer.valueOf(value).intValue());
<FONT ID="LN">450 </FONT><A NAME="450"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">451 </FONT><A NAME="451"></A>      setMinTermFreq(<FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">452 </FONT><A NAME="452"></A>
<FONT ID="LN">453 </FONT><A NAME="453"></A>    setOutputWordCounts(Utils.getFlag(<FONT ID="CharacerLiteral">'C'</FONT>, options));
<FONT ID="LN">454 </FONT><A NAME="454"></A>
<FONT ID="LN">455 </FONT><A NAME="455"></A>    setTFTransform(Utils.getFlag(<FONT ID="CharacerLiteral">'T'</FONT>,  options));
<FONT ID="LN">456 </FONT><A NAME="456"></A>
<FONT ID="LN">457 </FONT><A NAME="457"></A>    setIDFTransform(Utils.getFlag(<FONT ID="CharacerLiteral">'I'</FONT>,  options));
<FONT ID="LN">458 </FONT><A NAME="458"></A>
<FONT ID="LN">459 </FONT><A NAME="459"></A>    setDoNotOperateOnPerClassBasis(Utils.getFlag(<FONT ID="CharacerLiteral">'O'</FONT>, options));
<FONT ID="LN">460 </FONT><A NAME="460"></A>
<FONT ID="LN">461 </FONT><A NAME="461"></A>    String nString = Utils.getOption(<FONT ID="CharacerLiteral">'N'</FONT>, options);
<FONT ID="LN">462 </FONT><A NAME="462"></A>    <FONT ID="If">if</FONT> (nString.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">463 </FONT><A NAME="463"></A>      setNormalizeDocLength(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">SelectedTag</A>(Integer.parseInt(nString), TAGS_FILTER));
<FONT ID="LN">464 </FONT><A NAME="464"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">465 </FONT><A NAME="465"></A>      setNormalizeDocLength(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">SelectedTag</A>(FILTER_NONE, TAGS_FILTER));
<FONT ID="LN">466 </FONT><A NAME="466"></A>
<FONT ID="LN">467 </FONT><A NAME="467"></A>    setLowerCaseTokens(Utils.getFlag(<FONT ID="CharacerLiteral">'L'</FONT>, options));
<FONT ID="LN">468 </FONT><A NAME="468"></A>
<FONT ID="LN">469 </FONT><A NAME="469"></A>    setUseStoplist(Utils.getFlag(<FONT ID="CharacerLiteral">'S'</FONT>, options));
<FONT ID="LN">470 </FONT><A NAME="470"></A>
<FONT ID="LN">471 </FONT><A NAME="471"></A>    String stemmerString = Utils.getOption(<FONT ID="StringLiteral">"stemmer"</FONT>, options);
<FONT ID="LN">472 </FONT><A NAME="472"></A>    <FONT ID="If">if</FONT> (stemmerString.length() == <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">473 </FONT><A NAME="473"></A>      setStemmer(<FONT ID="Null">null</FONT>);
<FONT ID="LN">474 </FONT><A NAME="474"></A>    }
<FONT ID="LN">475 </FONT><A NAME="475"></A>    <FONT ID="Else">else</FONT> {
<FONT ID="LN">476 </FONT><A NAME="476"></A>      String[] stemmerSpec = Utils.splitOptions(stemmerString);
<FONT ID="LN">477 </FONT><A NAME="477"></A>      <FONT ID="If">if</FONT> (stemmerSpec.length == <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">478 </FONT><A NAME="478"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> Exception(<FONT ID="StringLiteral">"Invalid stemmer specification string"</FONT>);
<FONT ID="LN">479 </FONT><A NAME="479"></A>      String stemmerName = stemmerSpec[<FONT ID="IntegerLiteral">0</FONT>];
<FONT ID="LN">480 </FONT><A NAME="480"></A>      stemmerSpec[<FONT ID="IntegerLiteral">0</FONT>] = <FONT ID="StringLiteral">""</FONT>;
<FONT ID="LN">481 </FONT><A NAME="481"></A>      <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">Stemmer</A> stemmer = (<A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">Stemmer</A>) Class.forName(stemmerName).newInstance();
<FONT ID="LN">482 </FONT><A NAME="482"></A>      <FONT ID="If">if</FONT> (stemmer <FONT ID="InstanceOf">instanceof</FONT> <A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>)
<FONT ID="LN">483 </FONT><A NAME="483"></A>    ((<A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>) stemmer).setOptions(stemmerSpec);
<FONT ID="LN">484 </FONT><A NAME="484"></A>      setStemmer(stemmer);
<FONT ID="LN">485 </FONT><A NAME="485"></A>    }
<FONT ID="LN">486 </FONT><A NAME="486"></A>
<FONT ID="LN">487 </FONT><A NAME="487"></A>    value = Utils.getOption(<FONT ID="StringLiteral">"stopwords"</FONT>, options);
<FONT ID="LN">488 </FONT><A NAME="488"></A>    <FONT ID="If">if</FONT> (value.length() != <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">489 </FONT><A NAME="489"></A>      setStopwords(<FONT ID="New">new</FONT> File(value));
<FONT ID="LN">490 </FONT><A NAME="490"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">491 </FONT><A NAME="491"></A>      setStopwords(<FONT ID="Null">null</FONT>);
<FONT ID="LN">492 </FONT><A NAME="492"></A>
<FONT ID="LN">493 </FONT><A NAME="493"></A>    String tokenizerString = Utils.getOption(<FONT ID="StringLiteral">"tokenizer"</FONT>, options);
<FONT ID="LN">494 </FONT><A NAME="494"></A>    <FONT ID="If">if</FONT> (tokenizerString.length() == <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">495 </FONT><A NAME="495"></A>      setTokenizer(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/tokenizers/WordTokenizer.java.html">WordTokenizer</A>());
<FONT ID="LN">496 </FONT><A NAME="496"></A>    }
<FONT ID="LN">497 </FONT><A NAME="497"></A>    <FONT ID="Else">else</FONT> {
<FONT ID="LN">498 </FONT><A NAME="498"></A>      String[] tokenizerSpec = Utils.splitOptions(tokenizerString);
<FONT ID="LN">499 </FONT><A NAME="499"></A>      <FONT ID="If">if</FONT> (tokenizerSpec.length == <FONT ID="IntegerLiteral">0</FONT>)
<FONT ID="LN">500 </FONT><A NAME="500"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> Exception(<FONT ID="StringLiteral">"Invalid tokenizer specification string"</FONT>);
<FONT ID="LN">501 </FONT><A NAME="501"></A>      String tokenizerName = tokenizerSpec[<FONT ID="IntegerLiteral">0</FONT>];
<FONT ID="LN">502 </FONT><A NAME="502"></A>      tokenizerSpec[<FONT ID="IntegerLiteral">0</FONT>] = <FONT ID="StringLiteral">""</FONT>;
<FONT ID="LN">503 </FONT><A NAME="503"></A>      <A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">Tokenizer</A> tokenizer = (<A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">Tokenizer</A>) Class.forName(tokenizerName).newInstance();
<FONT ID="LN">504 </FONT><A NAME="504"></A>      <FONT ID="If">if</FONT> (tokenizer <FONT ID="InstanceOf">instanceof</FONT> <A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>)
<FONT ID="LN">505 </FONT><A NAME="505"></A>    ((<A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>) tokenizer).setOptions(tokenizerSpec);
<FONT ID="LN">506 </FONT><A NAME="506"></A>      setTokenizer(tokenizer);
<FONT ID="LN">507 </FONT><A NAME="507"></A>    }
<FONT ID="LN">508 </FONT><A NAME="508"></A>  }
<FONT ID="LN">509 </FONT><A NAME="509"></A>
<FONT ID="LN">510 </FONT><A NAME="510"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">511 </FONT><A NAME="511"></A>   * Gets the current settings of the filter.
<FONT ID="LN">512 </FONT><A NAME="512"></A>   *
<FONT ID="LN">513 </FONT><A NAME="513"></A>   * @return an array of strings suitable for passing to setOptions
<FONT ID="LN">514 </FONT><A NAME="514"></A>   */</FONT>
<FONT ID="LN">515 </FONT><A NAME="515"></A>  <FONT ID="Public">public</FONT> String[] getOptions() {
<FONT ID="LN">516 </FONT><A NAME="516"></A>    <A HREF="../../../../weka/core/FastVector.java.html">Vector</A>        result;
<FONT ID="LN">517 </FONT><A NAME="517"></A>
<FONT ID="LN">518 </FONT><A NAME="518"></A>    result = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">Vector</A>();
<FONT ID="LN">519 </FONT><A NAME="519"></A>
<FONT ID="LN">520 </FONT><A NAME="520"></A>    result.add(<FONT ID="StringLiteral">"-R"</FONT>); 
<FONT ID="LN">521 </FONT><A NAME="521"></A>    result.add(getSelectedRange().getRanges());
<FONT ID="LN">522 </FONT><A NAME="522"></A>
<FONT ID="LN">523 </FONT><A NAME="523"></A>    <FONT ID="If">if</FONT> (getInvertSelection())
<FONT ID="LN">524 </FONT><A NAME="524"></A>      result.add(<FONT ID="StringLiteral">"-V"</FONT>);
<FONT ID="LN">525 </FONT><A NAME="525"></A>
<FONT ID="LN">526 </FONT><A NAME="526"></A>    <FONT ID="If">if</FONT> (!<FONT ID="StringLiteral">""</FONT>.equals(getAttributeNamePrefix())) {
<FONT ID="LN">527 </FONT><A NAME="527"></A>      result.add(<FONT ID="StringLiteral">"-P"</FONT>); 
<FONT ID="LN">528 </FONT><A NAME="528"></A>      result.add(getAttributeNamePrefix());
<FONT ID="LN">529 </FONT><A NAME="529"></A>    }
<FONT ID="LN">530 </FONT><A NAME="530"></A>
<FONT ID="LN">531 </FONT><A NAME="531"></A>    result.add(<FONT ID="StringLiteral">"-W"</FONT>); 
<FONT ID="LN">532 </FONT><A NAME="532"></A>    result.add(String.valueOf(getWordsToKeep()));
<FONT ID="LN">533 </FONT><A NAME="533"></A>
<FONT ID="LN">534 </FONT><A NAME="534"></A>    result.add(<FONT ID="StringLiteral">"-prune-rate"</FONT>); 
<FONT ID="LN">535 </FONT><A NAME="535"></A>    result.add(String.valueOf(getPeriodicPruning()));
<FONT ID="LN">536 </FONT><A NAME="536"></A>
<FONT ID="LN">537 </FONT><A NAME="537"></A>    <FONT ID="If">if</FONT> (getOutputWordCounts())
<FONT ID="LN">538 </FONT><A NAME="538"></A>      result.add(<FONT ID="StringLiteral">"-C"</FONT>);
<FONT ID="LN">539 </FONT><A NAME="539"></A>
<FONT ID="LN">540 </FONT><A NAME="540"></A>    <FONT ID="If">if</FONT> (getTFTransform())
<FONT ID="LN">541 </FONT><A NAME="541"></A>      result.add(<FONT ID="StringLiteral">"-T"</FONT>);
<FONT ID="LN">542 </FONT><A NAME="542"></A>
<FONT ID="LN">543 </FONT><A NAME="543"></A>    <FONT ID="If">if</FONT> (getIDFTransform())
<FONT ID="LN">544 </FONT><A NAME="544"></A>      result.add(<FONT ID="StringLiteral">"-I"</FONT>);
<FONT ID="LN">545 </FONT><A NAME="545"></A>
<FONT ID="LN">546 </FONT><A NAME="546"></A>    result.add(<FONT ID="StringLiteral">"-N"</FONT>); 
<FONT ID="LN">547 </FONT><A NAME="547"></A>    result.add(<FONT ID="StringLiteral">""</FONT> + m_filterType);
<FONT ID="LN">548 </FONT><A NAME="548"></A>
<FONT ID="LN">549 </FONT><A NAME="549"></A>    <FONT ID="If">if</FONT> (getLowerCaseTokens())
<FONT ID="LN">550 </FONT><A NAME="550"></A>      result.add(<FONT ID="StringLiteral">"-L"</FONT>);
<FONT ID="LN">551 </FONT><A NAME="551"></A>
<FONT ID="LN">552 </FONT><A NAME="552"></A>    <FONT ID="If">if</FONT> (getUseStoplist())
<FONT ID="LN">553 </FONT><A NAME="553"></A>      result.add(<FONT ID="StringLiteral">"-S"</FONT>);
<FONT ID="LN">554 </FONT><A NAME="554"></A>
<FONT ID="LN">555 </FONT><A NAME="555"></A>    <FONT ID="If">if</FONT> (getStemmer() != <FONT ID="Null">null</FONT>) {
<FONT ID="LN">556 </FONT><A NAME="556"></A>      result.add(<FONT ID="StringLiteral">"-stemmer"</FONT>);
<FONT ID="LN">557 </FONT><A NAME="557"></A>      String spec = getStemmer().getClass().getName();
<FONT ID="LN">558 </FONT><A NAME="558"></A>      <FONT ID="If">if</FONT> (getStemmer() <FONT ID="InstanceOf">instanceof</FONT> <A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>)
<FONT ID="LN">559 </FONT><A NAME="559"></A>    spec += <FONT ID="StringLiteral">" "</FONT> + Utils.joinOptions(
<FONT ID="LN">560 </FONT><A NAME="560"></A>        ((<A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>) getStemmer()).getOptions());
<FONT ID="LN">561 </FONT><A NAME="561"></A>      result.add(spec.trim());
<FONT ID="LN">562 </FONT><A NAME="562"></A>    }
<FONT ID="LN">563 </FONT><A NAME="563"></A>
<FONT ID="LN">564 </FONT><A NAME="564"></A>    result.add(<FONT ID="StringLiteral">"-M"</FONT>); 
<FONT ID="LN">565 </FONT><A NAME="565"></A>    result.add(String.valueOf(getMinTermFreq()));
<FONT ID="LN">566 </FONT><A NAME="566"></A>
<FONT ID="LN">567 </FONT><A NAME="567"></A>    <FONT ID="If">if</FONT> (getDoNotOperateOnPerClassBasis())
<FONT ID="LN">568 </FONT><A NAME="568"></A>      result.add(<FONT ID="StringLiteral">"-O"</FONT>);
<FONT ID="LN">569 </FONT><A NAME="569"></A>
<FONT ID="LN">570 </FONT><A NAME="570"></A>    <FONT ID="If">if</FONT> (!getStopwords().isDirectory()) {
<FONT ID="LN">571 </FONT><A NAME="571"></A>      result.add(<FONT ID="StringLiteral">"-stopwords"</FONT>);
<FONT ID="LN">572 </FONT><A NAME="572"></A>      result.add(getStopwords().getAbsolutePath());
<FONT ID="LN">573 </FONT><A NAME="573"></A>    }
<FONT ID="LN">574 </FONT><A NAME="574"></A>
<FONT ID="LN">575 </FONT><A NAME="575"></A>    result.add(<FONT ID="StringLiteral">"-tokenizer"</FONT>);
<FONT ID="LN">576 </FONT><A NAME="576"></A>    String spec = getTokenizer().getClass().getName();
<FONT ID="LN">577 </FONT><A NAME="577"></A>    <FONT ID="If">if</FONT> (getTokenizer() <FONT ID="InstanceOf">instanceof</FONT> <A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>)
<FONT ID="LN">578 </FONT><A NAME="578"></A>      spec += <FONT ID="StringLiteral">" "</FONT> + Utils.joinOptions(
<FONT ID="LN">579 </FONT><A NAME="579"></A>      ((<A HREF="../../../../weka/core/OptionHandler.java.html">OptionHandler</A>) getTokenizer()).getOptions());
<FONT ID="LN">580 </FONT><A NAME="580"></A>    result.add(spec.trim());
<FONT ID="LN">581 </FONT><A NAME="581"></A>
<FONT ID="LN">582 </FONT><A NAME="582"></A>    <FONT ID="Return">return</FONT> (String[]) result.toArray(<FONT ID="New">new</FONT> String[result.size()]);
<FONT ID="LN">583 </FONT><A NAME="583"></A>  }
<FONT ID="LN">584 </FONT><A NAME="584"></A>
<FONT ID="LN">585 </FONT><A NAME="585"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">586 </FONT><A NAME="586"></A>   * Constructor that allows specification of the target number of words
<FONT ID="LN">587 </FONT><A NAME="587"></A>   * in the output.
<FONT ID="LN">588 </FONT><A NAME="588"></A>   *
<FONT ID="LN">589 </FONT><A NAME="589"></A>   * @param wordsToKeep the number of words in the output vector (per class
<FONT ID="LN">590 </FONT><A NAME="590"></A>   * if assigned).
<FONT ID="LN">591 </FONT><A NAME="591"></A>   */</FONT>
<FONT ID="LN">592 </FONT><A NAME="592"></A>  <FONT ID="Public">public</FONT> StringToWordVector(<FONT ID="Int">int</FONT> wordsToKeep) {
<FONT ID="LN">593 </FONT><A NAME="593"></A>    m_WordsToKeep = wordsToKeep;
<FONT ID="LN">594 </FONT><A NAME="594"></A>  }
<FONT ID="LN">595 </FONT><A NAME="595"></A>
<FONT ID="LN">596 </FONT><A NAME="596"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">597 </FONT><A NAME="597"></A>   * Used to store word counts for dictionary selection based on 
<FONT ID="LN">598 </FONT><A NAME="598"></A>   * a threshold.
<FONT ID="LN">599 </FONT><A NAME="599"></A>   */</FONT>
<FONT ID="LN">600 </FONT><A NAME="600"></A>  <FONT ID="Private">private</FONT> <FONT ID="Class">class</FONT> Count 
<FONT ID="LN">601 </FONT><A NAME="601"></A>  <FONT ID="Implements">implements</FONT> Serializable, <A HREF="../../../../weka/core/RevisionHandler.java.html">RevisionHandler</A> {
<FONT ID="LN">602 </FONT><A NAME="602"></A>
<FONT ID="LN">603 </FONT><A NAME="603"></A>    <FONT ID="FormalComment">/** for serialization. */</FONT>
<FONT ID="LN">604 </FONT><A NAME="604"></A>    <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = <FONT ID="IntegerLiteral">2157223818584474321L</FONT>;
<FONT ID="LN">605 </FONT><A NAME="605"></A>
<FONT ID="LN">606 </FONT><A NAME="606"></A>    <FONT ID="FormalComment">/** the counts. */</FONT>
<FONT ID="LN">607 </FONT><A NAME="607"></A>    <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> count, docCount;
<FONT ID="LN">608 </FONT><A NAME="608"></A>
<FONT ID="LN">609 </FONT><A NAME="609"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">610 </FONT><A NAME="610"></A>     * the constructor.
<FONT ID="LN">611 </FONT><A NAME="611"></A>     * 
<FONT ID="LN">612 </FONT><A NAME="612"></A>     * @param c the count
<FONT ID="LN">613 </FONT><A NAME="613"></A>     */</FONT>
<FONT ID="LN">614 </FONT><A NAME="614"></A>    <FONT ID="Public">public</FONT> Count(<FONT ID="Int">int</FONT> c) { 
<FONT ID="LN">615 </FONT><A NAME="615"></A>      count = c; 
<FONT ID="LN">616 </FONT><A NAME="616"></A>    }
<FONT ID="LN">617 </FONT><A NAME="617"></A>    
<FONT ID="LN">618 </FONT><A NAME="618"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">619 </FONT><A NAME="619"></A>     * Returns the revision string.
<FONT ID="LN">620 </FONT><A NAME="620"></A>     * 
<FONT ID="LN">621 </FONT><A NAME="621"></A>     * @return      the revision
<FONT ID="LN">622 </FONT><A NAME="622"></A>     */</FONT>
<FONT ID="LN">623 </FONT><A NAME="623"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">624 </FONT><A NAME="624"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5987 $"</FONT>);
<FONT ID="LN">625 </FONT><A NAME="625"></A>    }
<FONT ID="LN">626 </FONT><A NAME="626"></A>  }
<FONT ID="LN">627 </FONT><A NAME="627"></A>
<FONT ID="LN">628 </FONT><A NAME="628"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">629 </FONT><A NAME="629"></A>   * Returns the Capabilities of this filter.
<FONT ID="LN">630 </FONT><A NAME="630"></A>   *
<FONT ID="LN">631 </FONT><A NAME="631"></A>   * @return            the capabilities of this object
<FONT ID="LN">632 </FONT><A NAME="632"></A>   * @see               Capabilities
<FONT ID="LN">633 </FONT><A NAME="633"></A>   */</FONT>
<FONT ID="LN">634 </FONT><A NAME="634"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../../weka/core/Capabilities.java.html">Capabilities</A> getCapabilities() {
<FONT ID="LN">635 </FONT><A NAME="635"></A>    <A HREF="../../../../weka/core/Capabilities.java.html">Capabilities</A> result = <FONT ID="Super">super</FONT>.getCapabilities();
<FONT ID="LN">636 </FONT><A NAME="636"></A>    result.disableAll();
<FONT ID="LN">637 </FONT><A NAME="637"></A>
<FONT ID="LN">638 </FONT><A NAME="638"></A>    <FONT ID="SingleLineComment">// attributes
<FONT ID="LN">639 </FONT><A NAME="639"></A></FONT>    result.enableAllAttributes();
<FONT ID="LN">640 </FONT><A NAME="640"></A>    result.enable(Capability.MISSING_VALUES);
<FONT ID="LN">641 </FONT><A NAME="641"></A>
<FONT ID="LN">642 </FONT><A NAME="642"></A>    <FONT ID="SingleLineComment">// class
<FONT ID="LN">643 </FONT><A NAME="643"></A></FONT>    result.enableAllClasses();
<FONT ID="LN">644 </FONT><A NAME="644"></A>    result.enable(Capability.MISSING_CLASS_VALUES);
<FONT ID="LN">645 </FONT><A NAME="645"></A>    result.enable(Capability.NO_CLASS);
<FONT ID="LN">646 </FONT><A NAME="646"></A>
<FONT ID="LN">647 </FONT><A NAME="647"></A>    <FONT ID="Return">return</FONT> result;
<FONT ID="LN">648 </FONT><A NAME="648"></A>  }
<FONT ID="LN">649 </FONT><A NAME="649"></A>
<FONT ID="LN">650 </FONT><A NAME="650"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">651 </FONT><A NAME="651"></A>   * Sets the format of the input instances.
<FONT ID="LN">652 </FONT><A NAME="652"></A>   *
<FONT ID="LN">653 </FONT><A NAME="653"></A>   * @param instanceInfo an Instances object containing the input 
<FONT ID="LN">654 </FONT><A NAME="654"></A>   * instance structure (any instances contained in the object are 
<FONT ID="LN">655 </FONT><A NAME="655"></A>   * ignored - only the structure is required).
<FONT ID="LN">656 </FONT><A NAME="656"></A>   * @return true if the outputFormat may be collected immediately
<FONT ID="LN">657 </FONT><A NAME="657"></A>   * @throws Exception if the input format can't be set 
<FONT ID="LN">658 </FONT><A NAME="658"></A>   * successfully
<FONT ID="LN">659 </FONT><A NAME="659"></A>   */</FONT>
<FONT ID="LN">660 </FONT><A NAME="660"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> setInputFormat(<A HREF="../../../../weka/core/Instances.java.html">Instances</A> instanceInfo) 
<FONT ID="LN">661 </FONT><A NAME="661"></A>  <FONT ID="Throws">throws</FONT> Exception {
<FONT ID="LN">662 </FONT><A NAME="662"></A>
<FONT ID="LN">663 </FONT><A NAME="663"></A>    <FONT ID="Super">super</FONT>.setInputFormat(instanceInfo);
<FONT ID="LN">664 </FONT><A NAME="664"></A>    m_SelectedRange.setUpper(instanceInfo.numAttributes() - <FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">665 </FONT><A NAME="665"></A>    m_AvgDocLength = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">666 </FONT><A NAME="666"></A>    m_NumInstances = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">667 </FONT><A NAME="667"></A>    <FONT ID="Return">return</FONT> <FONT ID="False">false</FONT>;
<FONT ID="LN">668 </FONT><A NAME="668"></A>  }
<FONT ID="LN">669 </FONT><A NAME="669"></A>
<FONT ID="LN">670 </FONT><A NAME="670"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">671 </FONT><A NAME="671"></A>   * Input an instance for filtering. Filter requires all
<FONT ID="LN">672 </FONT><A NAME="672"></A>   * training instances be read before producing output.
<FONT ID="LN">673 </FONT><A NAME="673"></A>   *
<FONT ID="LN">674 </FONT><A NAME="674"></A>   * @param instance the input instance.
<FONT ID="LN">675 </FONT><A NAME="675"></A>   * @return true if the filtered instance may now be
<FONT ID="LN">676 </FONT><A NAME="676"></A>   * collected with output().
<FONT ID="LN">677 </FONT><A NAME="677"></A>   * @throws IllegalStateException if no input structure has been defined.
<FONT ID="LN">678 </FONT><A NAME="678"></A>   */</FONT>
<FONT ID="LN">679 </FONT><A NAME="679"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> input(<A HREF="../../../../weka/core/Instance.java.html">Instance</A> instance) <FONT ID="Throws">throws</FONT> Exception {
<FONT ID="LN">680 </FONT><A NAME="680"></A>
<FONT ID="LN">681 </FONT><A NAME="681"></A>    <FONT ID="If">if</FONT> (getInputFormat() == <FONT ID="Null">null</FONT>) {
<FONT ID="LN">682 </FONT><A NAME="682"></A>      <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> IllegalStateException(<FONT ID="StringLiteral">"No input instance format defined"</FONT>);
<FONT ID="LN">683 </FONT><A NAME="683"></A>    }
<FONT ID="LN">684 </FONT><A NAME="684"></A>    <FONT ID="If">if</FONT> (m_NewBatch) {
<FONT ID="LN">685 </FONT><A NAME="685"></A>      resetQueue();
<FONT ID="LN">686 </FONT><A NAME="686"></A>      m_NewBatch = <FONT ID="False">false</FONT>;
<FONT ID="LN">687 </FONT><A NAME="687"></A>    }
<FONT ID="LN">688 </FONT><A NAME="688"></A>    <FONT ID="If">if</FONT> (isFirstBatchDone()) {
<FONT ID="LN">689 </FONT><A NAME="689"></A>      <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A> fv = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A>();
<FONT ID="LN">690 </FONT><A NAME="690"></A>      <FONT ID="Int">int</FONT> firstCopy = convertInstancewoDocNorm(instance, fv);
<FONT ID="LN">691 </FONT><A NAME="691"></A>      <A HREF="../../../../weka/core/Instance.java.html">Instance</A> inst = (<A HREF="../../../../weka/core/Instance.java.html">Instance</A>)fv.elementAt(<FONT ID="IntegerLiteral">0</FONT>);
<FONT ID="LN">692 </FONT><A NAME="692"></A>      <FONT ID="If">if</FONT> (m_filterType != FILTER_NONE) {
<FONT ID="LN">693 </FONT><A NAME="693"></A>    normalizeInstance(inst, firstCopy);
<FONT ID="LN">694 </FONT><A NAME="694"></A>      }
<FONT ID="LN">695 </FONT><A NAME="695"></A>      push(inst);
<FONT ID="LN">696 </FONT><A NAME="696"></A>      <FONT ID="Return">return</FONT> <FONT ID="True">true</FONT>;
<FONT ID="LN">697 </FONT><A NAME="697"></A>    } <FONT ID="Else">else</FONT> {
<FONT ID="LN">698 </FONT><A NAME="698"></A>      bufferInput(instance);
<FONT ID="LN">699 </FONT><A NAME="699"></A>      <FONT ID="Return">return</FONT> <FONT ID="False">false</FONT>;
<FONT ID="LN">700 </FONT><A NAME="700"></A>    }
<FONT ID="LN">701 </FONT><A NAME="701"></A>  }
<FONT ID="LN">702 </FONT><A NAME="702"></A>
<FONT ID="LN">703 </FONT><A NAME="703"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">704 </FONT><A NAME="704"></A>   * Signify that this batch of input to the filter is finished. 
<FONT ID="LN">705 </FONT><A NAME="705"></A>   * If the filter requires all instances prior to filtering,
<FONT ID="LN">706 </FONT><A NAME="706"></A>   * output() may now be called to retrieve the filtered instances.
<FONT ID="LN">707 </FONT><A NAME="707"></A>   *
<FONT ID="LN">708 </FONT><A NAME="708"></A>   * @return true if there are instances pending output.
<FONT ID="LN">709 </FONT><A NAME="709"></A>   * @throws IllegalStateException if no input structure has been defined.
<FONT ID="LN">710 </FONT><A NAME="710"></A>   */</FONT>
<FONT ID="LN">711 </FONT><A NAME="711"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> batchFinished() <FONT ID="Throws">throws</FONT> Exception {
<FONT ID="LN">712 </FONT><A NAME="712"></A>
<FONT ID="LN">713 </FONT><A NAME="713"></A>    <FONT ID="If">if</FONT> (getInputFormat() == <FONT ID="Null">null</FONT>) {
<FONT ID="LN">714 </FONT><A NAME="714"></A>      <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> IllegalStateException(<FONT ID="StringLiteral">"No input instance format defined"</FONT>);
<FONT ID="LN">715 </FONT><A NAME="715"></A>    }
<FONT ID="LN">716 </FONT><A NAME="716"></A>
<FONT ID="LN">717 </FONT><A NAME="717"></A>    <FONT ID="SingleLineComment">// We only need to do something in this method
<FONT ID="LN">718 </FONT><A NAME="718"></A></FONT>    <FONT ID="SingleLineComment">// if the first batch hasn't been processed. Otherwise
<FONT ID="LN">719 </FONT><A NAME="719"></A></FONT>    <FONT ID="SingleLineComment">// input() has already done all the work.
<FONT ID="LN">720 </FONT><A NAME="720"></A></FONT>    <FONT ID="If">if</FONT> (!isFirstBatchDone()) {
<FONT ID="LN">721 </FONT><A NAME="721"></A>
<FONT ID="LN">722 </FONT><A NAME="722"></A>      <FONT ID="SingleLineComment">// Determine the dictionary from the first batch (training data)
<FONT ID="LN">723 </FONT><A NAME="723"></A></FONT>      determineDictionary();
<FONT ID="LN">724 </FONT><A NAME="724"></A>
<FONT ID="LN">725 </FONT><A NAME="725"></A>      <FONT ID="SingleLineComment">// Convert all instances w/o normalization
<FONT ID="LN">726 </FONT><A NAME="726"></A></FONT>      <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A> fv = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A>();
<FONT ID="LN">727 </FONT><A NAME="727"></A>      <FONT ID="Int">int</FONT> firstCopy=<FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">728 </FONT><A NAME="728"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; m_NumInstances; i++) {
<FONT ID="LN">729 </FONT><A NAME="729"></A>    firstCopy = convertInstancewoDocNorm(getInputFormat().instance(i), fv);
<FONT ID="LN">730 </FONT><A NAME="730"></A>      }
<FONT ID="LN">731 </FONT><A NAME="731"></A>
<FONT ID="LN">732 </FONT><A NAME="732"></A>      <FONT ID="SingleLineComment">// Need to compute average document length if necessary
<FONT ID="LN">733 </FONT><A NAME="733"></A></FONT>      <FONT ID="If">if</FONT> (m_filterType != FILTER_NONE) {
<FONT ID="LN">734 </FONT><A NAME="734"></A>    m_AvgDocLength = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">735 </FONT><A NAME="735"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;fv.size(); i++) {
<FONT ID="LN">736 </FONT><A NAME="736"></A>      <A HREF="../../../../weka/core/Instance.java.html">Instance</A> inst = (<A HREF="../../../../weka/core/Instance.java.html">Instance</A>) fv.elementAt(i);
<FONT ID="LN">737 </FONT><A NAME="737"></A>      <FONT ID="Double">double</FONT> docLength = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">738 </FONT><A NAME="738"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;inst.numValues(); j++) {
<FONT ID="LN">739 </FONT><A NAME="739"></A>        <FONT ID="If">if</FONT>(inst.index(j)&gt;=firstCopy) {
<FONT ID="LN">740 </FONT><A NAME="740"></A>          docLength += inst.valueSparse(j) * inst.valueSparse(j);
<FONT ID="LN">741 </FONT><A NAME="741"></A>        }
<FONT ID="LN">742 </FONT><A NAME="742"></A>      }        
<FONT ID="LN">743 </FONT><A NAME="743"></A>      m_AvgDocLength += Math.sqrt(docLength);
<FONT ID="LN">744 </FONT><A NAME="744"></A>    }
<FONT ID="LN">745 </FONT><A NAME="745"></A>    m_AvgDocLength /= m_NumInstances;
<FONT ID="LN">746 </FONT><A NAME="746"></A>      }
<FONT ID="LN">747 </FONT><A NAME="747"></A>
<FONT ID="LN">748 </FONT><A NAME="748"></A>      <FONT ID="SingleLineComment">// Perform normalization if necessary.
<FONT ID="LN">749 </FONT><A NAME="749"></A></FONT>      <FONT ID="If">if</FONT> (m_filterType == FILTER_NORMALIZE_ALL) {
<FONT ID="LN">750 </FONT><A NAME="750"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;fv.size(); i++) {
<FONT ID="LN">751 </FONT><A NAME="751"></A>      normalizeInstance((<A HREF="../../../../weka/core/Instance.java.html">Instance</A>) fv.elementAt(i), firstCopy);
<FONT ID="LN">752 </FONT><A NAME="752"></A>    }
<FONT ID="LN">753 </FONT><A NAME="753"></A>      }
<FONT ID="LN">754 </FONT><A NAME="754"></A>
<FONT ID="LN">755 </FONT><A NAME="755"></A>      <FONT ID="SingleLineComment">// Push all instances into the output queue
<FONT ID="LN">756 </FONT><A NAME="756"></A></FONT>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;fv.size(); i++) {
<FONT ID="LN">757 </FONT><A NAME="757"></A>    push((<A HREF="../../../../weka/core/Instance.java.html">Instance</A>) fv.elementAt(i));
<FONT ID="LN">758 </FONT><A NAME="758"></A>      }
<FONT ID="LN">759 </FONT><A NAME="759"></A>    }
<FONT ID="LN">760 </FONT><A NAME="760"></A>
<FONT ID="LN">761 </FONT><A NAME="761"></A>    <FONT ID="SingleLineComment">// Flush the input
<FONT ID="LN">762 </FONT><A NAME="762"></A></FONT>    flushInput();
<FONT ID="LN">763 </FONT><A NAME="763"></A>
<FONT ID="LN">764 </FONT><A NAME="764"></A>    m_NewBatch = <FONT ID="True">true</FONT>;
<FONT ID="LN">765 </FONT><A NAME="765"></A>    m_FirstBatchDone = <FONT ID="True">true</FONT>;
<FONT ID="LN">766 </FONT><A NAME="766"></A>    <FONT ID="Return">return</FONT> (numPendingOutput() != <FONT ID="IntegerLiteral">0</FONT>);
<FONT ID="LN">767 </FONT><A NAME="767"></A>  }
<FONT ID="LN">768 </FONT><A NAME="768"></A>
<FONT ID="LN">769 </FONT><A NAME="769"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">770 </FONT><A NAME="770"></A>   * Returns a string describing this filter.
<FONT ID="LN">771 </FONT><A NAME="771"></A>   * 
<FONT ID="LN">772 </FONT><A NAME="772"></A>   * @return a description of the filter suitable for
<FONT ID="LN">773 </FONT><A NAME="773"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">774 </FONT><A NAME="774"></A>   */</FONT>  
<FONT ID="LN">775 </FONT><A NAME="775"></A>  <FONT ID="Public">public</FONT> String globalInfo() {
<FONT ID="LN">776 </FONT><A NAME="776"></A>    <FONT ID="Return">return</FONT> 
<FONT ID="LN">777 </FONT><A NAME="777"></A>    <FONT ID="StringLiteral">"Converts String attributes into a set of attributes representing "</FONT>
<FONT ID="LN">778 </FONT><A NAME="778"></A>    + <FONT ID="StringLiteral">"word occurrence (depending on the tokenizer) information from the "</FONT>
<FONT ID="LN">779 </FONT><A NAME="779"></A>    + <FONT ID="StringLiteral">"text contained in the strings. The set of words (attributes) is "</FONT>
<FONT ID="LN">780 </FONT><A NAME="780"></A>    + <FONT ID="StringLiteral">"determined by the first batch filtered (typically training data)."</FONT>;
<FONT ID="LN">781 </FONT><A NAME="781"></A>  }  
<FONT ID="LN">782 </FONT><A NAME="782"></A>
<FONT ID="LN">783 </FONT><A NAME="783"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">784 </FONT><A NAME="784"></A>   * Gets whether output instances contain 0 or 1 indicating word
<FONT ID="LN">785 </FONT><A NAME="785"></A>   * presence, or word counts.
<FONT ID="LN">786 </FONT><A NAME="786"></A>   *
<FONT ID="LN">787 </FONT><A NAME="787"></A>   * @return true if word counts should be output.
<FONT ID="LN">788 </FONT><A NAME="788"></A>   */</FONT>
<FONT ID="LN">789 </FONT><A NAME="789"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getOutputWordCounts() {
<FONT ID="LN">790 </FONT><A NAME="790"></A>    <FONT ID="Return">return</FONT> m_OutputCounts;
<FONT ID="LN">791 </FONT><A NAME="791"></A>  }
<FONT ID="LN">792 </FONT><A NAME="792"></A>
<FONT ID="LN">793 </FONT><A NAME="793"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">794 </FONT><A NAME="794"></A>   * Sets whether output instances contain 0 or 1 indicating word
<FONT ID="LN">795 </FONT><A NAME="795"></A>   * presence, or word counts.
<FONT ID="LN">796 </FONT><A NAME="796"></A>   *
<FONT ID="LN">797 </FONT><A NAME="797"></A>   * @param outputWordCounts true if word counts should be output.
<FONT ID="LN">798 </FONT><A NAME="798"></A>   */</FONT>
<FONT ID="LN">799 </FONT><A NAME="799"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setOutputWordCounts(<FONT ID="Boolean">boolean</FONT> outputWordCounts) {
<FONT ID="LN">800 </FONT><A NAME="800"></A>    m_OutputCounts = outputWordCounts;
<FONT ID="LN">801 </FONT><A NAME="801"></A>  }
<FONT ID="LN">802 </FONT><A NAME="802"></A>
<FONT ID="LN">803 </FONT><A NAME="803"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">804 </FONT><A NAME="804"></A>   * Returns the tip text for this property.
<FONT ID="LN">805 </FONT><A NAME="805"></A>   * 
<FONT ID="LN">806 </FONT><A NAME="806"></A>   * @return tip text for this property suitable for
<FONT ID="LN">807 </FONT><A NAME="807"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">808 </FONT><A NAME="808"></A>   */</FONT>
<FONT ID="LN">809 </FONT><A NAME="809"></A>  <FONT ID="Public">public</FONT> String outputWordCountsTipText() {
<FONT ID="LN">810 </FONT><A NAME="810"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Output word counts rather than boolean 0 or 1"</FONT>+
<FONT ID="LN">811 </FONT><A NAME="811"></A>    <FONT ID="StringLiteral">"(indicating presence or absence of a word)."</FONT>;
<FONT ID="LN">812 </FONT><A NAME="812"></A>  }
<FONT ID="LN">813 </FONT><A NAME="813"></A>
<FONT ID="LN">814 </FONT><A NAME="814"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">815 </FONT><A NAME="815"></A>   * Get the value of m_SelectedRange.
<FONT ID="LN">816 </FONT><A NAME="816"></A>   *
<FONT ID="LN">817 </FONT><A NAME="817"></A>   * @return Value of m_SelectedRange.
<FONT ID="LN">818 </FONT><A NAME="818"></A>   */</FONT>
<FONT ID="LN">819 </FONT><A NAME="819"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../../weka/core/Range.java.html">Range</A> getSelectedRange() {
<FONT ID="LN">820 </FONT><A NAME="820"></A>    <FONT ID="Return">return</FONT> m_SelectedRange;
<FONT ID="LN">821 </FONT><A NAME="821"></A>  }
<FONT ID="LN">822 </FONT><A NAME="822"></A>
<FONT ID="LN">823 </FONT><A NAME="823"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">824 </FONT><A NAME="824"></A>   * Set the value of m_SelectedRange.
<FONT ID="LN">825 </FONT><A NAME="825"></A>   *
<FONT ID="LN">826 </FONT><A NAME="826"></A>   * @param newSelectedRange Value to assign to m_SelectedRange.
<FONT ID="LN">827 </FONT><A NAME="827"></A>   */</FONT>
<FONT ID="LN">828 </FONT><A NAME="828"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setSelectedRange(String newSelectedRange) {
<FONT ID="LN">829 </FONT><A NAME="829"></A>    m_SelectedRange = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Range.java.html">Range</A>(newSelectedRange);
<FONT ID="LN">830 </FONT><A NAME="830"></A>  }
<FONT ID="LN">831 </FONT><A NAME="831"></A>
<FONT ID="LN">832 </FONT><A NAME="832"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">833 </FONT><A NAME="833"></A>   * Returns the tip text for this property.
<FONT ID="LN">834 </FONT><A NAME="834"></A>   *
<FONT ID="LN">835 </FONT><A NAME="835"></A>   * @return tip text for this property suitable for
<FONT ID="LN">836 </FONT><A NAME="836"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">837 </FONT><A NAME="837"></A>   */</FONT>
<FONT ID="LN">838 </FONT><A NAME="838"></A>  <FONT ID="Public">public</FONT> String attributeIndicesTipText() {
<FONT ID="LN">839 </FONT><A NAME="839"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Specify range of attributes to act on."</FONT>
<FONT ID="LN">840 </FONT><A NAME="840"></A>    + <FONT ID="StringLiteral">" This is a comma separated list of attribute indices, with"</FONT>
<FONT ID="LN">841 </FONT><A NAME="841"></A>    + <FONT ID="StringLiteral">" \"first\" and \"last\" valid values. Specify an inclusive"</FONT>
<FONT ID="LN">842 </FONT><A NAME="842"></A>    + <FONT ID="StringLiteral">" range with \"-\". E.g: \"first-3,5,6-10,last\"."</FONT>;
<FONT ID="LN">843 </FONT><A NAME="843"></A>  }
<FONT ID="LN">844 </FONT><A NAME="844"></A>
<FONT ID="LN">845 </FONT><A NAME="845"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">846 </FONT><A NAME="846"></A>   * Gets the current range selection.
<FONT ID="LN">847 </FONT><A NAME="847"></A>   *
<FONT ID="LN">848 </FONT><A NAME="848"></A>   * @return a string containing a comma separated list of ranges
<FONT ID="LN">849 </FONT><A NAME="849"></A>   */</FONT>
<FONT ID="LN">850 </FONT><A NAME="850"></A>  <FONT ID="Public">public</FONT> String getAttributeIndices() {
<FONT ID="LN">851 </FONT><A NAME="851"></A>    <FONT ID="Return">return</FONT> m_SelectedRange.getRanges();
<FONT ID="LN">852 </FONT><A NAME="852"></A>  }
<FONT ID="LN">853 </FONT><A NAME="853"></A>
<FONT ID="LN">854 </FONT><A NAME="854"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">855 </FONT><A NAME="855"></A>   * Sets which attributes are to be worked on.
<FONT ID="LN">856 </FONT><A NAME="856"></A>   *
<FONT ID="LN">857 </FONT><A NAME="857"></A>   * @param rangeList a string representing the list of attributes. Since
<FONT ID="LN">858 </FONT><A NAME="858"></A>   * the string will typically come from a user, attributes are indexed from
<FONT ID="LN">859 </FONT><A NAME="859"></A>   * 1. &lt;br&gt;
<FONT ID="LN">860 </FONT><A NAME="860"></A>   * eg: first-3,5,6-last
<FONT ID="LN">861 </FONT><A NAME="861"></A>   * @throws IllegalArgumentException if an invalid range list is supplied 
<FONT ID="LN">862 </FONT><A NAME="862"></A>   */</FONT>
<FONT ID="LN">863 </FONT><A NAME="863"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setAttributeIndices(String rangeList) {
<FONT ID="LN">864 </FONT><A NAME="864"></A>    m_SelectedRange.setRanges(rangeList);
<FONT ID="LN">865 </FONT><A NAME="865"></A>  }
<FONT ID="LN">866 </FONT><A NAME="866"></A>
<FONT ID="LN">867 </FONT><A NAME="867"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">868 </FONT><A NAME="868"></A>   * Sets which attributes are to be processed.
<FONT ID="LN">869 </FONT><A NAME="869"></A>   *
<FONT ID="LN">870 </FONT><A NAME="870"></A>   * @param attributes an array containing indexes of attributes to process.
<FONT ID="LN">871 </FONT><A NAME="871"></A>   * Since the array will typically come from a program, attributes are indexed
<FONT ID="LN">872 </FONT><A NAME="872"></A>   * from 0.
<FONT ID="LN">873 </FONT><A NAME="873"></A>   * @throws IllegalArgumentException if an invalid set of ranges
<FONT ID="LN">874 </FONT><A NAME="874"></A>   * is supplied 
<FONT ID="LN">875 </FONT><A NAME="875"></A>   */</FONT>
<FONT ID="LN">876 </FONT><A NAME="876"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setAttributeIndicesArray(<FONT ID="Int">int</FONT>[] attributes) {
<FONT ID="LN">877 </FONT><A NAME="877"></A>    setAttributeIndices(Range.indicesToRangeList(attributes));
<FONT ID="LN">878 </FONT><A NAME="878"></A>  }
<FONT ID="LN">879 </FONT><A NAME="879"></A>
<FONT ID="LN">880 </FONT><A NAME="880"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">881 </FONT><A NAME="881"></A>   * Returns the tip text for this property.
<FONT ID="LN">882 </FONT><A NAME="882"></A>   *
<FONT ID="LN">883 </FONT><A NAME="883"></A>   * @return tip text for this property suitable for
<FONT ID="LN">884 </FONT><A NAME="884"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">885 </FONT><A NAME="885"></A>   */</FONT>
<FONT ID="LN">886 </FONT><A NAME="886"></A>  <FONT ID="Public">public</FONT> String invertSelectionTipText() {
<FONT ID="LN">887 </FONT><A NAME="887"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Set attribute selection mode. If false, only selected"</FONT>
<FONT ID="LN">888 </FONT><A NAME="888"></A>    + <FONT ID="StringLiteral">" attributes in the range will be worked on; if"</FONT>
<FONT ID="LN">889 </FONT><A NAME="889"></A>    + <FONT ID="StringLiteral">" true, only non-selected attributes will be processed."</FONT>;
<FONT ID="LN">890 </FONT><A NAME="890"></A>  }
<FONT ID="LN">891 </FONT><A NAME="891"></A>
<FONT ID="LN">892 </FONT><A NAME="892"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">893 </FONT><A NAME="893"></A>   * Gets whether the supplied columns are to be processed or skipped.
<FONT ID="LN">894 </FONT><A NAME="894"></A>   *
<FONT ID="LN">895 </FONT><A NAME="895"></A>   * @return true if the supplied columns will be kept
<FONT ID="LN">896 </FONT><A NAME="896"></A>   */</FONT>
<FONT ID="LN">897 </FONT><A NAME="897"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getInvertSelection() {
<FONT ID="LN">898 </FONT><A NAME="898"></A>    <FONT ID="Return">return</FONT> m_SelectedRange.getInvert();
<FONT ID="LN">899 </FONT><A NAME="899"></A>  }
<FONT ID="LN">900 </FONT><A NAME="900"></A>
<FONT ID="LN">901 </FONT><A NAME="901"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">902 </FONT><A NAME="902"></A>   * Sets whether selected columns should be processed or skipped.
<FONT ID="LN">903 </FONT><A NAME="903"></A>   *
<FONT ID="LN">904 </FONT><A NAME="904"></A>   * @param invert the new invert setting
<FONT ID="LN">905 </FONT><A NAME="905"></A>   */</FONT>
<FONT ID="LN">906 </FONT><A NAME="906"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setInvertSelection(<FONT ID="Boolean">boolean</FONT> invert) {
<FONT ID="LN">907 </FONT><A NAME="907"></A>    m_SelectedRange.setInvert(invert);
<FONT ID="LN">908 </FONT><A NAME="908"></A>  }
<FONT ID="LN">909 </FONT><A NAME="909"></A>
<FONT ID="LN">910 </FONT><A NAME="910"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">911 </FONT><A NAME="911"></A>   * Get the attribute name prefix.
<FONT ID="LN">912 </FONT><A NAME="912"></A>   *
<FONT ID="LN">913 </FONT><A NAME="913"></A>   * @return The current attribute name prefix.
<FONT ID="LN">914 </FONT><A NAME="914"></A>   */</FONT>
<FONT ID="LN">915 </FONT><A NAME="915"></A>  <FONT ID="Public">public</FONT> String getAttributeNamePrefix() {
<FONT ID="LN">916 </FONT><A NAME="916"></A>    <FONT ID="Return">return</FONT> m_Prefix;
<FONT ID="LN">917 </FONT><A NAME="917"></A>  }
<FONT ID="LN">918 </FONT><A NAME="918"></A>
<FONT ID="LN">919 </FONT><A NAME="919"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">920 </FONT><A NAME="920"></A>   * Set the attribute name prefix.
<FONT ID="LN">921 </FONT><A NAME="921"></A>   *
<FONT ID="LN">922 </FONT><A NAME="922"></A>   * @param newPrefix String to use as the attribute name prefix.
<FONT ID="LN">923 </FONT><A NAME="923"></A>   */</FONT>
<FONT ID="LN">924 </FONT><A NAME="924"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setAttributeNamePrefix(String newPrefix) {
<FONT ID="LN">925 </FONT><A NAME="925"></A>    m_Prefix = newPrefix;
<FONT ID="LN">926 </FONT><A NAME="926"></A>  }
<FONT ID="LN">927 </FONT><A NAME="927"></A>
<FONT ID="LN">928 </FONT><A NAME="928"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">929 </FONT><A NAME="929"></A>   * Returns the tip text for this property.
<FONT ID="LN">930 </FONT><A NAME="930"></A>   * 
<FONT ID="LN">931 </FONT><A NAME="931"></A>   * @return tip text for this property suitable for
<FONT ID="LN">932 </FONT><A NAME="932"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">933 </FONT><A NAME="933"></A>   */</FONT>
<FONT ID="LN">934 </FONT><A NAME="934"></A>  <FONT ID="Public">public</FONT> String attributeNamePrefixTipText() {
<FONT ID="LN">935 </FONT><A NAME="935"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Prefix for the created attribute names. "</FONT>+
<FONT ID="LN">936 </FONT><A NAME="936"></A>    <FONT ID="StringLiteral">"(default: \"\")"</FONT>;
<FONT ID="LN">937 </FONT><A NAME="937"></A>  }
<FONT ID="LN">938 </FONT><A NAME="938"></A>
<FONT ID="LN">939 </FONT><A NAME="939"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">940 </FONT><A NAME="940"></A>   * Gets the number of words (per class if there is a class attribute
<FONT ID="LN">941 </FONT><A NAME="941"></A>   * assigned) to attempt to keep.
<FONT ID="LN">942 </FONT><A NAME="942"></A>   *
<FONT ID="LN">943 </FONT><A NAME="943"></A>   * @return the target number of words in the output vector (per class if
<FONT ID="LN">944 </FONT><A NAME="944"></A>   * assigned).
<FONT ID="LN">945 </FONT><A NAME="945"></A>   */</FONT>
<FONT ID="LN">946 </FONT><A NAME="946"></A>  <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> getWordsToKeep() {
<FONT ID="LN">947 </FONT><A NAME="947"></A>    <FONT ID="Return">return</FONT> m_WordsToKeep;
<FONT ID="LN">948 </FONT><A NAME="948"></A>  }
<FONT ID="LN">949 </FONT><A NAME="949"></A>
<FONT ID="LN">950 </FONT><A NAME="950"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">951 </FONT><A NAME="951"></A>   * Sets the number of words (per class if there is a class attribute
<FONT ID="LN">952 </FONT><A NAME="952"></A>   * assigned) to attempt to keep.
<FONT ID="LN">953 </FONT><A NAME="953"></A>   *
<FONT ID="LN">954 </FONT><A NAME="954"></A>   * @param newWordsToKeep the target number of words in the output 
<FONT ID="LN">955 </FONT><A NAME="955"></A>   * vector (per class if assigned).
<FONT ID="LN">956 </FONT><A NAME="956"></A>   */</FONT>
<FONT ID="LN">957 </FONT><A NAME="957"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setWordsToKeep(<FONT ID="Int">int</FONT> newWordsToKeep) {
<FONT ID="LN">958 </FONT><A NAME="958"></A>    m_WordsToKeep = newWordsToKeep;
<FONT ID="LN">959 </FONT><A NAME="959"></A>  }
<FONT ID="LN">960 </FONT><A NAME="960"></A>
<FONT ID="LN">961 </FONT><A NAME="961"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">962 </FONT><A NAME="962"></A>   * Returns the tip text for this property.
<FONT ID="LN">963 </FONT><A NAME="963"></A>   * 
<FONT ID="LN">964 </FONT><A NAME="964"></A>   * @return tip text for this property suitable for
<FONT ID="LN">965 </FONT><A NAME="965"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">966 </FONT><A NAME="966"></A>   */</FONT>
<FONT ID="LN">967 </FONT><A NAME="967"></A>  <FONT ID="Public">public</FONT> String wordsToKeepTipText() {
<FONT ID="LN">968 </FONT><A NAME="968"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The number of words (per class if there is a class attribute "</FONT>+
<FONT ID="LN">969 </FONT><A NAME="969"></A>    <FONT ID="StringLiteral">"assigned) to attempt to keep."</FONT>;
<FONT ID="LN">970 </FONT><A NAME="970"></A>  }
<FONT ID="LN">971 </FONT><A NAME="971"></A>
<FONT ID="LN">972 </FONT><A NAME="972"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">973 </FONT><A NAME="973"></A>   * Gets the rate at which the dictionary is periodically pruned, as a 
<FONT ID="LN">974 </FONT><A NAME="974"></A>   * percentage of the dataset size.
<FONT ID="LN">975 </FONT><A NAME="975"></A>   *
<FONT ID="LN">976 </FONT><A NAME="976"></A>   * @return the rate at which the dictionary is periodically pruned
<FONT ID="LN">977 </FONT><A NAME="977"></A>   */</FONT>
<FONT ID="LN">978 </FONT><A NAME="978"></A>  <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getPeriodicPruning() {
<FONT ID="LN">979 </FONT><A NAME="979"></A>    <FONT ID="Return">return</FONT> m_PeriodicPruningRate;
<FONT ID="LN">980 </FONT><A NAME="980"></A>  }
<FONT ID="LN">981 </FONT><A NAME="981"></A>
<FONT ID="LN">982 </FONT><A NAME="982"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">983 </FONT><A NAME="983"></A>   * Sets the rate at which the dictionary is periodically pruned, as a 
<FONT ID="LN">984 </FONT><A NAME="984"></A>   * percentage of the dataset size.
<FONT ID="LN">985 </FONT><A NAME="985"></A>   *
<FONT ID="LN">986 </FONT><A NAME="986"></A>   * @param newPeriodicPruning the rate at which the dictionary is periodically pruned
<FONT ID="LN">987 </FONT><A NAME="987"></A>   */</FONT>
<FONT ID="LN">988 </FONT><A NAME="988"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setPeriodicPruning(<FONT ID="Double">double</FONT> newPeriodicPruning) {
<FONT ID="LN">989 </FONT><A NAME="989"></A>    m_PeriodicPruningRate = newPeriodicPruning;
<FONT ID="LN">990 </FONT><A NAME="990"></A>  }
<FONT ID="LN">991 </FONT><A NAME="991"></A>
<FONT ID="LN">992 </FONT><A NAME="992"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">993 </FONT><A NAME="993"></A>   * Returns the tip text for this property.
<FONT ID="LN">994 </FONT><A NAME="994"></A>   * 
<FONT ID="LN">995 </FONT><A NAME="995"></A>   * @return tip text for this property suitable for
<FONT ID="LN">996 </FONT><A NAME="996"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">997 </FONT><A NAME="997"></A>   */</FONT>
<FONT ID="LN">998 </FONT><A NAME="998"></A>  <FONT ID="Public">public</FONT> String periodicPruningTipText() {
<FONT ID="LN">999 </FONT><A NAME="999"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Specify the rate (x% of the input dataset) at which to periodically prune the dictionary. "</FONT>
<FONT ID="LN">1000</FONT><A NAME="1000"></A>    + <FONT ID="StringLiteral">"wordsToKeep prunes after creating a full dictionary. You may not have enough "</FONT>
<FONT ID="LN">1001</FONT><A NAME="1001"></A>    + <FONT ID="StringLiteral">"memory for this approach."</FONT>;
<FONT ID="LN">1002</FONT><A NAME="1002"></A>  }
<FONT ID="LN">1003</FONT><A NAME="1003"></A>
<FONT ID="LN">1004</FONT><A NAME="1004"></A>  <FONT ID="FormalComment">/** Gets whether if the word frequencies should be transformed into
<FONT ID="LN">1005</FONT><A NAME="1005"></A>   *  log(1+fij) where fij is the frequency of word i in document(instance) j.
<FONT ID="LN">1006</FONT><A NAME="1006"></A>   *
<FONT ID="LN">1007</FONT><A NAME="1007"></A>   * @return true if word frequencies are to be transformed.
<FONT ID="LN">1008</FONT><A NAME="1008"></A>   */</FONT>
<FONT ID="LN">1009</FONT><A NAME="1009"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getTFTransform() {
<FONT ID="LN">1010</FONT><A NAME="1010"></A>    <FONT ID="Return">return</FONT> <FONT ID="This">this</FONT>.m_TFTransform;
<FONT ID="LN">1011</FONT><A NAME="1011"></A>  }
<FONT ID="LN">1012</FONT><A NAME="1012"></A>
<FONT ID="LN">1013</FONT><A NAME="1013"></A>  <FONT ID="FormalComment">/** Sets whether if the word frequencies should be transformed into
<FONT ID="LN">1014</FONT><A NAME="1014"></A>   *  log(1+fij) where fij is the frequency of word i in document(instance) j.
<FONT ID="LN">1015</FONT><A NAME="1015"></A>   *
<FONT ID="LN">1016</FONT><A NAME="1016"></A>   * @param TFTransform true if word frequencies are to be transformed.
<FONT ID="LN">1017</FONT><A NAME="1017"></A>   */</FONT>
<FONT ID="LN">1018</FONT><A NAME="1018"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setTFTransform(<FONT ID="Boolean">boolean</FONT> TFTransform) {
<FONT ID="LN">1019</FONT><A NAME="1019"></A>    <FONT ID="This">this</FONT>.m_TFTransform = TFTransform;
<FONT ID="LN">1020</FONT><A NAME="1020"></A>  }
<FONT ID="LN">1021</FONT><A NAME="1021"></A>
<FONT ID="LN">1022</FONT><A NAME="1022"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1023</FONT><A NAME="1023"></A>   * Returns the tip text for this property.
<FONT ID="LN">1024</FONT><A NAME="1024"></A>   * 
<FONT ID="LN">1025</FONT><A NAME="1025"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1026</FONT><A NAME="1026"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1027</FONT><A NAME="1027"></A>   */</FONT>
<FONT ID="LN">1028</FONT><A NAME="1028"></A>  <FONT ID="Public">public</FONT> String TFTransformTipText() {
<FONT ID="LN">1029</FONT><A NAME="1029"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Sets whether if the word frequencies should be transformed into:\n "</FONT>+
<FONT ID="LN">1030</FONT><A NAME="1030"></A>    <FONT ID="StringLiteral">"   log(1+fij) \n"</FONT>+
<FONT ID="LN">1031</FONT><A NAME="1031"></A>    <FONT ID="StringLiteral">"       where fij is the frequency of word i in document (instance) j."</FONT>;
<FONT ID="LN">1032</FONT><A NAME="1032"></A>  }
<FONT ID="LN">1033</FONT><A NAME="1033"></A>
<FONT ID="LN">1034</FONT><A NAME="1034"></A>  <FONT ID="FormalComment">/** Sets whether if the word frequencies in a document should be transformed
<FONT ID="LN">1035</FONT><A NAME="1035"></A>   * into: &lt;br&gt;
<FONT ID="LN">1036</FONT><A NAME="1036"></A>   * fij*log(num of Docs/num of Docs with word i) &lt;br&gt;
<FONT ID="LN">1037</FONT><A NAME="1037"></A>   *      where fij is the frequency of word i in document(instance) j.
<FONT ID="LN">1038</FONT><A NAME="1038"></A>   *
<FONT ID="LN">1039</FONT><A NAME="1039"></A>   * @return true if the word frequencies are to be transformed.
<FONT ID="LN">1040</FONT><A NAME="1040"></A>   */</FONT>
<FONT ID="LN">1041</FONT><A NAME="1041"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getIDFTransform() {
<FONT ID="LN">1042</FONT><A NAME="1042"></A>    <FONT ID="Return">return</FONT> <FONT ID="This">this</FONT>.m_IDFTransform;
<FONT ID="LN">1043</FONT><A NAME="1043"></A>  }
<FONT ID="LN">1044</FONT><A NAME="1044"></A>
<FONT ID="LN">1045</FONT><A NAME="1045"></A>  <FONT ID="FormalComment">/** Sets whether if the word frequencies in a document should be transformed
<FONT ID="LN">1046</FONT><A NAME="1046"></A>   * into: &lt;br&gt;
<FONT ID="LN">1047</FONT><A NAME="1047"></A>   * fij*log(num of Docs/num of Docs with word i) &lt;br&gt;
<FONT ID="LN">1048</FONT><A NAME="1048"></A>   *      where fij is the frequency of word i in document(instance) j.
<FONT ID="LN">1049</FONT><A NAME="1049"></A>   *
<FONT ID="LN">1050</FONT><A NAME="1050"></A>   * @param IDFTransform true if the word frequecies are to be transformed
<FONT ID="LN">1051</FONT><A NAME="1051"></A>   */</FONT>
<FONT ID="LN">1052</FONT><A NAME="1052"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setIDFTransform(<FONT ID="Boolean">boolean</FONT> IDFTransform) {
<FONT ID="LN">1053</FONT><A NAME="1053"></A>    <FONT ID="This">this</FONT>.m_IDFTransform = IDFTransform;
<FONT ID="LN">1054</FONT><A NAME="1054"></A>  }
<FONT ID="LN">1055</FONT><A NAME="1055"></A>
<FONT ID="LN">1056</FONT><A NAME="1056"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1057</FONT><A NAME="1057"></A>   * Returns the tip text for this property.
<FONT ID="LN">1058</FONT><A NAME="1058"></A>   * 
<FONT ID="LN">1059</FONT><A NAME="1059"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1060</FONT><A NAME="1060"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1061</FONT><A NAME="1061"></A>   */</FONT>
<FONT ID="LN">1062</FONT><A NAME="1062"></A>  <FONT ID="Public">public</FONT> String IDFTransformTipText() {
<FONT ID="LN">1063</FONT><A NAME="1063"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Sets whether if the word frequencies in a document should be "</FONT>+
<FONT ID="LN">1064</FONT><A NAME="1064"></A>    <FONT ID="StringLiteral">"transformed into: \n"</FONT>+
<FONT ID="LN">1065</FONT><A NAME="1065"></A>    <FONT ID="StringLiteral">"   fij*log(num of Docs/num of Docs with word i) \n"</FONT>+
<FONT ID="LN">1066</FONT><A NAME="1066"></A>    <FONT ID="StringLiteral">"      where fij is the frequency of word i in document (instance) j."</FONT>;
<FONT ID="LN">1067</FONT><A NAME="1067"></A>  }
<FONT ID="LN">1068</FONT><A NAME="1068"></A>
<FONT ID="LN">1069</FONT><A NAME="1069"></A>
<FONT ID="LN">1070</FONT><A NAME="1070"></A>  <FONT ID="FormalComment">/** Gets whether if the word frequencies for a document (instance) should
<FONT ID="LN">1071</FONT><A NAME="1071"></A>   *  be normalized or not.
<FONT ID="LN">1072</FONT><A NAME="1072"></A>   *
<FONT ID="LN">1073</FONT><A NAME="1073"></A>   * @return true if word frequencies are to be normalized.
<FONT ID="LN">1074</FONT><A NAME="1074"></A>   */</FONT>
<FONT ID="LN">1075</FONT><A NAME="1075"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">SelectedTag</A> getNormalizeDocLength() {
<FONT ID="LN">1076</FONT><A NAME="1076"></A>
<FONT ID="LN">1077</FONT><A NAME="1077"></A>    <FONT ID="Return">return</FONT> <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SelectedTag.java.html">SelectedTag</A>(m_filterType, TAGS_FILTER);
<FONT ID="LN">1078</FONT><A NAME="1078"></A>  }
<FONT ID="LN">1079</FONT><A NAME="1079"></A>
<FONT ID="LN">1080</FONT><A NAME="1080"></A>  <FONT ID="FormalComment">/** Sets whether if the word frequencies for a document (instance) should
<FONT ID="LN">1081</FONT><A NAME="1081"></A>   *  be normalized or not.
<FONT ID="LN">1082</FONT><A NAME="1082"></A>   *
<FONT ID="LN">1083</FONT><A NAME="1083"></A>   * @param newType the new type.
<FONT ID="LN">1084</FONT><A NAME="1084"></A>   */</FONT>
<FONT ID="LN">1085</FONT><A NAME="1085"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setNormalizeDocLength(<A HREF="../../../../weka/core/SelectedTag.java.html">SelectedTag</A> newType) {
<FONT ID="LN">1086</FONT><A NAME="1086"></A>
<FONT ID="LN">1087</FONT><A NAME="1087"></A>    <FONT ID="If">if</FONT> (newType.getTags() == TAGS_FILTER) {
<FONT ID="LN">1088</FONT><A NAME="1088"></A>      m_filterType = newType.getSelectedTag().getID();
<FONT ID="LN">1089</FONT><A NAME="1089"></A>    }
<FONT ID="LN">1090</FONT><A NAME="1090"></A>  }
<FONT ID="LN">1091</FONT><A NAME="1091"></A>
<FONT ID="LN">1092</FONT><A NAME="1092"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1093</FONT><A NAME="1093"></A>   * Returns the tip text for this property.
<FONT ID="LN">1094</FONT><A NAME="1094"></A>   *
<FONT ID="LN">1095</FONT><A NAME="1095"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1096</FONT><A NAME="1096"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1097</FONT><A NAME="1097"></A>   */</FONT>
<FONT ID="LN">1098</FONT><A NAME="1098"></A>  <FONT ID="Public">public</FONT> String normalizeDocLengthTipText() {
<FONT ID="LN">1099</FONT><A NAME="1099"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Sets whether if the word frequencies for a document (instance) "</FONT>+
<FONT ID="LN">1100</FONT><A NAME="1100"></A>    <FONT ID="StringLiteral">"should be normalized or not."</FONT>;
<FONT ID="LN">1101</FONT><A NAME="1101"></A>  }
<FONT ID="LN">1102</FONT><A NAME="1102"></A>
<FONT ID="LN">1103</FONT><A NAME="1103"></A>  <FONT ID="FormalComment">/** Gets whether if the tokens are to be downcased or not.
<FONT ID="LN">1104</FONT><A NAME="1104"></A>   *
<FONT ID="LN">1105</FONT><A NAME="1105"></A>   * @return true if the tokens are to be downcased.
<FONT ID="LN">1106</FONT><A NAME="1106"></A>   */</FONT>
<FONT ID="LN">1107</FONT><A NAME="1107"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getLowerCaseTokens() {
<FONT ID="LN">1108</FONT><A NAME="1108"></A>    <FONT ID="Return">return</FONT> <FONT ID="This">this</FONT>.m_lowerCaseTokens;
<FONT ID="LN">1109</FONT><A NAME="1109"></A>  }
<FONT ID="LN">1110</FONT><A NAME="1110"></A>
<FONT ID="LN">1111</FONT><A NAME="1111"></A>  <FONT ID="FormalComment">/** Sets whether if the tokens are to be downcased or not. (Doesn't affect
<FONT ID="LN">1112</FONT><A NAME="1112"></A>   * non-alphabetic characters in tokens).
<FONT ID="LN">1113</FONT><A NAME="1113"></A>   *
<FONT ID="LN">1114</FONT><A NAME="1114"></A>   * @param downCaseTokens should be true if only lower case tokens are 
<FONT ID="LN">1115</FONT><A NAME="1115"></A>   * to be formed.
<FONT ID="LN">1116</FONT><A NAME="1116"></A>   */</FONT>
<FONT ID="LN">1117</FONT><A NAME="1117"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setLowerCaseTokens(<FONT ID="Boolean">boolean</FONT> downCaseTokens) {
<FONT ID="LN">1118</FONT><A NAME="1118"></A>    <FONT ID="This">this</FONT>.m_lowerCaseTokens = downCaseTokens;
<FONT ID="LN">1119</FONT><A NAME="1119"></A>  }
<FONT ID="LN">1120</FONT><A NAME="1120"></A>
<FONT ID="LN">1121</FONT><A NAME="1121"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1122</FONT><A NAME="1122"></A>   * Returns the tip text for this property.
<FONT ID="LN">1123</FONT><A NAME="1123"></A>   *
<FONT ID="LN">1124</FONT><A NAME="1124"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1125</FONT><A NAME="1125"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1126</FONT><A NAME="1126"></A>   */</FONT>
<FONT ID="LN">1127</FONT><A NAME="1127"></A>  <FONT ID="Public">public</FONT> String doNotOperateOnPerClassBasisTipText() {
<FONT ID="LN">1128</FONT><A NAME="1128"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"If this is set, the maximum number of words and the "</FONT>
<FONT ID="LN">1129</FONT><A NAME="1129"></A>    + <FONT ID="StringLiteral">"minimum term frequency is not enforced on a per-class "</FONT>
<FONT ID="LN">1130</FONT><A NAME="1130"></A>    + <FONT ID="StringLiteral">"basis but based on the documents in all the classes "</FONT>
<FONT ID="LN">1131</FONT><A NAME="1131"></A>    +  <FONT ID="StringLiteral">"(even if a class attribute is set)."</FONT>;
<FONT ID="LN">1132</FONT><A NAME="1132"></A>  }
<FONT ID="LN">1133</FONT><A NAME="1133"></A>
<FONT ID="LN">1134</FONT><A NAME="1134"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1135</FONT><A NAME="1135"></A>   * Get the DoNotOperateOnPerClassBasis value.
<FONT ID="LN">1136</FONT><A NAME="1136"></A>   * @return the DoNotOperateOnPerClassBasis value.
<FONT ID="LN">1137</FONT><A NAME="1137"></A>   */</FONT>
<FONT ID="LN">1138</FONT><A NAME="1138"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getDoNotOperateOnPerClassBasis() {
<FONT ID="LN">1139</FONT><A NAME="1139"></A>    <FONT ID="Return">return</FONT> m_doNotOperateOnPerClassBasis;
<FONT ID="LN">1140</FONT><A NAME="1140"></A>  }
<FONT ID="LN">1141</FONT><A NAME="1141"></A>
<FONT ID="LN">1142</FONT><A NAME="1142"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1143</FONT><A NAME="1143"></A>   * Set the DoNotOperateOnPerClassBasis value.
<FONT ID="LN">1144</FONT><A NAME="1144"></A>   * @param newDoNotOperateOnPerClassBasis The new DoNotOperateOnPerClassBasis value.
<FONT ID="LN">1145</FONT><A NAME="1145"></A>   */</FONT>
<FONT ID="LN">1146</FONT><A NAME="1146"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setDoNotOperateOnPerClassBasis(<FONT ID="Boolean">boolean</FONT> newDoNotOperateOnPerClassBasis) {
<FONT ID="LN">1147</FONT><A NAME="1147"></A>    <FONT ID="This">this</FONT>.m_doNotOperateOnPerClassBasis = newDoNotOperateOnPerClassBasis;
<FONT ID="LN">1148</FONT><A NAME="1148"></A>  }
<FONT ID="LN">1149</FONT><A NAME="1149"></A>
<FONT ID="LN">1150</FONT><A NAME="1150"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1151</FONT><A NAME="1151"></A>   * Returns the tip text for this property.
<FONT ID="LN">1152</FONT><A NAME="1152"></A>   *
<FONT ID="LN">1153</FONT><A NAME="1153"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1154</FONT><A NAME="1154"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1155</FONT><A NAME="1155"></A>   */</FONT>
<FONT ID="LN">1156</FONT><A NAME="1156"></A>  <FONT ID="Public">public</FONT> String minTermFreqTipText() {
<FONT ID="LN">1157</FONT><A NAME="1157"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Sets the minimum term frequency. This is enforced "</FONT>
<FONT ID="LN">1158</FONT><A NAME="1158"></A>    + <FONT ID="StringLiteral">"on a per-class basis."</FONT>;
<FONT ID="LN">1159</FONT><A NAME="1159"></A>  }
<FONT ID="LN">1160</FONT><A NAME="1160"></A>
<FONT ID="LN">1161</FONT><A NAME="1161"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1162</FONT><A NAME="1162"></A>   * Get the MinTermFreq value.
<FONT ID="LN">1163</FONT><A NAME="1163"></A>   * @return the MinTermFreq value.
<FONT ID="LN">1164</FONT><A NAME="1164"></A>   */</FONT>
<FONT ID="LN">1165</FONT><A NAME="1165"></A>  <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> getMinTermFreq() {
<FONT ID="LN">1166</FONT><A NAME="1166"></A>    <FONT ID="Return">return</FONT> m_minTermFreq;
<FONT ID="LN">1167</FONT><A NAME="1167"></A>  }
<FONT ID="LN">1168</FONT><A NAME="1168"></A>
<FONT ID="LN">1169</FONT><A NAME="1169"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1170</FONT><A NAME="1170"></A>   * Set the MinTermFreq value.
<FONT ID="LN">1171</FONT><A NAME="1171"></A>   * @param newMinTermFreq The new MinTermFreq value.
<FONT ID="LN">1172</FONT><A NAME="1172"></A>   */</FONT>
<FONT ID="LN">1173</FONT><A NAME="1173"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setMinTermFreq(<FONT ID="Int">int</FONT> newMinTermFreq) {
<FONT ID="LN">1174</FONT><A NAME="1174"></A>    <FONT ID="This">this</FONT>.m_minTermFreq = newMinTermFreq;
<FONT ID="LN">1175</FONT><A NAME="1175"></A>  }
<FONT ID="LN">1176</FONT><A NAME="1176"></A>
<FONT ID="LN">1177</FONT><A NAME="1177"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1178</FONT><A NAME="1178"></A>   * Returns the tip text for this property.
<FONT ID="LN">1179</FONT><A NAME="1179"></A>   *
<FONT ID="LN">1180</FONT><A NAME="1180"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1181</FONT><A NAME="1181"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1182</FONT><A NAME="1182"></A>   */</FONT>
<FONT ID="LN">1183</FONT><A NAME="1183"></A>  <FONT ID="Public">public</FONT> String lowerCaseTokensTipText() {
<FONT ID="LN">1184</FONT><A NAME="1184"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"If set then all the word tokens are converted to lower case "</FONT>+
<FONT ID="LN">1185</FONT><A NAME="1185"></A>    <FONT ID="StringLiteral">"before being added to the dictionary."</FONT>;
<FONT ID="LN">1186</FONT><A NAME="1186"></A>  }
<FONT ID="LN">1187</FONT><A NAME="1187"></A>
<FONT ID="LN">1188</FONT><A NAME="1188"></A>  <FONT ID="FormalComment">/** Gets whether if the words on the stoplist are to be ignored (The stoplist
<FONT ID="LN">1189</FONT><A NAME="1189"></A>   *  is in weka.core.StopWords).
<FONT ID="LN">1190</FONT><A NAME="1190"></A>   *
<FONT ID="LN">1191</FONT><A NAME="1191"></A>   * @return true if the words on the stoplist are to be ignored.
<FONT ID="LN">1192</FONT><A NAME="1192"></A>   */</FONT>
<FONT ID="LN">1193</FONT><A NAME="1193"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getUseStoplist() {
<FONT ID="LN">1194</FONT><A NAME="1194"></A>    <FONT ID="Return">return</FONT> m_useStoplist;
<FONT ID="LN">1195</FONT><A NAME="1195"></A>  }  
<FONT ID="LN">1196</FONT><A NAME="1196"></A>
<FONT ID="LN">1197</FONT><A NAME="1197"></A>  <FONT ID="FormalComment">/** Sets whether if the words that are on a stoplist are to be ignored (The
<FONT ID="LN">1198</FONT><A NAME="1198"></A>   * stop list is in weka.core.StopWords).
<FONT ID="LN">1199</FONT><A NAME="1199"></A>   *
<FONT ID="LN">1200</FONT><A NAME="1200"></A>   * @param useStoplist true if the tokens that are on a stoplist are to be 
<FONT ID="LN">1201</FONT><A NAME="1201"></A>   * ignored.
<FONT ID="LN">1202</FONT><A NAME="1202"></A>   */</FONT>
<FONT ID="LN">1203</FONT><A NAME="1203"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setUseStoplist(<FONT ID="Boolean">boolean</FONT> useStoplist) {
<FONT ID="LN">1204</FONT><A NAME="1204"></A>    m_useStoplist = useStoplist;
<FONT ID="LN">1205</FONT><A NAME="1205"></A>  }  
<FONT ID="LN">1206</FONT><A NAME="1206"></A>
<FONT ID="LN">1207</FONT><A NAME="1207"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1208</FONT><A NAME="1208"></A>   * Returns the tip text for this property.
<FONT ID="LN">1209</FONT><A NAME="1209"></A>   *
<FONT ID="LN">1210</FONT><A NAME="1210"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1211</FONT><A NAME="1211"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1212</FONT><A NAME="1212"></A>   */</FONT>
<FONT ID="LN">1213</FONT><A NAME="1213"></A>  <FONT ID="Public">public</FONT> String useStoplistTipText() {
<FONT ID="LN">1214</FONT><A NAME="1214"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Ignores all the words that are on the stoplist, if set to true."</FONT>;
<FONT ID="LN">1215</FONT><A NAME="1215"></A>  } 
<FONT ID="LN">1216</FONT><A NAME="1216"></A>
<FONT ID="LN">1217</FONT><A NAME="1217"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1218</FONT><A NAME="1218"></A>   * the stemming algorithm to use, null means no stemming at all (i.e., the
<FONT ID="LN">1219</FONT><A NAME="1219"></A>   * NullStemmer is used).
<FONT ID="LN">1220</FONT><A NAME="1220"></A>   *
<FONT ID="LN">1221</FONT><A NAME="1221"></A>   * @param value     the configured stemming algorithm, or null
<FONT ID="LN">1222</FONT><A NAME="1222"></A>   * @see             NullStemmer
<FONT ID="LN">1223</FONT><A NAME="1223"></A>   */</FONT>
<FONT ID="LN">1224</FONT><A NAME="1224"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setStemmer(<A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">Stemmer</A> value) {
<FONT ID="LN">1225</FONT><A NAME="1225"></A>    <FONT ID="If">if</FONT> (value != <FONT ID="Null">null</FONT>)
<FONT ID="LN">1226</FONT><A NAME="1226"></A>      m_Stemmer = value;
<FONT ID="LN">1227</FONT><A NAME="1227"></A>    <FONT ID="Else">else</FONT>
<FONT ID="LN">1228</FONT><A NAME="1228"></A>      m_Stemmer = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">NullStemmer</A>();
<FONT ID="LN">1229</FONT><A NAME="1229"></A>  }
<FONT ID="LN">1230</FONT><A NAME="1230"></A>
<FONT ID="LN">1231</FONT><A NAME="1231"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1232</FONT><A NAME="1232"></A>   * Returns the current stemming algorithm, null if none is used.
<FONT ID="LN">1233</FONT><A NAME="1233"></A>   *
<FONT ID="LN">1234</FONT><A NAME="1234"></A>   * @return          the current stemming algorithm, null if none set
<FONT ID="LN">1235</FONT><A NAME="1235"></A>   */</FONT>
<FONT ID="LN">1236</FONT><A NAME="1236"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../../weka/core/stemmers/NullStemmer.java.html">Stemmer</A> getStemmer() {
<FONT ID="LN">1237</FONT><A NAME="1237"></A>    <FONT ID="Return">return</FONT> m_Stemmer;
<FONT ID="LN">1238</FONT><A NAME="1238"></A>  }
<FONT ID="LN">1239</FONT><A NAME="1239"></A>
<FONT ID="LN">1240</FONT><A NAME="1240"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1241</FONT><A NAME="1241"></A>   * Returns the tip text for this property.
<FONT ID="LN">1242</FONT><A NAME="1242"></A>   *
<FONT ID="LN">1243</FONT><A NAME="1243"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1244</FONT><A NAME="1244"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1245</FONT><A NAME="1245"></A>   */</FONT>
<FONT ID="LN">1246</FONT><A NAME="1246"></A>  <FONT ID="Public">public</FONT> String stemmerTipText() {
<FONT ID="LN">1247</FONT><A NAME="1247"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The stemming algorithm to use on the words."</FONT>;
<FONT ID="LN">1248</FONT><A NAME="1248"></A>  }
<FONT ID="LN">1249</FONT><A NAME="1249"></A>
<FONT ID="LN">1250</FONT><A NAME="1250"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1251</FONT><A NAME="1251"></A>   * sets the file containing the stopwords, null or a directory unset the
<FONT ID="LN">1252</FONT><A NAME="1252"></A>   * stopwords. If the file exists, it automatically turns on the flag to
<FONT ID="LN">1253</FONT><A NAME="1253"></A>   * use the stoplist.
<FONT ID="LN">1254</FONT><A NAME="1254"></A>   *
<FONT ID="LN">1255</FONT><A NAME="1255"></A>   * @param value     the file containing the stopwords
<FONT ID="LN">1256</FONT><A NAME="1256"></A>   */</FONT>
<FONT ID="LN">1257</FONT><A NAME="1257"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setStopwords(File value) {
<FONT ID="LN">1258</FONT><A NAME="1258"></A>    <FONT ID="If">if</FONT> (value == <FONT ID="Null">null</FONT>)
<FONT ID="LN">1259</FONT><A NAME="1259"></A>      value = <FONT ID="New">new</FONT> File(System.getProperty(<FONT ID="StringLiteral">"user.dir"</FONT>));
<FONT ID="LN">1260</FONT><A NAME="1260"></A>
<FONT ID="LN">1261</FONT><A NAME="1261"></A>    m_Stopwords = value;
<FONT ID="LN">1262</FONT><A NAME="1262"></A>    <FONT ID="If">if</FONT> (value.exists() &amp;&amp; value.isFile())
<FONT ID="LN">1263</FONT><A NAME="1263"></A>      setUseStoplist(<FONT ID="True">true</FONT>);
<FONT ID="LN">1264</FONT><A NAME="1264"></A>  }
<FONT ID="LN">1265</FONT><A NAME="1265"></A>
<FONT ID="LN">1266</FONT><A NAME="1266"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1267</FONT><A NAME="1267"></A>   * returns the file used for obtaining the stopwords, if the file represents
<FONT ID="LN">1268</FONT><A NAME="1268"></A>   * a directory then the default ones are used.
<FONT ID="LN">1269</FONT><A NAME="1269"></A>   *
<FONT ID="LN">1270</FONT><A NAME="1270"></A>   * @return          the file containing the stopwords
<FONT ID="LN">1271</FONT><A NAME="1271"></A>   */</FONT>
<FONT ID="LN">1272</FONT><A NAME="1272"></A>  <FONT ID="Public">public</FONT> File getStopwords() {
<FONT ID="LN">1273</FONT><A NAME="1273"></A>    <FONT ID="Return">return</FONT> m_Stopwords;
<FONT ID="LN">1274</FONT><A NAME="1274"></A>  }
<FONT ID="LN">1275</FONT><A NAME="1275"></A>
<FONT ID="LN">1276</FONT><A NAME="1276"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1277</FONT><A NAME="1277"></A>   * Returns the tip text for this property.
<FONT ID="LN">1278</FONT><A NAME="1278"></A>   *
<FONT ID="LN">1279</FONT><A NAME="1279"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1280</FONT><A NAME="1280"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1281</FONT><A NAME="1281"></A>   */</FONT>
<FONT ID="LN">1282</FONT><A NAME="1282"></A>  <FONT ID="Public">public</FONT> String stopwordsTipText() {
<FONT ID="LN">1283</FONT><A NAME="1283"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The file containing the stopwords (if this is a directory then the default ones are used)."</FONT>;
<FONT ID="LN">1284</FONT><A NAME="1284"></A>  }
<FONT ID="LN">1285</FONT><A NAME="1285"></A>
<FONT ID="LN">1286</FONT><A NAME="1286"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1287</FONT><A NAME="1287"></A>   * the tokenizer algorithm to use.
<FONT ID="LN">1288</FONT><A NAME="1288"></A>   *
<FONT ID="LN">1289</FONT><A NAME="1289"></A>   * @param value     the configured tokenizing algorithm
<FONT ID="LN">1290</FONT><A NAME="1290"></A>   */</FONT>
<FONT ID="LN">1291</FONT><A NAME="1291"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setTokenizer(<A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">Tokenizer</A> value) {
<FONT ID="LN">1292</FONT><A NAME="1292"></A>    m_Tokenizer = value;
<FONT ID="LN">1293</FONT><A NAME="1293"></A>  }
<FONT ID="LN">1294</FONT><A NAME="1294"></A>
<FONT ID="LN">1295</FONT><A NAME="1295"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1296</FONT><A NAME="1296"></A>   * Returns the current tokenizer algorithm.
<FONT ID="LN">1297</FONT><A NAME="1297"></A>   *
<FONT ID="LN">1298</FONT><A NAME="1298"></A>   * @return          the current tokenizer algorithm
<FONT ID="LN">1299</FONT><A NAME="1299"></A>   */</FONT>
<FONT ID="LN">1300</FONT><A NAME="1300"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../../weka/core/tokenizers/Tokenizer.java.html">Tokenizer</A> getTokenizer() {
<FONT ID="LN">1301</FONT><A NAME="1301"></A>    <FONT ID="Return">return</FONT> m_Tokenizer;
<FONT ID="LN">1302</FONT><A NAME="1302"></A>  }
<FONT ID="LN">1303</FONT><A NAME="1303"></A>
<FONT ID="LN">1304</FONT><A NAME="1304"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1305</FONT><A NAME="1305"></A>   * Returns the tip text for this property.
<FONT ID="LN">1306</FONT><A NAME="1306"></A>   *
<FONT ID="LN">1307</FONT><A NAME="1307"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1308</FONT><A NAME="1308"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1309</FONT><A NAME="1309"></A>   */</FONT>
<FONT ID="LN">1310</FONT><A NAME="1310"></A>  <FONT ID="Public">public</FONT> String tokenizerTipText() {
<FONT ID="LN">1311</FONT><A NAME="1311"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The tokenizing algorithm to use on the strings."</FONT>;
<FONT ID="LN">1312</FONT><A NAME="1312"></A>  }
<FONT ID="LN">1313</FONT><A NAME="1313"></A>
<FONT ID="LN">1314</FONT><A NAME="1314"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1315</FONT><A NAME="1315"></A>   * sorts an array.
<FONT ID="LN">1316</FONT><A NAME="1316"></A>   * 
<FONT ID="LN">1317</FONT><A NAME="1317"></A>   * @param array the array to sort
<FONT ID="LN">1318</FONT><A NAME="1318"></A>   */</FONT>
<FONT ID="LN">1319</FONT><A NAME="1319"></A>  <FONT ID="Private">private</FONT> <FONT ID="Static">static</FONT> <FONT ID="Void">void</FONT> sortArray(<FONT ID="Int">int</FONT> [] array) {
<FONT ID="LN">1320</FONT><A NAME="1320"></A>
<FONT ID="LN">1321</FONT><A NAME="1321"></A>    <FONT ID="Int">int</FONT> i, j, h, N = array.length - <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">1322</FONT><A NAME="1322"></A>
<FONT ID="LN">1323</FONT><A NAME="1323"></A>    <FONT ID="For">for</FONT> (h = <FONT ID="IntegerLiteral">1</FONT>; h &lt;= N / <FONT ID="IntegerLiteral">9</FONT>; h = <FONT ID="IntegerLiteral">3</FONT> * h + <FONT ID="IntegerLiteral">1</FONT>); 
<FONT ID="LN">1324</FONT><A NAME="1324"></A>
<FONT ID="LN">1325</FONT><A NAME="1325"></A>    <FONT ID="For">for</FONT> (; h &gt; <FONT ID="IntegerLiteral">0</FONT>; h /= <FONT ID="IntegerLiteral">3</FONT>) {
<FONT ID="LN">1326</FONT><A NAME="1326"></A>      <FONT ID="For">for</FONT> (i = h + <FONT ID="IntegerLiteral">1</FONT>; i &lt;= N; i++) { 
<FONT ID="LN">1327</FONT><A NAME="1327"></A>    <FONT ID="Int">int</FONT> v = array[i]; 
<FONT ID="LN">1328</FONT><A NAME="1328"></A>    j = i; 
<FONT ID="LN">1329</FONT><A NAME="1329"></A>    <FONT ID="While">while</FONT> (j &gt; h &amp;&amp; array[j - h] &gt; v ) { 
<FONT ID="LN">1330</FONT><A NAME="1330"></A>      array[j] = array[j - h]; 
<FONT ID="LN">1331</FONT><A NAME="1331"></A>      j -= h; 
<FONT ID="LN">1332</FONT><A NAME="1332"></A>    } 
<FONT ID="LN">1333</FONT><A NAME="1333"></A>    array[j] = v; 
<FONT ID="LN">1334</FONT><A NAME="1334"></A>      } 
<FONT ID="LN">1335</FONT><A NAME="1335"></A>    }
<FONT ID="LN">1336</FONT><A NAME="1336"></A>  }
<FONT ID="LN">1337</FONT><A NAME="1337"></A>
<FONT ID="LN">1338</FONT><A NAME="1338"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1339</FONT><A NAME="1339"></A>   * determines the selected range.
<FONT ID="LN">1340</FONT><A NAME="1340"></A>   */</FONT>
<FONT ID="LN">1341</FONT><A NAME="1341"></A>  <FONT ID="Private">private</FONT> <FONT ID="Void">void</FONT> determineSelectedRange() {
<FONT ID="LN">1342</FONT><A NAME="1342"></A>
<FONT ID="LN">1343</FONT><A NAME="1343"></A>    <A HREF="../../../../weka/core/Instances.java.html">Instances</A> inputFormat = getInputFormat();
<FONT ID="LN">1344</FONT><A NAME="1344"></A>
<FONT ID="LN">1345</FONT><A NAME="1345"></A>    <FONT ID="SingleLineComment">// Calculate the default set of fields to convert
<FONT ID="LN">1346</FONT><A NAME="1346"></A></FONT>    <FONT ID="If">if</FONT> (m_SelectedRange == <FONT ID="Null">null</FONT>) {
<FONT ID="LN">1347</FONT><A NAME="1347"></A>      StringBuffer fields = <FONT ID="New">new</FONT> StringBuffer();
<FONT ID="LN">1348</FONT><A NAME="1348"></A>      <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> j = <FONT ID="IntegerLiteral">0</FONT>; j &lt; inputFormat.numAttributes(); j++) { 
<FONT ID="LN">1349</FONT><A NAME="1349"></A>    <FONT ID="If">if</FONT> (inputFormat.attribute(j).type() == Attribute.STRING)
<FONT ID="LN">1350</FONT><A NAME="1350"></A>      fields.append((j + <FONT ID="IntegerLiteral">1</FONT>) + <FONT ID="StringLiteral">","</FONT>);
<FONT ID="LN">1351</FONT><A NAME="1351"></A>      }
<FONT ID="LN">1352</FONT><A NAME="1352"></A>      m_SelectedRange = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Range.java.html">Range</A>(fields.toString());
<FONT ID="LN">1353</FONT><A NAME="1353"></A>    }
<FONT ID="LN">1354</FONT><A NAME="1354"></A>    m_SelectedRange.setUpper(inputFormat.numAttributes() - <FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">1355</FONT><A NAME="1355"></A>
<FONT ID="LN">1356</FONT><A NAME="1356"></A>    <FONT ID="SingleLineComment">// Prevent the user from converting non-string fields
<FONT ID="LN">1357</FONT><A NAME="1357"></A></FONT>    StringBuffer fields = <FONT ID="New">new</FONT> StringBuffer();
<FONT ID="LN">1358</FONT><A NAME="1358"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> j = <FONT ID="IntegerLiteral">0</FONT>; j &lt; inputFormat.numAttributes(); j++) { 
<FONT ID="LN">1359</FONT><A NAME="1359"></A>      <FONT ID="If">if</FONT> (m_SelectedRange.isInRange(j) 
<FONT ID="LN">1360</FONT><A NAME="1360"></A>      &amp;&amp; inputFormat.attribute(j).type() == Attribute.STRING)
<FONT ID="LN">1361</FONT><A NAME="1361"></A>    fields.append((j + <FONT ID="IntegerLiteral">1</FONT>) + <FONT ID="StringLiteral">","</FONT>);
<FONT ID="LN">1362</FONT><A NAME="1362"></A>    }
<FONT ID="LN">1363</FONT><A NAME="1363"></A>    m_SelectedRange.setRanges(fields.toString());
<FONT ID="LN">1364</FONT><A NAME="1364"></A>    m_SelectedRange.setUpper(inputFormat.numAttributes() - <FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">1365</FONT><A NAME="1365"></A>
<FONT ID="LN">1366</FONT><A NAME="1366"></A>    <FONT ID="SingleLineComment">// System.err.println("Selected Range: " + getSelectedRange().getRanges()); 
<FONT ID="LN">1367</FONT><A NAME="1367"></A></FONT>  }
<FONT ID="LN">1368</FONT><A NAME="1368"></A>
<FONT ID="LN">1369</FONT><A NAME="1369"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1370</FONT><A NAME="1370"></A>   * determines the dictionary.
<FONT ID="LN">1371</FONT><A NAME="1371"></A>   */</FONT>
<FONT ID="LN">1372</FONT><A NAME="1372"></A>  <FONT ID="Private">private</FONT> <FONT ID="Void">void</FONT> determineDictionary() {
<FONT ID="LN">1373</FONT><A NAME="1373"></A>    <FONT ID="SingleLineComment">// initialize stopwords
<FONT ID="LN">1374</FONT><A NAME="1374"></A></FONT>    <A HREF="../../../../weka/core/Stopwords.java.html">Stopwords</A> stopwords = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Stopwords.java.html">Stopwords</A>();
<FONT ID="LN">1375</FONT><A NAME="1375"></A>    <FONT ID="If">if</FONT> (getUseStoplist()) {
<FONT ID="LN">1376</FONT><A NAME="1376"></A>      <FONT ID="Try">try</FONT> {
<FONT ID="LN">1377</FONT><A NAME="1377"></A>    <FONT ID="If">if</FONT> (getStopwords().exists() &amp;&amp; !getStopwords().isDirectory())
<FONT ID="LN">1378</FONT><A NAME="1378"></A>      stopwords.read(getStopwords());
<FONT ID="LN">1379</FONT><A NAME="1379"></A>      }
<FONT ID="LN">1380</FONT><A NAME="1380"></A>      <FONT ID="Catch">catch</FONT> (Exception e) {
<FONT ID="LN">1381</FONT><A NAME="1381"></A>    e.printStackTrace();
<FONT ID="LN">1382</FONT><A NAME="1382"></A>      }
<FONT ID="LN">1383</FONT><A NAME="1383"></A>    }
<FONT ID="LN">1384</FONT><A NAME="1384"></A>
<FONT ID="LN">1385</FONT><A NAME="1385"></A>    <FONT ID="SingleLineComment">// Operate on a per-class basis if class attribute is set
<FONT ID="LN">1386</FONT><A NAME="1386"></A></FONT>    <FONT ID="Int">int</FONT> classInd = getInputFormat().classIndex();
<FONT ID="LN">1387</FONT><A NAME="1387"></A>    <FONT ID="Int">int</FONT> values = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">1388</FONT><A NAME="1388"></A>    <FONT ID="If">if</FONT> (!m_doNotOperateOnPerClassBasis &amp;&amp; (classInd != -<FONT ID="IntegerLiteral">1</FONT>)) {
<FONT ID="LN">1389</FONT><A NAME="1389"></A>      values = getInputFormat().attribute(classInd).numValues();
<FONT ID="LN">1390</FONT><A NAME="1390"></A>    }
<FONT ID="LN">1391</FONT><A NAME="1391"></A>
<FONT ID="LN">1392</FONT><A NAME="1392"></A>    <FONT ID="SingleLineComment">//TreeMap dictionaryArr [] = new TreeMap[values];
<FONT ID="LN">1393</FONT><A NAME="1393"></A></FONT>    TreeMap [] dictionaryArr = <FONT ID="New">new</FONT> TreeMap[values];
<FONT ID="LN">1394</FONT><A NAME="1394"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> i = <FONT ID="IntegerLiteral">0</FONT>; i &lt; values; i++) {
<FONT ID="LN">1395</FONT><A NAME="1395"></A>      dictionaryArr[i] = <FONT ID="New">new</FONT> TreeMap();
<FONT ID="LN">1396</FONT><A NAME="1396"></A>    }
<FONT ID="LN">1397</FONT><A NAME="1397"></A>
<FONT ID="LN">1398</FONT><A NAME="1398"></A>    <FONT ID="SingleLineComment">// Make sure we know which fields to convert
<FONT ID="LN">1399</FONT><A NAME="1399"></A></FONT>    determineSelectedRange();
<FONT ID="LN">1400</FONT><A NAME="1400"></A>
<FONT ID="LN">1401</FONT><A NAME="1401"></A>    <FONT ID="SingleLineComment">// Tokenize all training text into an orderedMap of "words".
<FONT ID="LN">1402</FONT><A NAME="1402"></A></FONT>    <FONT ID="Long">long</FONT> pruneRate = 
<FONT ID="LN">1403</FONT><A NAME="1403"></A>      Math.round((m_PeriodicPruningRate/<FONT ID="FloatPointLiteral">100.0</FONT>)*getInputFormat().numInstances());
<FONT ID="LN">1404</FONT><A NAME="1404"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> i = <FONT ID="IntegerLiteral">0</FONT>; i &lt; getInputFormat().numInstances(); i++) {
<FONT ID="LN">1405</FONT><A NAME="1405"></A>      <A HREF="../../../../weka/core/Instance.java.html">Instance</A> instance = getInputFormat().instance(i);
<FONT ID="LN">1406</FONT><A NAME="1406"></A>      <FONT ID="Int">int</FONT> vInd = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1407</FONT><A NAME="1407"></A>      <FONT ID="If">if</FONT> (!m_doNotOperateOnPerClassBasis &amp;&amp; (classInd != -<FONT ID="IntegerLiteral">1</FONT>)) {
<FONT ID="LN">1408</FONT><A NAME="1408"></A>    vInd = (<FONT ID="Int">int</FONT>)instance.classValue();
<FONT ID="LN">1409</FONT><A NAME="1409"></A>      }
<FONT ID="LN">1410</FONT><A NAME="1410"></A>
<FONT ID="LN">1411</FONT><A NAME="1411"></A>      <FONT ID="SingleLineComment">// Iterate through all relevant string attributes of the current instance
<FONT ID="LN">1412</FONT><A NAME="1412"></A></FONT>      Hashtable h = <FONT ID="New">new</FONT> Hashtable();
<FONT ID="LN">1413</FONT><A NAME="1413"></A>      <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> j = <FONT ID="IntegerLiteral">0</FONT>; j &lt; instance.numAttributes(); j++) { 
<FONT ID="LN">1414</FONT><A NAME="1414"></A>    <FONT ID="If">if</FONT> (m_SelectedRange.isInRange(j) &amp;&amp; (instance.isMissing(j) == <FONT ID="False">false</FONT>)) {
<FONT ID="LN">1415</FONT><A NAME="1415"></A>
<FONT ID="LN">1416</FONT><A NAME="1416"></A>      <FONT ID="SingleLineComment">// Get tokenizer
<FONT ID="LN">1417</FONT><A NAME="1417"></A></FONT>      m_Tokenizer.tokenize(instance.stringValue(j));
<FONT ID="LN">1418</FONT><A NAME="1418"></A>
<FONT ID="LN">1419</FONT><A NAME="1419"></A>      <FONT ID="SingleLineComment">// Iterate through tokens, perform stemming, and remove stopwords
<FONT ID="LN">1420</FONT><A NAME="1420"></A></FONT>      <FONT ID="SingleLineComment">// (if required)
<FONT ID="LN">1421</FONT><A NAME="1421"></A></FONT>      <FONT ID="While">while</FONT> (m_Tokenizer.hasMoreElements()) {
<FONT ID="LN">1422</FONT><A NAME="1422"></A>        String word = ((String)m_Tokenizer.nextElement()).intern();
<FONT ID="LN">1423</FONT><A NAME="1423"></A>
<FONT ID="LN">1424</FONT><A NAME="1424"></A>        <FONT ID="If">if</FONT>(<FONT ID="This">this</FONT>.m_lowerCaseTokens==<FONT ID="True">true</FONT>)
<FONT ID="LN">1425</FONT><A NAME="1425"></A>          word = word.toLowerCase();
<FONT ID="LN">1426</FONT><A NAME="1426"></A>
<FONT ID="LN">1427</FONT><A NAME="1427"></A>        word = m_Stemmer.stem(word);
<FONT ID="LN">1428</FONT><A NAME="1428"></A>
<FONT ID="LN">1429</FONT><A NAME="1429"></A>        <FONT ID="If">if</FONT>(<FONT ID="This">this</FONT>.m_useStoplist==<FONT ID="True">true</FONT>)
<FONT ID="LN">1430</FONT><A NAME="1430"></A>          <FONT ID="If">if</FONT>(stopwords.is(word))
<FONT ID="LN">1431</FONT><A NAME="1431"></A>        <FONT ID="Continue">continue</FONT>;
<FONT ID="LN">1432</FONT><A NAME="1432"></A>
<FONT ID="LN">1433</FONT><A NAME="1433"></A>        <FONT ID="If">if</FONT>(!(h.contains(word)))
<FONT ID="LN">1434</FONT><A NAME="1434"></A>          h.put(word, <FONT ID="New">new</FONT> Integer(<FONT ID="IntegerLiteral">0</FONT>));
<FONT ID="LN">1435</FONT><A NAME="1435"></A>
<FONT ID="LN">1436</FONT><A NAME="1436"></A>        Count count = (Count)dictionaryArr[vInd].get(word);
<FONT ID="LN">1437</FONT><A NAME="1437"></A>        <FONT ID="If">if</FONT> (count == <FONT ID="Null">null</FONT>) {
<FONT ID="LN">1438</FONT><A NAME="1438"></A>          dictionaryArr[vInd].put(word, <FONT ID="New">new</FONT> Count(<FONT ID="IntegerLiteral">1</FONT>));
<FONT ID="LN">1439</FONT><A NAME="1439"></A>        } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1440</FONT><A NAME="1440"></A>          count.count++;                
<FONT ID="LN">1441</FONT><A NAME="1441"></A>        }
<FONT ID="LN">1442</FONT><A NAME="1442"></A>      }          
<FONT ID="LN">1443</FONT><A NAME="1443"></A>    }
<FONT ID="LN">1444</FONT><A NAME="1444"></A>      }
<FONT ID="LN">1445</FONT><A NAME="1445"></A>
<FONT ID="LN">1446</FONT><A NAME="1446"></A>      <FONT ID="SingleLineComment">//updating the docCount for the words that have occurred in this
<FONT ID="LN">1447</FONT><A NAME="1447"></A></FONT>      <FONT ID="SingleLineComment">//instance(document).
<FONT ID="LN">1448</FONT><A NAME="1448"></A></FONT>      Enumeration e = h.keys();
<FONT ID="LN">1449</FONT><A NAME="1449"></A>      <FONT ID="While">while</FONT>(e.hasMoreElements()) {
<FONT ID="LN">1450</FONT><A NAME="1450"></A>    String word = (String) e.nextElement();
<FONT ID="LN">1451</FONT><A NAME="1451"></A>    Count c = (Count)dictionaryArr[vInd].get(word);
<FONT ID="LN">1452</FONT><A NAME="1452"></A>    <FONT ID="If">if</FONT>(c!=<FONT ID="Null">null</FONT>) {
<FONT ID="LN">1453</FONT><A NAME="1453"></A>      c.docCount++;
<FONT ID="LN">1454</FONT><A NAME="1454"></A>    } <FONT ID="Else">else</FONT> 
<FONT ID="LN">1455</FONT><A NAME="1455"></A>      System.err.println(<FONT ID="StringLiteral">"Warning: A word should definitely be in the "</FONT>+
<FONT ID="LN">1456</FONT><A NAME="1456"></A>          <FONT ID="StringLiteral">"dictionary.Please check the code"</FONT>);
<FONT ID="LN">1457</FONT><A NAME="1457"></A>      }
<FONT ID="LN">1458</FONT><A NAME="1458"></A>
<FONT ID="LN">1459</FONT><A NAME="1459"></A>
<FONT ID="LN">1460</FONT><A NAME="1460"></A>      <FONT ID="If">if</FONT> (pruneRate &gt; <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">1461</FONT><A NAME="1461"></A>    <FONT ID="If">if</FONT> (i % pruneRate == <FONT ID="IntegerLiteral">0</FONT> &amp;&amp; i &gt; <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">1462</FONT><A NAME="1462"></A>      <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> z = <FONT ID="IntegerLiteral">0</FONT>; z &lt; values; z++) {
<FONT ID="LN">1463</FONT><A NAME="1463"></A>        <A HREF="../../../../weka/core/FastVector.java.html">Vector</A> d = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">Vector</A>(<FONT ID="IntegerLiteral">1000</FONT>);
<FONT ID="LN">1464</FONT><A NAME="1464"></A>        Iterator it = dictionaryArr[z].keySet().iterator();
<FONT ID="LN">1465</FONT><A NAME="1465"></A>        <FONT ID="While">while</FONT> (it.hasNext()) {
<FONT ID="LN">1466</FONT><A NAME="1466"></A>          String word = (String)it.next();
<FONT ID="LN">1467</FONT><A NAME="1467"></A>          Count count = (Count)dictionaryArr[z].get(word);
<FONT ID="LN">1468</FONT><A NAME="1468"></A>          <FONT ID="If">if</FONT> (count.count &lt;= <FONT ID="IntegerLiteral">1</FONT>) { d.add(word); }
<FONT ID="LN">1469</FONT><A NAME="1469"></A>        }
<FONT ID="LN">1470</FONT><A NAME="1470"></A>        Iterator iter = d.iterator();
<FONT ID="LN">1471</FONT><A NAME="1471"></A>        <FONT ID="While">while</FONT>(iter.hasNext()) {
<FONT ID="LN">1472</FONT><A NAME="1472"></A>          String word = (String)iter.next();
<FONT ID="LN">1473</FONT><A NAME="1473"></A>          dictionaryArr[z].remove(word);
<FONT ID="LN">1474</FONT><A NAME="1474"></A>        }
<FONT ID="LN">1475</FONT><A NAME="1475"></A>      }
<FONT ID="LN">1476</FONT><A NAME="1476"></A>    }
<FONT ID="LN">1477</FONT><A NAME="1477"></A>      }
<FONT ID="LN">1478</FONT><A NAME="1478"></A>    }
<FONT ID="LN">1479</FONT><A NAME="1479"></A>
<FONT ID="LN">1480</FONT><A NAME="1480"></A>    <FONT ID="SingleLineComment">// Figure out the minimum required word frequency
<FONT ID="LN">1481</FONT><A NAME="1481"></A></FONT>    <FONT ID="Int">int</FONT> totalsize = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1482</FONT><A NAME="1482"></A>    <FONT ID="Int">int</FONT> prune[] = <FONT ID="New">new</FONT> <FONT ID="Int">int</FONT>[values];
<FONT ID="LN">1483</FONT><A NAME="1483"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> z = <FONT ID="IntegerLiteral">0</FONT>; z &lt; values; z++) {
<FONT ID="LN">1484</FONT><A NAME="1484"></A>      totalsize += dictionaryArr[z].size();
<FONT ID="LN">1485</FONT><A NAME="1485"></A>
<FONT ID="LN">1486</FONT><A NAME="1486"></A>      <FONT ID="Int">int</FONT> array[] = <FONT ID="New">new</FONT> <FONT ID="Int">int</FONT>[dictionaryArr[z].size()];
<FONT ID="LN">1487</FONT><A NAME="1487"></A>      <FONT ID="Int">int</FONT> pos = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1488</FONT><A NAME="1488"></A>      Iterator it = dictionaryArr[z].keySet().iterator();
<FONT ID="LN">1489</FONT><A NAME="1489"></A>      <FONT ID="While">while</FONT> (it.hasNext()) {
<FONT ID="LN">1490</FONT><A NAME="1490"></A>    String word = (String)it.next();
<FONT ID="LN">1491</FONT><A NAME="1491"></A>    Count count = (Count)dictionaryArr[z].get(word);
<FONT ID="LN">1492</FONT><A NAME="1492"></A>    array[pos] = count.count;
<FONT ID="LN">1493</FONT><A NAME="1493"></A>    pos++;
<FONT ID="LN">1494</FONT><A NAME="1494"></A>      }
<FONT ID="LN">1495</FONT><A NAME="1495"></A>
<FONT ID="LN">1496</FONT><A NAME="1496"></A>      <FONT ID="SingleLineComment">// sort the array
<FONT ID="LN">1497</FONT><A NAME="1497"></A></FONT>      sortArray(array);
<FONT ID="LN">1498</FONT><A NAME="1498"></A>      <FONT ID="If">if</FONT> (array.length &lt; m_WordsToKeep) {
<FONT ID="LN">1499</FONT><A NAME="1499"></A>    <FONT ID="SingleLineComment">// if there aren't enough words, set the threshold to
<FONT ID="LN">1500</FONT><A NAME="1500"></A></FONT>    <FONT ID="SingleLineComment">// minFreq
<FONT ID="LN">1501</FONT><A NAME="1501"></A></FONT>    prune[z] = m_minTermFreq;
<FONT ID="LN">1502</FONT><A NAME="1502"></A>      } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1503</FONT><A NAME="1503"></A>    <FONT ID="SingleLineComment">// otherwise set it to be at least minFreq
<FONT ID="LN">1504</FONT><A NAME="1504"></A></FONT>    prune[z] = Math.max(m_minTermFreq, 
<FONT ID="LN">1505</FONT><A NAME="1505"></A>        array[array.length - m_WordsToKeep]);
<FONT ID="LN">1506</FONT><A NAME="1506"></A>      }
<FONT ID="LN">1507</FONT><A NAME="1507"></A>    }
<FONT ID="LN">1508</FONT><A NAME="1508"></A>
<FONT ID="LN">1509</FONT><A NAME="1509"></A>    <FONT ID="SingleLineComment">// Convert the dictionary into an attribute index
<FONT ID="LN">1510</FONT><A NAME="1510"></A></FONT>    <FONT ID="SingleLineComment">// and create one attribute per word
<FONT ID="LN">1511</FONT><A NAME="1511"></A></FONT>    <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A> attributes = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A>(totalsize +
<FONT ID="LN">1512</FONT><A NAME="1512"></A>    getInputFormat().numAttributes());
<FONT ID="LN">1513</FONT><A NAME="1513"></A>
<FONT ID="LN">1514</FONT><A NAME="1514"></A>    <FONT ID="SingleLineComment">// Add the non-converted attributes 
<FONT ID="LN">1515</FONT><A NAME="1515"></A></FONT>    <FONT ID="Int">int</FONT> classIndex = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">1516</FONT><A NAME="1516"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> i = <FONT ID="IntegerLiteral">0</FONT>; i &lt; getInputFormat().numAttributes(); i++) {
<FONT ID="LN">1517</FONT><A NAME="1517"></A>      <FONT ID="If">if</FONT> (!m_SelectedRange.isInRange(i)) { 
<FONT ID="LN">1518</FONT><A NAME="1518"></A>    <FONT ID="If">if</FONT> (getInputFormat().classIndex() == i) {
<FONT ID="LN">1519</FONT><A NAME="1519"></A>      classIndex = attributes.size();
<FONT ID="LN">1520</FONT><A NAME="1520"></A>    }
<FONT ID="LN">1521</FONT><A NAME="1521"></A>    attributes.addElement(getInputFormat().attribute(i).copy());
<FONT ID="LN">1522</FONT><A NAME="1522"></A>      }     
<FONT ID="LN">1523</FONT><A NAME="1523"></A>    }
<FONT ID="LN">1524</FONT><A NAME="1524"></A>
<FONT ID="LN">1525</FONT><A NAME="1525"></A>    <FONT ID="SingleLineComment">// Add the word vector attributes (eliminating duplicates
<FONT ID="LN">1526</FONT><A NAME="1526"></A></FONT>    <FONT ID="SingleLineComment">// that occur in multiple classes)
<FONT ID="LN">1527</FONT><A NAME="1527"></A></FONT>    TreeMap newDictionary = <FONT ID="New">new</FONT> TreeMap();
<FONT ID="LN">1528</FONT><A NAME="1528"></A>    <FONT ID="Int">int</FONT> index = attributes.size();
<FONT ID="LN">1529</FONT><A NAME="1529"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> z = <FONT ID="IntegerLiteral">0</FONT>; z &lt; values; z++) {
<FONT ID="LN">1530</FONT><A NAME="1530"></A>      Iterator it = dictionaryArr[z].keySet().iterator();
<FONT ID="LN">1531</FONT><A NAME="1531"></A>      <FONT ID="While">while</FONT> (it.hasNext()) {
<FONT ID="LN">1532</FONT><A NAME="1532"></A>    String word = (String)it.next();
<FONT ID="LN">1533</FONT><A NAME="1533"></A>    Count count = (Count)dictionaryArr[z].get(word);
<FONT ID="LN">1534</FONT><A NAME="1534"></A>    <FONT ID="If">if</FONT> (count.count &gt;= prune[z]) {
<FONT ID="LN">1535</FONT><A NAME="1535"></A>      <FONT ID="If">if</FONT>(newDictionary.get(word) == <FONT ID="Null">null</FONT>) {
<FONT ID="LN">1536</FONT><A NAME="1536"></A>        newDictionary.put(word, <FONT ID="New">new</FONT> Integer(index++));
<FONT ID="LN">1537</FONT><A NAME="1537"></A>        attributes.addElement(<FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Attribute.java.html">Attribute</A>(m_Prefix + word));
<FONT ID="LN">1538</FONT><A NAME="1538"></A>      }
<FONT ID="LN">1539</FONT><A NAME="1539"></A>    }
<FONT ID="LN">1540</FONT><A NAME="1540"></A>      }
<FONT ID="LN">1541</FONT><A NAME="1541"></A>    }
<FONT ID="LN">1542</FONT><A NAME="1542"></A>
<FONT ID="LN">1543</FONT><A NAME="1543"></A>    <FONT ID="SingleLineComment">// Compute document frequencies
<FONT ID="LN">1544</FONT><A NAME="1544"></A></FONT>    m_DocsCounts = <FONT ID="New">new</FONT> <FONT ID="Int">int</FONT>[attributes.size()];
<FONT ID="LN">1545</FONT><A NAME="1545"></A>    Iterator it = newDictionary.keySet().iterator();
<FONT ID="LN">1546</FONT><A NAME="1546"></A>    <FONT ID="While">while</FONT>(it.hasNext()) {
<FONT ID="LN">1547</FONT><A NAME="1547"></A>      String word = (String) it.next();
<FONT ID="LN">1548</FONT><A NAME="1548"></A>      <FONT ID="Int">int</FONT> idx = ((Integer)newDictionary.get(word)).intValue();
<FONT ID="LN">1549</FONT><A NAME="1549"></A>      <FONT ID="Int">int</FONT> docsCount=<FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1550</FONT><A NAME="1550"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;values; j++) {
<FONT ID="LN">1551</FONT><A NAME="1551"></A>    Count c = (Count) dictionaryArr[j].get(word);
<FONT ID="LN">1552</FONT><A NAME="1552"></A>    <FONT ID="If">if</FONT>(c!=<FONT ID="Null">null</FONT>)
<FONT ID="LN">1553</FONT><A NAME="1553"></A>      docsCount += c.docCount;
<FONT ID="LN">1554</FONT><A NAME="1554"></A>      }
<FONT ID="LN">1555</FONT><A NAME="1555"></A>      m_DocsCounts[idx]=docsCount;
<FONT ID="LN">1556</FONT><A NAME="1556"></A>    }
<FONT ID="LN">1557</FONT><A NAME="1557"></A>
<FONT ID="LN">1558</FONT><A NAME="1558"></A>    <FONT ID="SingleLineComment">// Trim vector and set instance variables
<FONT ID="LN">1559</FONT><A NAME="1559"></A></FONT>    attributes.trimToSize();
<FONT ID="LN">1560</FONT><A NAME="1560"></A>    m_Dictionary = newDictionary;
<FONT ID="LN">1561</FONT><A NAME="1561"></A>    m_NumInstances = getInputFormat().numInstances();
<FONT ID="LN">1562</FONT><A NAME="1562"></A>
<FONT ID="LN">1563</FONT><A NAME="1563"></A>    <FONT ID="SingleLineComment">// Set the filter's output format
<FONT ID="LN">1564</FONT><A NAME="1564"></A></FONT>    <A HREF="../../../../weka/core/Instances.java.html">Instances</A> outputFormat = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/Instances.java.html">Instances</A>(getInputFormat().relationName(), 
<FONT ID="LN">1565</FONT><A NAME="1565"></A>    attributes, <FONT ID="IntegerLiteral">0</FONT>);
<FONT ID="LN">1566</FONT><A NAME="1566"></A>    outputFormat.setClassIndex(classIndex);
<FONT ID="LN">1567</FONT><A NAME="1567"></A>    setOutputFormat(outputFormat);
<FONT ID="LN">1568</FONT><A NAME="1568"></A>  }
<FONT ID="LN">1569</FONT><A NAME="1569"></A>
<FONT ID="LN">1570</FONT><A NAME="1570"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1571</FONT><A NAME="1571"></A>   * Converts the instance w/o normalization.
<FONT ID="LN">1572</FONT><A NAME="1572"></A>   * 
<FONT ID="LN">1573</FONT><A NAME="1573"></A>   * @oaram instance the instance to convert
<FONT ID="LN">1574</FONT><A NAME="1574"></A>   * @param v
<FONT ID="LN">1575</FONT><A NAME="1575"></A>   * @return the conerted instance
<FONT ID="LN">1576</FONT><A NAME="1576"></A>   */</FONT>
<FONT ID="LN">1577</FONT><A NAME="1577"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> convertInstancewoDocNorm(<A HREF="../../../../weka/core/Instance.java.html">Instance</A> instance, <A HREF="../../../../weka/core/FastVector.java.html">FastVector</A> v) {
<FONT ID="LN">1578</FONT><A NAME="1578"></A>
<FONT ID="LN">1579</FONT><A NAME="1579"></A>    <FONT ID="SingleLineComment">// Convert the instance into a sorted set of indexes
<FONT ID="LN">1580</FONT><A NAME="1580"></A></FONT>    TreeMap contained = <FONT ID="New">new</FONT> TreeMap();
<FONT ID="LN">1581</FONT><A NAME="1581"></A>
<FONT ID="LN">1582</FONT><A NAME="1582"></A>    <FONT ID="SingleLineComment">// Copy all non-converted attributes from input to output
<FONT ID="LN">1583</FONT><A NAME="1583"></A></FONT>    <FONT ID="Int">int</FONT> firstCopy = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1584</FONT><A NAME="1584"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> i = <FONT ID="IntegerLiteral">0</FONT>; i &lt; getInputFormat().numAttributes(); i++) {
<FONT ID="LN">1585</FONT><A NAME="1585"></A>      <FONT ID="If">if</FONT> (!m_SelectedRange.isInRange(i)) { 
<FONT ID="LN">1586</FONT><A NAME="1586"></A>    <FONT ID="If">if</FONT> (getInputFormat().attribute(i).type() != Attribute.STRING) {
<FONT ID="LN">1587</FONT><A NAME="1587"></A>      <FONT ID="SingleLineComment">// Add simple nominal and numeric attributes directly
<FONT ID="LN">1588</FONT><A NAME="1588"></A></FONT>      <FONT ID="If">if</FONT> (instance.value(i) != <FONT ID="FloatPointLiteral">0.0</FONT>) {
<FONT ID="LN">1589</FONT><A NAME="1589"></A>        contained.put(<FONT ID="New">new</FONT> Integer(firstCopy), 
<FONT ID="LN">1590</FONT><A NAME="1590"></A>        <FONT ID="New">new</FONT> Double(instance.value(i)));
<FONT ID="LN">1591</FONT><A NAME="1591"></A>      } 
<FONT ID="LN">1592</FONT><A NAME="1592"></A>    } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1593</FONT><A NAME="1593"></A>      <FONT ID="If">if</FONT> (instance.isMissing(i)) {
<FONT ID="LN">1594</FONT><A NAME="1594"></A>        contained.put(<FONT ID="New">new</FONT> Integer(firstCopy),
<FONT ID="LN">1595</FONT><A NAME="1595"></A>        <FONT ID="New">new</FONT> Double(Utils.missingValue()));
<FONT ID="LN">1596</FONT><A NAME="1596"></A>      } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1597</FONT><A NAME="1597"></A>
<FONT ID="LN">1598</FONT><A NAME="1598"></A>        <FONT ID="SingleLineComment">// If this is a string attribute, we have to first add
<FONT ID="LN">1599</FONT><A NAME="1599"></A></FONT>        <FONT ID="SingleLineComment">// this value to the range of possible values, then add
<FONT ID="LN">1600</FONT><A NAME="1600"></A></FONT>        <FONT ID="SingleLineComment">// its new internal index.
<FONT ID="LN">1601</FONT><A NAME="1601"></A></FONT>        <FONT ID="If">if</FONT> (outputFormatPeek().attribute(firstCopy).numValues() == <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">1602</FONT><A NAME="1602"></A>          <FONT ID="SingleLineComment">// Note that the first string value in a
<FONT ID="LN">1603</FONT><A NAME="1603"></A></FONT>          <FONT ID="SingleLineComment">// SparseInstance doesn't get printed.
<FONT ID="LN">1604</FONT><A NAME="1604"></A></FONT>          outputFormatPeek().attribute(firstCopy)
<FONT ID="LN">1605</FONT><A NAME="1605"></A>          .addStringValue(<FONT ID="StringLiteral">"Hack to defeat SparseInstance bug"</FONT>);
<FONT ID="LN">1606</FONT><A NAME="1606"></A>        }
<FONT ID="LN">1607</FONT><A NAME="1607"></A>        <FONT ID="Int">int</FONT> newIndex = outputFormatPeek().attribute(firstCopy)
<FONT ID="LN">1608</FONT><A NAME="1608"></A>        .addStringValue(instance.stringValue(i));
<FONT ID="LN">1609</FONT><A NAME="1609"></A>        contained.put(<FONT ID="New">new</FONT> Integer(firstCopy), 
<FONT ID="LN">1610</FONT><A NAME="1610"></A>        <FONT ID="New">new</FONT> Double(newIndex));
<FONT ID="LN">1611</FONT><A NAME="1611"></A>      }
<FONT ID="LN">1612</FONT><A NAME="1612"></A>    }
<FONT ID="LN">1613</FONT><A NAME="1613"></A>    firstCopy++;
<FONT ID="LN">1614</FONT><A NAME="1614"></A>      }     
<FONT ID="LN">1615</FONT><A NAME="1615"></A>    }
<FONT ID="LN">1616</FONT><A NAME="1616"></A>
<FONT ID="LN">1617</FONT><A NAME="1617"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> j = <FONT ID="IntegerLiteral">0</FONT>; j &lt; instance.numAttributes(); j++) { 
<FONT ID="LN">1618</FONT><A NAME="1618"></A>      <FONT ID="SingleLineComment">//if ((getInputFormat().attribute(j).type() == Attribute.STRING) 
<FONT ID="LN">1619</FONT><A NAME="1619"></A></FONT>      <FONT ID="If">if</FONT> (m_SelectedRange.isInRange(j)
<FONT ID="LN">1620</FONT><A NAME="1620"></A>      &amp;&amp; (instance.isMissing(j) == <FONT ID="False">false</FONT>)) {          
<FONT ID="LN">1621</FONT><A NAME="1621"></A>
<FONT ID="LN">1622</FONT><A NAME="1622"></A>    m_Tokenizer.tokenize(instance.stringValue(j));
<FONT ID="LN">1623</FONT><A NAME="1623"></A>
<FONT ID="LN">1624</FONT><A NAME="1624"></A>    <FONT ID="While">while</FONT> (m_Tokenizer.hasMoreElements()) {
<FONT ID="LN">1625</FONT><A NAME="1625"></A>      String word = (String)m_Tokenizer.nextElement(); 
<FONT ID="LN">1626</FONT><A NAME="1626"></A>      <FONT ID="If">if</FONT>(<FONT ID="This">this</FONT>.m_lowerCaseTokens==<FONT ID="True">true</FONT>)
<FONT ID="LN">1627</FONT><A NAME="1627"></A>        word = word.toLowerCase();
<FONT ID="LN">1628</FONT><A NAME="1628"></A>      word = m_Stemmer.stem(word);
<FONT ID="LN">1629</FONT><A NAME="1629"></A>      Integer index = (Integer) m_Dictionary.get(word);
<FONT ID="LN">1630</FONT><A NAME="1630"></A>      <FONT ID="If">if</FONT> (index != <FONT ID="Null">null</FONT>) {
<FONT ID="LN">1631</FONT><A NAME="1631"></A>        <FONT ID="If">if</FONT> (m_OutputCounts) { <FONT ID="SingleLineComment">// Separate if here rather than two lines down to avoid hashtable lookup
<FONT ID="LN">1632</FONT><A NAME="1632"></A></FONT>          Double count = (Double)contained.get(index);
<FONT ID="LN">1633</FONT><A NAME="1633"></A>        <FONT ID="If">if</FONT> (count != <FONT ID="Null">null</FONT>) {
<FONT ID="LN">1634</FONT><A NAME="1634"></A>          contained.put(index, <FONT ID="New">new</FONT> Double(count.doubleValue() + <FONT ID="FloatPointLiteral">1.0</FONT>));
<FONT ID="LN">1635</FONT><A NAME="1635"></A>        } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1636</FONT><A NAME="1636"></A>          contained.put(index, <FONT ID="New">new</FONT> Double(<FONT ID="IntegerLiteral">1</FONT>));
<FONT ID="LN">1637</FONT><A NAME="1637"></A>        }
<FONT ID="LN">1638</FONT><A NAME="1638"></A>        } <FONT ID="Else">else</FONT> {
<FONT ID="LN">1639</FONT><A NAME="1639"></A>          contained.put(index, <FONT ID="New">new</FONT> Double(<FONT ID="IntegerLiteral">1</FONT>));
<FONT ID="LN">1640</FONT><A NAME="1640"></A>        }                
<FONT ID="LN">1641</FONT><A NAME="1641"></A>      }
<FONT ID="LN">1642</FONT><A NAME="1642"></A>    }
<FONT ID="LN">1643</FONT><A NAME="1643"></A>      }
<FONT ID="LN">1644</FONT><A NAME="1644"></A>    }
<FONT ID="LN">1645</FONT><A NAME="1645"></A>
<FONT ID="LN">1646</FONT><A NAME="1646"></A>    <FONT ID="SingleLineComment">//Doing TFTransform
<FONT ID="LN">1647</FONT><A NAME="1647"></A></FONT>    <FONT ID="If">if</FONT>(m_TFTransform==<FONT ID="True">true</FONT>) {
<FONT ID="LN">1648</FONT><A NAME="1648"></A>      Iterator it = contained.keySet().iterator();
<FONT ID="LN">1649</FONT><A NAME="1649"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; it.hasNext(); i++) {
<FONT ID="LN">1650</FONT><A NAME="1650"></A>    Integer index = (Integer)it.next();
<FONT ID="LN">1651</FONT><A NAME="1651"></A>    <FONT ID="If">if</FONT>( index.intValue() &gt;= firstCopy ) { 
<FONT ID="LN">1652</FONT><A NAME="1652"></A>      <FONT ID="Double">double</FONT> val = ((Double)contained.get(index)).doubleValue();
<FONT ID="LN">1653</FONT><A NAME="1653"></A>      val = Math.log(val+<FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">1654</FONT><A NAME="1654"></A>      contained.put(index, <FONT ID="New">new</FONT> Double(val));
<FONT ID="LN">1655</FONT><A NAME="1655"></A>    }
<FONT ID="LN">1656</FONT><A NAME="1656"></A>      }
<FONT ID="LN">1657</FONT><A NAME="1657"></A>    }
<FONT ID="LN">1658</FONT><A NAME="1658"></A>
<FONT ID="LN">1659</FONT><A NAME="1659"></A>    <FONT ID="SingleLineComment">//Doing IDFTransform
<FONT ID="LN">1660</FONT><A NAME="1660"></A></FONT>    <FONT ID="If">if</FONT>(m_IDFTransform==<FONT ID="True">true</FONT>) {
<FONT ID="LN">1661</FONT><A NAME="1661"></A>      Iterator it = contained.keySet().iterator();
<FONT ID="LN">1662</FONT><A NAME="1662"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; it.hasNext(); i++) {
<FONT ID="LN">1663</FONT><A NAME="1663"></A>    Integer index = (Integer)it.next();
<FONT ID="LN">1664</FONT><A NAME="1664"></A>    <FONT ID="If">if</FONT>( index.intValue() &gt;= firstCopy ) {
<FONT ID="LN">1665</FONT><A NAME="1665"></A>      <FONT ID="Double">double</FONT> val = ((Double)contained.get(index)).doubleValue();
<FONT ID="LN">1666</FONT><A NAME="1666"></A>      val = val*Math.log( m_NumInstances /
<FONT ID="LN">1667</FONT><A NAME="1667"></A>          (<FONT ID="Double">double</FONT>) m_DocsCounts[index.intValue()] );
<FONT ID="LN">1668</FONT><A NAME="1668"></A>      contained.put(index, <FONT ID="New">new</FONT> Double(val));
<FONT ID="LN">1669</FONT><A NAME="1669"></A>    }
<FONT ID="LN">1670</FONT><A NAME="1670"></A>      }        
<FONT ID="LN">1671</FONT><A NAME="1671"></A>    }
<FONT ID="LN">1672</FONT><A NAME="1672"></A>
<FONT ID="LN">1673</FONT><A NAME="1673"></A>    <FONT ID="SingleLineComment">// Convert the set to structures needed to create a sparse instance.
<FONT ID="LN">1674</FONT><A NAME="1674"></A></FONT>    <FONT ID="Double">double</FONT> [] values = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT> [contained.size()];
<FONT ID="LN">1675</FONT><A NAME="1675"></A>    <FONT ID="Int">int</FONT> [] indices = <FONT ID="New">new</FONT> <FONT ID="Int">int</FONT> [contained.size()];
<FONT ID="LN">1676</FONT><A NAME="1676"></A>    Iterator it = contained.keySet().iterator();
<FONT ID="LN">1677</FONT><A NAME="1677"></A>    <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> i = <FONT ID="IntegerLiteral">0</FONT>; it.hasNext(); i++) {
<FONT ID="LN">1678</FONT><A NAME="1678"></A>      Integer index = (Integer)it.next();
<FONT ID="LN">1679</FONT><A NAME="1679"></A>      Double value = (Double)contained.get(index);
<FONT ID="LN">1680</FONT><A NAME="1680"></A>      values[i] = value.doubleValue();
<FONT ID="LN">1681</FONT><A NAME="1681"></A>      indices[i] = index.intValue();
<FONT ID="LN">1682</FONT><A NAME="1682"></A>    }
<FONT ID="LN">1683</FONT><A NAME="1683"></A>
<FONT ID="LN">1684</FONT><A NAME="1684"></A>    <A HREF="../../../../weka/core/Instance.java.html">Instance</A> inst = <FONT ID="New">new</FONT> <A HREF="../../../../weka/core/SparseInstance.java.html">SparseInstance</A>(instance.weight(), values, indices, 
<FONT ID="LN">1685</FONT><A NAME="1685"></A>    outputFormatPeek().numAttributes());
<FONT ID="LN">1686</FONT><A NAME="1686"></A>    inst.setDataset(outputFormatPeek());
<FONT ID="LN">1687</FONT><A NAME="1687"></A>
<FONT ID="LN">1688</FONT><A NAME="1688"></A>    v.addElement(inst);
<FONT ID="LN">1689</FONT><A NAME="1689"></A>
<FONT ID="LN">1690</FONT><A NAME="1690"></A>    <FONT ID="Return">return</FONT> firstCopy;    
<FONT ID="LN">1691</FONT><A NAME="1691"></A>  }
<FONT ID="LN">1692</FONT><A NAME="1692"></A>
<FONT ID="LN">1693</FONT><A NAME="1693"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1694</FONT><A NAME="1694"></A>   * Normalizes given instance to average doc length (only the newly
<FONT ID="LN">1695</FONT><A NAME="1695"></A>   * constructed attributes).
<FONT ID="LN">1696</FONT><A NAME="1696"></A>   * 
<FONT ID="LN">1697</FONT><A NAME="1697"></A>   * @param inst    the instance to normalize
<FONT ID="LN">1698</FONT><A NAME="1698"></A>   * @param firstCopy
<FONT ID="LN">1699</FONT><A NAME="1699"></A>   * @throws Exception if avg. doc length not set
<FONT ID="LN">1700</FONT><A NAME="1700"></A>   */</FONT>
<FONT ID="LN">1701</FONT><A NAME="1701"></A>  <FONT ID="Private">private</FONT> <FONT ID="Void">void</FONT> normalizeInstance(<A HREF="../../../../weka/core/Instance.java.html">Instance</A> inst, <FONT ID="Int">int</FONT> firstCopy) 
<FONT ID="LN">1702</FONT><A NAME="1702"></A>  <FONT ID="Throws">throws</FONT> Exception {
<FONT ID="LN">1703</FONT><A NAME="1703"></A>
<FONT ID="LN">1704</FONT><A NAME="1704"></A>    <FONT ID="Double">double</FONT> docLength = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1705</FONT><A NAME="1705"></A>
<FONT ID="LN">1706</FONT><A NAME="1706"></A>    <FONT ID="If">if</FONT> (m_AvgDocLength &lt; <FONT ID="IntegerLiteral">0</FONT>) {
<FONT ID="LN">1707</FONT><A NAME="1707"></A>      <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> Exception(<FONT ID="StringLiteral">"Average document length not set."</FONT>);
<FONT ID="LN">1708</FONT><A NAME="1708"></A>    }
<FONT ID="LN">1709</FONT><A NAME="1709"></A>
<FONT ID="LN">1710</FONT><A NAME="1710"></A>    <FONT ID="SingleLineComment">// Compute length of document vector
<FONT ID="LN">1711</FONT><A NAME="1711"></A></FONT>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;inst.numValues(); j++) {
<FONT ID="LN">1712</FONT><A NAME="1712"></A>      <FONT ID="If">if</FONT>(inst.index(j)&gt;=firstCopy) {
<FONT ID="LN">1713</FONT><A NAME="1713"></A>    docLength += inst.valueSparse(j) * inst.valueSparse(j);
<FONT ID="LN">1714</FONT><A NAME="1714"></A>      }
<FONT ID="LN">1715</FONT><A NAME="1715"></A>    }        
<FONT ID="LN">1716</FONT><A NAME="1716"></A>    docLength = Math.sqrt(docLength);
<FONT ID="LN">1717</FONT><A NAME="1717"></A>
<FONT ID="LN">1718</FONT><A NAME="1718"></A>    <FONT ID="SingleLineComment">// Normalize document vector
<FONT ID="LN">1719</FONT><A NAME="1719"></A></FONT>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;inst.numValues(); j++) {
<FONT ID="LN">1720</FONT><A NAME="1720"></A>      <FONT ID="If">if</FONT>(inst.index(j)&gt;=firstCopy) {
<FONT ID="LN">1721</FONT><A NAME="1721"></A>    <FONT ID="Double">double</FONT> val = inst.valueSparse(j) * m_AvgDocLength / docLength;
<FONT ID="LN">1722</FONT><A NAME="1722"></A>    inst.setValueSparse(j, val);
<FONT ID="LN">1723</FONT><A NAME="1723"></A>    <FONT ID="If">if</FONT> (val == <FONT ID="IntegerLiteral">0</FONT>){
<FONT ID="LN">1724</FONT><A NAME="1724"></A>      System.err.println(<FONT ID="StringLiteral">"setting value "</FONT>+inst.index(j)+<FONT ID="StringLiteral">" to zero."</FONT>);
<FONT ID="LN">1725</FONT><A NAME="1725"></A>      j--;
<FONT ID="LN">1726</FONT><A NAME="1726"></A>    }
<FONT ID="LN">1727</FONT><A NAME="1727"></A>      }
<FONT ID="LN">1728</FONT><A NAME="1728"></A>    }        
<FONT ID="LN">1729</FONT><A NAME="1729"></A>  }
<FONT ID="LN">1730</FONT><A NAME="1730"></A>  
<FONT ID="LN">1731</FONT><A NAME="1731"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1732</FONT><A NAME="1732"></A>   * Returns the revision string.
<FONT ID="LN">1733</FONT><A NAME="1733"></A>   * 
<FONT ID="LN">1734</FONT><A NAME="1734"></A>   * @return        the revision
<FONT ID="LN">1735</FONT><A NAME="1735"></A>   */</FONT>
<FONT ID="LN">1736</FONT><A NAME="1736"></A>  <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">1737</FONT><A NAME="1737"></A>    <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5987 $"</FONT>);
<FONT ID="LN">1738</FONT><A NAME="1738"></A>  }
<FONT ID="LN">1739</FONT><A NAME="1739"></A>
<FONT ID="LN">1740</FONT><A NAME="1740"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1741</FONT><A NAME="1741"></A>   * Main method for testing this class.
<FONT ID="LN">1742</FONT><A NAME="1742"></A>   *
<FONT ID="LN">1743</FONT><A NAME="1743"></A>   * @param argv should contain arguments to the filter: 
<FONT ID="LN">1744</FONT><A NAME="1744"></A>   * use -h for help
<FONT ID="LN">1745</FONT><A NAME="1745"></A>   */</FONT>
<FONT ID="LN">1746</FONT><A NAME="1746"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Void">void</FONT> main(String [] argv) {
<FONT ID="LN">1747</FONT><A NAME="1747"></A>    runFilter(<FONT ID="New">new</FONT> <A HREF="../../../../weka/filters/unsupervised/attribute/StringToWordVector.java.html">StringToWordVector</A>(), argv);
<FONT ID="LN">1748</FONT><A NAME="1748"></A>  }
<FONT ID="LN">1749</FONT><A NAME="1749"></A>}
<FONT ID="LN">1750</FONT><A NAME="1750"></A>
<FONT ID="LN">1751</FONT><A NAME="1751"></A></pre><TABLE id="Header" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td colspan="2" width="33%">&nbsp;</td>
<td align="center" colspan="2" width="33%">
<font size="4">StringToWordVector.java</font>
</td>
<td align="right" colspan="2" width="33%">&nbsp;</td>
</tr>
</TABLE>

</BODY>
</HTML>