<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
<META NAME="GENERATOR" CONTENT="Java2HTML Version 1.5">
<TITLE>weka.classifiers.rules.Ridor (Java2HTML)</TITLE>
</HEAD>
<BODY><TABLE id="Header" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td colspan="2" width="33%">&nbsp;</td>
<td align="center" colspan="2" width="33%">
<font size="4">Ridor.java</font>
</td>
<td align="right" colspan="2" width="33%">&nbsp;</td>
</tr>
</TABLE>
<pre ID="Classes">
<FONT ID="LN">1   </FONT><A NAME="1"></A><FONT ID="MultiLineComment">/*
<FONT ID="LN">2   </FONT><A NAME="2"></A> *    This program is free software; you can redistribute it and/or modify
<FONT ID="LN">3   </FONT><A NAME="3"></A> *    it under the terms of the GNU General Public License as published by
<FONT ID="LN">4   </FONT><A NAME="4"></A> *    the Free Software Foundation; either version 2 of the License, or
<FONT ID="LN">5   </FONT><A NAME="5"></A> *    (at your option) any later version.
<FONT ID="LN">6   </FONT><A NAME="6"></A> *
<FONT ID="LN">7   </FONT><A NAME="7"></A> *    This program is distributed in the hope that it will be useful,
<FONT ID="LN">8   </FONT><A NAME="8"></A> *    but WITHOUT ANY WARRANTY; without even the implied warranty of
<FONT ID="LN">9   </FONT><A NAME="9"></A> *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<FONT ID="LN">10  </FONT><A NAME="10"></A> *    GNU General Public License for more details.
<FONT ID="LN">11  </FONT><A NAME="11"></A> *
<FONT ID="LN">12  </FONT><A NAME="12"></A> *    You should have received a copy of the GNU General Public License
<FONT ID="LN">13  </FONT><A NAME="13"></A> *    along with this program; if not, write to the Free Software
<FONT ID="LN">14  </FONT><A NAME="14"></A> *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<FONT ID="LN">15  </FONT><A NAME="15"></A> */</FONT>
<FONT ID="LN">16  </FONT><A NAME="16"></A>
<FONT ID="LN">17  </FONT><A NAME="17"></A><FONT ID="MultiLineComment">/*
<FONT ID="LN">18  </FONT><A NAME="18"></A> *    Ridor.java
<FONT ID="LN">19  </FONT><A NAME="19"></A> *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
<FONT ID="LN">20  </FONT><A NAME="20"></A> *
<FONT ID="LN">21  </FONT><A NAME="21"></A> */</FONT>
<FONT ID="LN">22  </FONT><A NAME="22"></A>
<FONT ID="LN">23  </FONT><A NAME="23"></A><FONT ID="Package">package</FONT> weka.classifiers.rules;
<FONT ID="LN">24  </FONT><A NAME="24"></A>
<FONT ID="LN">25  </FONT><A NAME="25"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/classifiers/Classifier.java.html">weka.classifiers.Classifier</A>;
<FONT ID="LN">26  </FONT><A NAME="26"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/classifiers/AbstractClassifier.java.html">weka.classifiers.AbstractClassifier</A>;
<FONT ID="LN">27  </FONT><A NAME="27"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/AdditionalMeasureProducer.java.html">weka.core.AdditionalMeasureProducer</A>;
<FONT ID="LN">28  </FONT><A NAME="28"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Attribute.java.html">weka.core.Attribute</A>;
<FONT ID="LN">29  </FONT><A NAME="29"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Capabilities.java.html">weka.core.Capabilities</A>;
<FONT ID="LN">30  </FONT><A NAME="30"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/FastVector.java.html">weka.core.FastVector</A>;
<FONT ID="LN">31  </FONT><A NAME="31"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Instance.java.html">weka.core.Instance</A>;
<FONT ID="LN">32  </FONT><A NAME="32"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Instances.java.html">weka.core.Instances</A>;
<FONT ID="LN">33  </FONT><A NAME="33"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Option.java.html">weka.core.Option</A>;
<FONT ID="LN">34  </FONT><A NAME="34"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/RevisionHandler.java.html">weka.core.RevisionHandler</A>;
<FONT ID="LN">35  </FONT><A NAME="35"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/RevisionUtils.java.html">weka.core.RevisionUtils</A>;
<FONT ID="LN">36  </FONT><A NAME="36"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">weka.core.UnsupportedClassTypeException</A>;
<FONT ID="LN">37  </FONT><A NAME="37"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Utils.java.html">weka.core.Utils</A>;
<FONT ID="LN">38  </FONT><A NAME="38"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/WeightedInstancesHandler.java.html">weka.core.WeightedInstancesHandler</A>;
<FONT ID="LN">39  </FONT><A NAME="39"></A><FONT ID="Import">import</FONT> <A HREF="../../../weka/core/Capabilities.java.html">weka.core.Capabilities.Capability</A>;
<FONT ID="LN">40  </FONT><A NAME="40"></A>
<FONT ID="LN">41  </FONT><A NAME="41"></A><FONT ID="Import">import</FONT> java.io.Serializable;
<FONT ID="LN">42  </FONT><A NAME="42"></A><FONT ID="Import">import</FONT> java.util.Enumeration;
<FONT ID="LN">43  </FONT><A NAME="43"></A><FONT ID="Import">import</FONT> java.util.Random;
<FONT ID="LN">44  </FONT><A NAME="44"></A><FONT ID="Import">import</FONT> java.util.Vector;
<FONT ID="LN">45  </FONT><A NAME="45"></A>
<FONT ID="LN">46  </FONT><A NAME="46"></A><FONT ID="FormalComment">/**
<FONT ID="LN">47  </FONT><A NAME="47"></A> &lt;!-- globalinfo-start --&gt;
<FONT ID="LN">48  </FONT><A NAME="48"></A> * An implementation of a RIpple-DOwn Rule learner.&lt;br/&gt;
<FONT ID="LN">49  </FONT><A NAME="49"></A> * &lt;br/&gt;
<FONT ID="LN">50  </FONT><A NAME="50"></A> * It generates a default rule first and then the exceptions for the default rule with the least (weighted) error rate.  Then it generates the "best" exceptions for each exception and iterates until pure.  Thus it performs a tree-like expansion of exceptions.The exceptions are a set of rules that predict classes other than the default. IREP is used to generate the exceptions.&lt;br/&gt;
<FONT ID="LN">51  </FONT><A NAME="51"></A> * &lt;br/&gt;
<FONT ID="LN">52  </FONT><A NAME="52"></A> * For more information about Ripple-Down Rules, see:&lt;br/&gt;
<FONT ID="LN">53  </FONT><A NAME="53"></A> * &lt;br/&gt;
<FONT ID="LN">54  </FONT><A NAME="54"></A> * Brian R. Gaines, Paul Compton (1995). Induction of Ripple-Down Rules Applied to Modeling Large Databases. J. Intell. Inf. Syst.. 5(3):211-228.
<FONT ID="LN">55  </FONT><A NAME="55"></A> * &lt;p/&gt;
<FONT ID="LN">56  </FONT><A NAME="56"></A> &lt;!-- globalinfo-end --&gt;
<FONT ID="LN">57  </FONT><A NAME="57"></A> * 
<FONT ID="LN">58  </FONT><A NAME="58"></A> * There are five inner classes defined in this class. &lt;br&gt;
<FONT ID="LN">59  </FONT><A NAME="59"></A> * The first is Ridor_node, which implements one node in the Ridor tree.  It's basically
<FONT ID="LN">60  </FONT><A NAME="60"></A> * composed of a default class and a set of exception rules to the default class.&lt;br&gt;
<FONT ID="LN">61  </FONT><A NAME="61"></A> * The second inner class is RidorRule, which implements a single exception rule 
<FONT ID="LN">62  </FONT><A NAME="62"></A> * using REP.&lt;br&gt;
<FONT ID="LN">63  </FONT><A NAME="63"></A> * The last three inner classes are only used in RidorRule.  They are Antd, NumericAntd 
<FONT ID="LN">64  </FONT><A NAME="64"></A> * and NominalAntd, which all implement a single antecedent in the RidorRule. &lt;br&gt;
<FONT ID="LN">65  </FONT><A NAME="65"></A> * The Antd class is an abstract class, which has two subclasses, NumericAntd and 
<FONT ID="LN">66  </FONT><A NAME="66"></A> * NominalAntd, to implement the corresponding abstract functions.  These two subclasses
<FONT ID="LN">67  </FONT><A NAME="67"></A> * implement the functions related to a antecedent with a nominal attribute and a numeric 
<FONT ID="LN">68  </FONT><A NAME="68"></A> * attribute respectively.&lt;p&gt;
<FONT ID="LN">69  </FONT><A NAME="69"></A> * 
<FONT ID="LN">70  </FONT><A NAME="70"></A> &lt;!-- options-start --&gt;
<FONT ID="LN">71  </FONT><A NAME="71"></A> * Valid options are: &lt;p/&gt;
<FONT ID="LN">72  </FONT><A NAME="72"></A> * 
<FONT ID="LN">73  </FONT><A NAME="73"></A> * &lt;pre&gt; -F &amp;lt;number of folds&amp;gt;
<FONT ID="LN">74  </FONT><A NAME="74"></A> *  Set number of folds for IREP
<FONT ID="LN">75  </FONT><A NAME="75"></A> *  One fold is used as pruning set.
<FONT ID="LN">76  </FONT><A NAME="76"></A> *  (default 3)&lt;/pre&gt;
<FONT ID="LN">77  </FONT><A NAME="77"></A> * 
<FONT ID="LN">78  </FONT><A NAME="78"></A> * &lt;pre&gt; -S &amp;lt;number of shuffles&amp;gt;
<FONT ID="LN">79  </FONT><A NAME="79"></A> *  Set number of shuffles to randomize
<FONT ID="LN">80  </FONT><A NAME="80"></A> *  the data in order to get better rule.
<FONT ID="LN">81  </FONT><A NAME="81"></A> *  (default 10)&lt;/pre&gt;
<FONT ID="LN">82  </FONT><A NAME="82"></A> * 
<FONT ID="LN">83  </FONT><A NAME="83"></A> * &lt;pre&gt; -A
<FONT ID="LN">84  </FONT><A NAME="84"></A> *  Set flag of whether use the error rate 
<FONT ID="LN">85  </FONT><A NAME="85"></A> *  of all the data to select the default class
<FONT ID="LN">86  </FONT><A NAME="86"></A> *  in each step. If not set, the learner will only use the error rate in the pruning data&lt;/pre&gt;
<FONT ID="LN">87  </FONT><A NAME="87"></A> * 
<FONT ID="LN">88  </FONT><A NAME="88"></A> * &lt;pre&gt; -M
<FONT ID="LN">89  </FONT><A NAME="89"></A> *   Set flag of whether use the majority class as
<FONT ID="LN">90  </FONT><A NAME="90"></A> *  the default class in each step instead of 
<FONT ID="LN">91  </FONT><A NAME="91"></A> *  choosing default class based on the error rate
<FONT ID="LN">92  </FONT><A NAME="92"></A> *  (if the flag is not set)&lt;/pre&gt;
<FONT ID="LN">93  </FONT><A NAME="93"></A> * 
<FONT ID="LN">94  </FONT><A NAME="94"></A> * &lt;pre&gt; -N &amp;lt;min. weights&amp;gt;
<FONT ID="LN">95  </FONT><A NAME="95"></A> *  Set the minimal weights of instances
<FONT ID="LN">96  </FONT><A NAME="96"></A> *  within a split.
<FONT ID="LN">97  </FONT><A NAME="97"></A> *  (default 2.0)&lt;/pre&gt;
<FONT ID="LN">98  </FONT><A NAME="98"></A> * 
<FONT ID="LN">99  </FONT><A NAME="99"></A> &lt;!-- options-end --&gt;
<FONT ID="LN">100 </FONT><A NAME="100"></A> *
<FONT ID="LN">101 </FONT><A NAME="101"></A> * @author Xin XU (xx5@cs.waikato.ac.nz)
<FONT ID="LN">102 </FONT><A NAME="102"></A> * @version $Revision: 5928 $ 
<FONT ID="LN">103 </FONT><A NAME="103"></A> */</FONT>
<FONT ID="LN">104 </FONT><A NAME="104"></A><FONT ID="Public">public</FONT> <FONT ID="Class">class</FONT> Ridor 
<FONT ID="LN">105 </FONT><A NAME="105"></A>  <FONT ID="Extends">extends</FONT> <A HREF="../../../weka/classifiers/AbstractClassifier.java.html">AbstractClassifier</A>
<FONT ID="LN">106 </FONT><A NAME="106"></A>  <FONT ID="Implements">implements</FONT> <A HREF="../../../weka/core/AdditionalMeasureProducer.java.html">AdditionalMeasureProducer</A>, <A HREF="../../../weka/core/WeightedInstancesHandler.java.html">WeightedInstancesHandler</A> {
<FONT ID="LN">107 </FONT><A NAME="107"></A>
<FONT ID="LN">108 </FONT><A NAME="108"></A>  <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">109 </FONT><A NAME="109"></A>  <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = -<FONT ID="IntegerLiteral">7261533075088314436L</FONT>;
<FONT ID="LN">110 </FONT><A NAME="110"></A>  
<FONT ID="LN">111 </FONT><A NAME="111"></A>  <FONT ID="FormalComment">/** The number of folds to split data into Grow and Prune for IREP */</FONT>
<FONT ID="LN">112 </FONT><A NAME="112"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_Folds = <FONT ID="IntegerLiteral">3</FONT>;
<FONT ID="LN">113 </FONT><A NAME="113"></A>    
<FONT ID="LN">114 </FONT><A NAME="114"></A>  <FONT ID="FormalComment">/** The number of shuffles performed on the data for randomization */</FONT>
<FONT ID="LN">115 </FONT><A NAME="115"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_Shuffle = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">116 </FONT><A NAME="116"></A>
<FONT ID="LN">117 </FONT><A NAME="117"></A>  <FONT ID="FormalComment">/** Random object for randomization */</FONT>
<FONT ID="LN">118 </FONT><A NAME="118"></A>  <FONT ID="Private">private</FONT> Random m_Random = <FONT ID="Null">null</FONT>;
<FONT ID="LN">119 </FONT><A NAME="119"></A>    
<FONT ID="LN">120 </FONT><A NAME="120"></A>  <FONT ID="FormalComment">/** The seed to perform randomization */</FONT>
<FONT ID="LN">121 </FONT><A NAME="121"></A>  <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> m_Seed = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">122 </FONT><A NAME="122"></A>
<FONT ID="LN">123 </FONT><A NAME="123"></A>  <FONT ID="FormalComment">/** Whether use error rate on all the data */</FONT>
<FONT ID="LN">124 </FONT><A NAME="124"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_IsAllErr = <FONT ID="False">false</FONT>;
<FONT ID="LN">125 </FONT><A NAME="125"></A>
<FONT ID="LN">126 </FONT><A NAME="126"></A>  <FONT ID="FormalComment">/** Whether use majority class as default class */</FONT>
<FONT ID="LN">127 </FONT><A NAME="127"></A>  <FONT ID="Private">private</FONT> <FONT ID="Boolean">boolean</FONT> m_IsMajority = <FONT ID="False">false</FONT>;
<FONT ID="LN">128 </FONT><A NAME="128"></A>    
<FONT ID="LN">129 </FONT><A NAME="129"></A>  <FONT ID="FormalComment">/** The root of Ridor */</FONT>
<FONT ID="LN">130 </FONT><A NAME="130"></A>  <FONT ID="Private">private</FONT> Ridor_node m_Root = <FONT ID="Null">null</FONT>;
<FONT ID="LN">131 </FONT><A NAME="131"></A>    
<FONT ID="LN">132 </FONT><A NAME="132"></A>  <FONT ID="FormalComment">/** The class attribute of the data */</FONT>
<FONT ID="LN">133 </FONT><A NAME="133"></A>  <FONT ID="Private">private</FONT> <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> m_Class;
<FONT ID="LN">134 </FONT><A NAME="134"></A>
<FONT ID="LN">135 </FONT><A NAME="135"></A>  <FONT ID="FormalComment">/** Statistics of the data */</FONT>
<FONT ID="LN">136 </FONT><A NAME="136"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_Cover, m_Err;
<FONT ID="LN">137 </FONT><A NAME="137"></A>
<FONT ID="LN">138 </FONT><A NAME="138"></A>  <FONT ID="FormalComment">/** The minimal number of instance weights within a split*/</FONT>
<FONT ID="LN">139 </FONT><A NAME="139"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_MinNo = <FONT ID="FloatPointLiteral">2.0</FONT>;
<FONT ID="LN">140 </FONT><A NAME="140"></A>    
<FONT ID="LN">141 </FONT><A NAME="141"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">142 </FONT><A NAME="142"></A>   * Returns a string describing classifier
<FONT ID="LN">143 </FONT><A NAME="143"></A>   * @return a description suitable for
<FONT ID="LN">144 </FONT><A NAME="144"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">145 </FONT><A NAME="145"></A>   */</FONT>
<FONT ID="LN">146 </FONT><A NAME="146"></A>  <FONT ID="Public">public</FONT> String globalInfo() {
<FONT ID="LN">147 </FONT><A NAME="147"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"An implementation of a RIpple-DOwn Rule learner.\n\n"</FONT> 
<FONT ID="LN">148 </FONT><A NAME="148"></A>      + <FONT ID="StringLiteral">"It generates a default rule first and then the exceptions for the default rule "</FONT>
<FONT ID="LN">149 </FONT><A NAME="149"></A>      + <FONT ID="StringLiteral">"with the least (weighted) error rate.  Then it generates the \"best\" exceptions for "</FONT>
<FONT ID="LN">150 </FONT><A NAME="150"></A>      + <FONT ID="StringLiteral">"each exception and iterates until pure.  Thus it performs a tree-like expansion of "</FONT>
<FONT ID="LN">151 </FONT><A NAME="151"></A>      + <FONT ID="StringLiteral">"exceptions."</FONT>
<FONT ID="LN">152 </FONT><A NAME="152"></A>      + <FONT ID="StringLiteral">"The exceptions are a set of rules that predict classes other than the default. "</FONT>
<FONT ID="LN">153 </FONT><A NAME="153"></A>      + <FONT ID="StringLiteral">"IREP is used to generate the exceptions.\n\n"</FONT>
<FONT ID="LN">154 </FONT><A NAME="154"></A>      + <FONT ID="StringLiteral">"For more information about Ripple-Down Rules, see:\n\n"</FONT>;
<FONT ID="LN">155 </FONT><A NAME="155"></A>  }
<FONT ID="LN">156 </FONT><A NAME="156"></A>    
<FONT ID="LN">157 </FONT><A NAME="157"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">158 </FONT><A NAME="158"></A>   * Private class implementing the single node of Ridor. 
<FONT ID="LN">159 </FONT><A NAME="159"></A>   * It consists of a default class label, a set of exceptions to the default rule
<FONT ID="LN">160 </FONT><A NAME="160"></A>   * and the exceptions to each exception
<FONT ID="LN">161 </FONT><A NAME="161"></A>   */</FONT>
<FONT ID="LN">162 </FONT><A NAME="162"></A>  <FONT ID="Private">private</FONT> <FONT ID="Class">class</FONT> Ridor_node 
<FONT ID="LN">163 </FONT><A NAME="163"></A>    <FONT ID="Implements">implements</FONT> Serializable, <A HREF="../../../weka/core/RevisionHandler.java.html">RevisionHandler</A> {
<FONT ID="LN">164 </FONT><A NAME="164"></A>    
<FONT ID="LN">165 </FONT><A NAME="165"></A>    <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">166 </FONT><A NAME="166"></A>    <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = -<FONT ID="IntegerLiteral">581370560157467677L</FONT>;
<FONT ID="LN">167 </FONT><A NAME="167"></A>    
<FONT ID="LN">168 </FONT><A NAME="168"></A>    <FONT ID="FormalComment">/** The default class label */</FONT>
<FONT ID="LN">169 </FONT><A NAME="169"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> defClass = Double.NaN;
<FONT ID="LN">170 </FONT><A NAME="170"></A>    
<FONT ID="LN">171 </FONT><A NAME="171"></A>    <FONT ID="FormalComment">/** The set of exceptions of the default rule. 
<FONT ID="LN">172 </FONT><A NAME="172"></A>    Each element also has its own exceptions and the consequent of each rule 
<FONT ID="LN">173 </FONT><A NAME="173"></A>    is determined by its exceptions */</FONT>
<FONT ID="LN">174 </FONT><A NAME="174"></A>    <FONT ID="Private">private</FONT> RidorRule[] rules = <FONT ID="Null">null</FONT>;
<FONT ID="LN">175 </FONT><A NAME="175"></A>    
<FONT ID="LN">176 </FONT><A NAME="176"></A>    <FONT ID="FormalComment">/** The exceptions of the exception rules */</FONT>
<FONT ID="LN">177 </FONT><A NAME="177"></A>    <FONT ID="Private">private</FONT> Ridor_node[] excepts = <FONT ID="Null">null</FONT>; 
<FONT ID="LN">178 </FONT><A NAME="178"></A>
<FONT ID="LN">179 </FONT><A NAME="179"></A>    <FONT ID="FormalComment">/** The level of this node */</FONT>
<FONT ID="LN">180 </FONT><A NAME="180"></A>    <FONT ID="Private">private</FONT> <FONT ID="Int">int</FONT> level;
<FONT ID="LN">181 </FONT><A NAME="181"></A>
<FONT ID="LN">182 </FONT><A NAME="182"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">183 </FONT><A NAME="183"></A>     * Gets the default class label
<FONT ID="LN">184 </FONT><A NAME="184"></A>     *
<FONT ID="LN">185 </FONT><A NAME="185"></A>     * @return the default class label
<FONT ID="LN">186 </FONT><A NAME="186"></A>     */</FONT>
<FONT ID="LN">187 </FONT><A NAME="187"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getDefClass() { 
<FONT ID="LN">188 </FONT><A NAME="188"></A>      <FONT ID="Return">return</FONT> defClass; 
<FONT ID="LN">189 </FONT><A NAME="189"></A>    }
<FONT ID="LN">190 </FONT><A NAME="190"></A>    
<FONT ID="LN">191 </FONT><A NAME="191"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">192 </FONT><A NAME="192"></A>     * Gets the set of exceptions
<FONT ID="LN">193 </FONT><A NAME="193"></A>     * 
<FONT ID="LN">194 </FONT><A NAME="194"></A>     * @return the set of exceptions
<FONT ID="LN">195 </FONT><A NAME="195"></A>     */</FONT>
<FONT ID="LN">196 </FONT><A NAME="196"></A>    <FONT ID="Public">public</FONT> RidorRule[] getRules() { 
<FONT ID="LN">197 </FONT><A NAME="197"></A>      <FONT ID="Return">return</FONT> rules; 
<FONT ID="LN">198 </FONT><A NAME="198"></A>    }
<FONT ID="LN">199 </FONT><A NAME="199"></A>    
<FONT ID="LN">200 </FONT><A NAME="200"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">201 </FONT><A NAME="201"></A>     * Gets the exceptions of the exceptions rules
<FONT ID="LN">202 </FONT><A NAME="202"></A>     * 
<FONT ID="LN">203 </FONT><A NAME="203"></A>     * @return the exceptions of the exceptions rules
<FONT ID="LN">204 </FONT><A NAME="204"></A>     */</FONT>
<FONT ID="LN">205 </FONT><A NAME="205"></A>    <FONT ID="Public">public</FONT> Ridor_node[] getExcepts() { 
<FONT ID="LN">206 </FONT><A NAME="206"></A>      <FONT ID="Return">return</FONT> excepts; 
<FONT ID="LN">207 </FONT><A NAME="207"></A>    }
<FONT ID="LN">208 </FONT><A NAME="208"></A>
<FONT ID="LN">209 </FONT><A NAME="209"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">210 </FONT><A NAME="210"></A>     * Builds a ripple-down manner rule learner.
<FONT ID="LN">211 </FONT><A NAME="211"></A>     *
<FONT ID="LN">212 </FONT><A NAME="212"></A>     * @param dataByClass the divided data by their class label. The real class
<FONT ID="LN">213 </FONT><A NAME="213"></A>     * labels of the instances are all set to 0
<FONT ID="LN">214 </FONT><A NAME="214"></A>     * @param lvl the level of the parent node
<FONT ID="LN">215 </FONT><A NAME="215"></A>     * @throws Exception if ruleset of this node cannot be built
<FONT ID="LN">216 </FONT><A NAME="216"></A>     */</FONT>
<FONT ID="LN">217 </FONT><A NAME="217"></A>    <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> findRules(<A HREF="../../../weka/core/Instances.java.html">Instances</A>[] dataByClass, <FONT ID="Int">int</FONT> lvl) <FONT ID="Throws">throws</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A> {
<FONT ID="LN">218 </FONT><A NAME="218"></A>      <A HREF="../../../weka/core/FastVector.java.html">Vector</A> finalRules = <FONT ID="Null">null</FONT>;
<FONT ID="LN">219 </FONT><A NAME="219"></A>      <FONT ID="Int">int</FONT> clas = -<FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">220 </FONT><A NAME="220"></A>      <FONT ID="Double">double</FONT>[] isPure = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[dataByClass.length];
<FONT ID="LN">221 </FONT><A NAME="221"></A>      <FONT ID="Int">int</FONT> numMajority = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">222 </FONT><A NAME="222"></A>        
<FONT ID="LN">223 </FONT><A NAME="223"></A>      level = lvl + <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">224 </FONT><A NAME="224"></A>        
<FONT ID="LN">225 </FONT><A NAME="225"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> h=<FONT ID="IntegerLiteral">0</FONT>; h &lt; dataByClass.length; h++){
<FONT ID="LN">226 </FONT><A NAME="226"></A>    isPure[h] = dataByClass[h].sumOfWeights();
<FONT ID="LN">227 </FONT><A NAME="227"></A>    <FONT ID="If">if</FONT>(Utils.grOrEq(isPure[h], m_Folds))
<FONT ID="LN">228 </FONT><A NAME="228"></A>      numMajority++;  <FONT ID="SingleLineComment">// Count how many class labels have enough instances
<FONT ID="LN">229 </FONT><A NAME="229"></A></FONT>      }
<FONT ID="LN">230 </FONT><A NAME="230"></A>        
<FONT ID="LN">231 </FONT><A NAME="231"></A>      <FONT ID="If">if</FONT>(numMajority &lt;= <FONT ID="IntegerLiteral">1</FONT>){                    <FONT ID="SingleLineComment">// The data is pure or not enough
<FONT ID="LN">232 </FONT><A NAME="232"></A></FONT>    defClass = (<FONT ID="Double">double</FONT>)Utils.maxIndex(isPure);
<FONT ID="LN">233 </FONT><A NAME="233"></A>    <FONT ID="Return">return</FONT>;
<FONT ID="LN">234 </FONT><A NAME="234"></A>      }
<FONT ID="LN">235 </FONT><A NAME="235"></A>      <FONT ID="Double">double</FONT> total = Utils.sum(isPure);  
<FONT ID="LN">236 </FONT><A NAME="236"></A>        
<FONT ID="LN">237 </FONT><A NAME="237"></A>      <FONT ID="If">if</FONT>(m_IsMajority){
<FONT ID="LN">238 </FONT><A NAME="238"></A>    defClass = (<FONT ID="Double">double</FONT>)Utils.maxIndex(isPure);
<FONT ID="LN">239 </FONT><A NAME="239"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(dataByClass[(<FONT ID="Int">int</FONT>)defClass]);
<FONT ID="LN">240 </FONT><A NAME="240"></A>    <FONT ID="Int">int</FONT> index = data.classIndex();
<FONT ID="LN">241 </FONT><A NAME="241"></A>        
<FONT ID="LN">242 </FONT><A NAME="242"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;data.numInstances(); j++)
<FONT ID="LN">243 </FONT><A NAME="243"></A>      data.instance(j).setClassValue(<FONT ID="IntegerLiteral">1</FONT>);       <FONT ID="SingleLineComment">// Set one class as default
<FONT ID="LN">244 </FONT><A NAME="244"></A></FONT>        
<FONT ID="LN">245 </FONT><A NAME="245"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> k=<FONT ID="IntegerLiteral">0</FONT>; k &lt; dataByClass.length; k++)    <FONT ID="SingleLineComment">// Merge into one dataset
<FONT ID="LN">246 </FONT><A NAME="246"></A></FONT>      <FONT ID="If">if</FONT>(k != (<FONT ID="Int">int</FONT>)defClass){
<FONT ID="LN">247 </FONT><A NAME="247"></A>        <FONT ID="If">if</FONT>(data.numInstances() &gt;= dataByClass[k].numInstances())
<FONT ID="LN">248 </FONT><A NAME="248"></A>          data = append(data, dataByClass[k]);
<FONT ID="LN">249 </FONT><A NAME="249"></A>        <FONT ID="Else">else</FONT> data = append(dataByClass[k], data);
<FONT ID="LN">250 </FONT><A NAME="250"></A>      }
<FONT ID="LN">251 </FONT><A NAME="251"></A>        
<FONT ID="LN">252 </FONT><A NAME="252"></A>    data.setClassIndex(index);           <FONT ID="SingleLineComment">// Position new class label
<FONT ID="LN">253 </FONT><A NAME="253"></A></FONT>        
<FONT ID="LN">254 </FONT><A NAME="254"></A>    <FONT ID="Double">double</FONT> classCount = total - isPure[(<FONT ID="Int">int</FONT>)defClass];
<FONT ID="LN">255 </FONT><A NAME="255"></A>    finalRules = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">Vector</A>();
<FONT ID="LN">256 </FONT><A NAME="256"></A>    buildRuleset(data, classCount, finalRules);
<FONT ID="LN">257 </FONT><A NAME="257"></A>    <FONT ID="If">if</FONT>(finalRules.size() == <FONT ID="IntegerLiteral">0</FONT>)           <FONT ID="SingleLineComment">// No good rules built
<FONT ID="LN">258 </FONT><A NAME="258"></A></FONT>      <FONT ID="Return">return</FONT>;
<FONT ID="LN">259 </FONT><A NAME="259"></A>      }
<FONT ID="LN">260 </FONT><A NAME="260"></A>      <FONT ID="Else">else</FONT>{
<FONT ID="LN">261 </FONT><A NAME="261"></A>    <FONT ID="Double">double</FONT> maxAcRt = isPure[Utils.maxIndex(isPure)] / total;
<FONT ID="LN">262 </FONT><A NAME="262"></A>        
<FONT ID="LN">263 </FONT><A NAME="263"></A>    <FONT ID="SingleLineComment">// Find default class
<FONT ID="LN">264 </FONT><A NAME="264"></A></FONT>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; dataByClass.length; i++){
<FONT ID="LN">265 </FONT><A NAME="265"></A>      <FONT ID="If">if</FONT>(isPure[i] &gt;= m_Folds){
<FONT ID="LN">266 </FONT><A NAME="266"></A>        <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(dataByClass[i]);
<FONT ID="LN">267 </FONT><A NAME="267"></A>        <FONT ID="Int">int</FONT> index = data.classIndex();
<FONT ID="LN">268 </FONT><A NAME="268"></A>            
<FONT ID="LN">269 </FONT><A NAME="269"></A>        <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt;data.numInstances(); j++)
<FONT ID="LN">270 </FONT><A NAME="270"></A>          data.instance(j).setClassValue(<FONT ID="IntegerLiteral">1</FONT>);       <FONT ID="SingleLineComment">// Set one class as default
<FONT ID="LN">271 </FONT><A NAME="271"></A></FONT>            
<FONT ID="LN">272 </FONT><A NAME="272"></A>        <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> k=<FONT ID="IntegerLiteral">0</FONT>; k &lt; dataByClass.length; k++)    <FONT ID="SingleLineComment">// Merge into one dataset
<FONT ID="LN">273 </FONT><A NAME="273"></A></FONT>          <FONT ID="If">if</FONT>(k != i){
<FONT ID="LN">274 </FONT><A NAME="274"></A>        <FONT ID="If">if</FONT>(data.numInstances() &gt;= dataByClass[k].numInstances())
<FONT ID="LN">275 </FONT><A NAME="275"></A>          data = append(data, dataByClass[k]);
<FONT ID="LN">276 </FONT><A NAME="276"></A>        <FONT ID="Else">else</FONT> data = append(dataByClass[k], data);
<FONT ID="LN">277 </FONT><A NAME="277"></A>          }
<FONT ID="LN">278 </FONT><A NAME="278"></A>            
<FONT ID="LN">279 </FONT><A NAME="279"></A>        data.setClassIndex(index);           <FONT ID="SingleLineComment">// Position new class label 
<FONT ID="LN">280 </FONT><A NAME="280"></A></FONT>            
<FONT ID="LN">281 </FONT><A NAME="281"></A>        <FONT ID="MultiLineComment">/* Build a set of rules */</FONT>
<FONT ID="LN">282 </FONT><A NAME="282"></A>        <FONT ID="Double">double</FONT> classCount = data.sumOfWeights() - isPure[i];
<FONT ID="LN">283 </FONT><A NAME="283"></A>        <A HREF="../../../weka/core/FastVector.java.html">Vector</A> ruleset = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">Vector</A>();
<FONT ID="LN">284 </FONT><A NAME="284"></A>        <FONT ID="Double">double</FONT> wAcRt = buildRuleset(data, classCount, ruleset); 
<FONT ID="LN">285 </FONT><A NAME="285"></A>            
<FONT ID="LN">286 </FONT><A NAME="286"></A>        <FONT ID="If">if</FONT>(Utils.gr(wAcRt, maxAcRt)){
<FONT ID="LN">287 </FONT><A NAME="287"></A>          finalRules = ruleset;
<FONT ID="LN">288 </FONT><A NAME="288"></A>          maxAcRt = wAcRt;
<FONT ID="LN">289 </FONT><A NAME="289"></A>          clas = i;
<FONT ID="LN">290 </FONT><A NAME="290"></A>        }
<FONT ID="LN">291 </FONT><A NAME="291"></A>      }
<FONT ID="LN">292 </FONT><A NAME="292"></A>    }
<FONT ID="LN">293 </FONT><A NAME="293"></A>        
<FONT ID="LN">294 </FONT><A NAME="294"></A>    <FONT ID="If">if</FONT>(finalRules == <FONT ID="Null">null</FONT>){ <FONT ID="SingleLineComment">// No good rules found, set majority class as default
<FONT ID="LN">295 </FONT><A NAME="295"></A></FONT>      defClass = (<FONT ID="Double">double</FONT>)Utils.maxIndex(isPure);
<FONT ID="LN">296 </FONT><A NAME="296"></A>      <FONT ID="Return">return</FONT>;
<FONT ID="LN">297 </FONT><A NAME="297"></A>    }
<FONT ID="LN">298 </FONT><A NAME="298"></A>        
<FONT ID="LN">299 </FONT><A NAME="299"></A>    defClass = (<FONT ID="Double">double</FONT>)clas;
<FONT ID="LN">300 </FONT><A NAME="300"></A>      }
<FONT ID="LN">301 </FONT><A NAME="301"></A>            
<FONT ID="LN">302 </FONT><A NAME="302"></A>      <FONT ID="MultiLineComment">/* Store the exception rules and default class in this node */</FONT>
<FONT ID="LN">303 </FONT><A NAME="303"></A>      <FONT ID="Int">int</FONT> size = finalRules.size();
<FONT ID="LN">304 </FONT><A NAME="304"></A>      rules = <FONT ID="New">new</FONT> RidorRule[size];
<FONT ID="LN">305 </FONT><A NAME="305"></A>      excepts = <FONT ID="New">new</FONT> Ridor_node[size];
<FONT ID="LN">306 </FONT><A NAME="306"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> l=<FONT ID="IntegerLiteral">0</FONT>; l &lt; size; l++)
<FONT ID="LN">307 </FONT><A NAME="307"></A>    rules[l] = (RidorRule)finalRules.elementAt(l);
<FONT ID="LN">308 </FONT><A NAME="308"></A>        
<FONT ID="LN">309 </FONT><A NAME="309"></A>      <FONT ID="MultiLineComment">/* Build exceptions for each exception rule */</FONT>
<FONT ID="LN">310 </FONT><A NAME="310"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] uncovered = dataByClass; 
<FONT ID="LN">311 </FONT><A NAME="311"></A>      <FONT ID="If">if</FONT>(level == <FONT ID="IntegerLiteral">1</FONT>)  <FONT ID="SingleLineComment">// The error of default rule
<FONT ID="LN">312 </FONT><A NAME="312"></A></FONT>    m_Err = total - uncovered[(<FONT ID="Int">int</FONT>)defClass].sumOfWeights();            
<FONT ID="LN">313 </FONT><A NAME="313"></A>
<FONT ID="LN">314 </FONT><A NAME="314"></A>      uncovered[(<FONT ID="Int">int</FONT>)defClass] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(uncovered[(<FONT ID="Int">int</FONT>)defClass], <FONT ID="IntegerLiteral">0</FONT>);    
<FONT ID="LN">315 </FONT><A NAME="315"></A>        
<FONT ID="LN">316 </FONT><A NAME="316"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> m=<FONT ID="IntegerLiteral">0</FONT>; m &lt; size; m++){
<FONT ID="LN">317 </FONT><A NAME="317"></A>    <FONT ID="MultiLineComment">/* The data covered by this rule, they are also deducted from the original data */</FONT>
<FONT ID="LN">318 </FONT><A NAME="318"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A>[][] dvdData = divide(rules[m], uncovered);
<FONT ID="LN">319 </FONT><A NAME="319"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] covered = dvdData[<FONT ID="IntegerLiteral">0</FONT>];    <FONT ID="SingleLineComment">// Data covered by the rule
<FONT ID="LN">320 </FONT><A NAME="320"></A></FONT>    <FONT ID="SingleLineComment">//uncovered = dvdData[1];            // Data not covered by the rule
<FONT ID="LN">321 </FONT><A NAME="321"></A></FONT>    excepts[m] = <FONT ID="New">new</FONT> Ridor_node();
<FONT ID="LN">322 </FONT><A NAME="322"></A>    excepts[m].findRules(covered, level);<FONT ID="SingleLineComment">// Find exceptions on the covered data
<FONT ID="LN">323 </FONT><A NAME="323"></A></FONT>      }
<FONT ID="LN">324 </FONT><A NAME="324"></A>    }
<FONT ID="LN">325 </FONT><A NAME="325"></A>
<FONT ID="LN">326 </FONT><A NAME="326"></A>    <FONT ID="FormalComment">/** 
<FONT ID="LN">327 </FONT><A NAME="327"></A>     * Private function to build a rule set and return the weighted avg of accuracy
<FONT ID="LN">328 </FONT><A NAME="328"></A>     * rate of rules in the set.
<FONT ID="LN">329 </FONT><A NAME="329"></A>     *
<FONT ID="LN">330 </FONT><A NAME="330"></A>     * @param insts the data used to build ruleset
<FONT ID="LN">331 </FONT><A NAME="331"></A>     * @param classCount the counts of the instances with the predicted class but not
<FONT ID="LN">332 </FONT><A NAME="332"></A>     *                   yet covered by the ruleset
<FONT ID="LN">333 </FONT><A NAME="333"></A>     * @param ruleset the ruleset to be built
<FONT ID="LN">334 </FONT><A NAME="334"></A>     * @return the weighted accuracy rate of the ruleset
<FONT ID="LN">335 </FONT><A NAME="335"></A>     * @throws Exception if the rules cannot be built properly
<FONT ID="LN">336 </FONT><A NAME="336"></A>     */</FONT>
<FONT ID="LN">337 </FONT><A NAME="337"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> buildRuleset(<A HREF="../../../weka/core/Instances.java.html">Instances</A> insts, <FONT ID="Double">double</FONT> classCount, <A HREF="../../../weka/core/FastVector.java.html">Vector</A> ruleset) 
<FONT ID="LN">338 </FONT><A NAME="338"></A>      <FONT ID="Throws">throws</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A> {        
<FONT ID="LN">339 </FONT><A NAME="339"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(insts);
<FONT ID="LN">340 </FONT><A NAME="340"></A>      <FONT ID="Double">double</FONT> wAcRt = <FONT ID="IntegerLiteral">0</FONT>;  <FONT ID="SingleLineComment">// The weighted accuracy rate of this ruleset
<FONT ID="LN">341 </FONT><A NAME="341"></A></FONT>      <FONT ID="Double">double</FONT> total = data.sumOfWeights();
<FONT ID="LN">342 </FONT><A NAME="342"></A>        
<FONT ID="LN">343 </FONT><A NAME="343"></A>      <FONT ID="While">while</FONT>( classCount &gt;= m_Folds ){      <FONT ID="SingleLineComment">// Data is not pure
<FONT ID="LN">344 </FONT><A NAME="344"></A></FONT>    RidorRule bestRule = <FONT ID="Null">null</FONT>;
<FONT ID="LN">345 </FONT><A NAME="345"></A>    <FONT ID="Double">double</FONT> bestWorthRate= -<FONT ID="IntegerLiteral">1</FONT>;        <FONT ID="SingleLineComment">// The best worth achieved by
<FONT ID="LN">346 </FONT><A NAME="346"></A></FONT>    <FONT ID="Double">double</FONT> bestWorth = -<FONT ID="IntegerLiteral">1</FONT>;           <FONT ID="SingleLineComment">// randomization of the data
<FONT ID="LN">347 </FONT><A NAME="347"></A></FONT>        
<FONT ID="LN">348 </FONT><A NAME="348"></A>    RidorRule rule = <FONT ID="New">new</FONT> RidorRule();                                
<FONT ID="LN">349 </FONT><A NAME="349"></A>    rule.setPredictedClass(<FONT ID="IntegerLiteral">0</FONT>);       <FONT ID="SingleLineComment">// Predict the classes other than default
<FONT ID="LN">350 </FONT><A NAME="350"></A></FONT>        
<FONT ID="LN">351 </FONT><A NAME="351"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j = <FONT ID="IntegerLiteral">0</FONT>; j &lt; m_Shuffle; j++){
<FONT ID="LN">352 </FONT><A NAME="352"></A>      <FONT ID="If">if</FONT>(m_Shuffle &gt; <FONT ID="IntegerLiteral">1</FONT>)
<FONT ID="LN">353 </FONT><A NAME="353"></A>        data.randomize(m_Random);
<FONT ID="LN">354 </FONT><A NAME="354"></A>            
<FONT ID="LN">355 </FONT><A NAME="355"></A>      rule.buildClassifier(data);
<FONT ID="LN">356 </FONT><A NAME="356"></A>            
<FONT ID="LN">357 </FONT><A NAME="357"></A>      <FONT ID="Double">double</FONT> wr, w; <FONT ID="SingleLineComment">// Worth rate and worth
<FONT ID="LN">358 </FONT><A NAME="358"></A></FONT>      <FONT ID="If">if</FONT>(m_IsAllErr){
<FONT ID="LN">359 </FONT><A NAME="359"></A>        wr = (rule.getWorth()+rule.getAccuG()) / 
<FONT ID="LN">360 </FONT><A NAME="360"></A>          (rule.getCoverP()+rule.getCoverG());
<FONT ID="LN">361 </FONT><A NAME="361"></A>        w = rule.getWorth() + rule.getAccuG();
<FONT ID="LN">362 </FONT><A NAME="362"></A>      }
<FONT ID="LN">363 </FONT><A NAME="363"></A>      <FONT ID="Else">else</FONT>{
<FONT ID="LN">364 </FONT><A NAME="364"></A>        wr = rule.getWorthRate();
<FONT ID="LN">365 </FONT><A NAME="365"></A>        w = rule.getWorth(); 
<FONT ID="LN">366 </FONT><A NAME="366"></A>      }
<FONT ID="LN">367 </FONT><A NAME="367"></A>            
<FONT ID="LN">368 </FONT><A NAME="368"></A>      <FONT ID="If">if</FONT>(Utils.gr(wr, bestWorthRate) ||
<FONT ID="LN">369 </FONT><A NAME="369"></A>         (Utils.eq(wr, bestWorthRate) &amp;&amp; Utils.gr(w, bestWorth))){
<FONT ID="LN">370 </FONT><A NAME="370"></A>        bestRule = rule;
<FONT ID="LN">371 </FONT><A NAME="371"></A>        bestWorthRate = wr;
<FONT ID="LN">372 </FONT><A NAME="372"></A>        bestWorth = w;
<FONT ID="LN">373 </FONT><A NAME="373"></A>      }
<FONT ID="LN">374 </FONT><A NAME="374"></A>    }
<FONT ID="LN">375 </FONT><A NAME="375"></A>        
<FONT ID="LN">376 </FONT><A NAME="376"></A>    <FONT ID="If">if</FONT> (bestRule == <FONT ID="Null">null</FONT>)
<FONT ID="LN">377 </FONT><A NAME="377"></A>      <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A>(<FONT ID="StringLiteral">"Something wrong here inside findRule()!"</FONT>);
<FONT ID="LN">378 </FONT><A NAME="378"></A>        
<FONT ID="LN">379 </FONT><A NAME="379"></A>    <FONT ID="If">if</FONT>(Utils.sm(bestWorthRate, <FONT ID="FloatPointLiteral">0.5</FONT>) || (!bestRule.hasAntds()))
<FONT ID="LN">380 </FONT><A NAME="380"></A>      <FONT ID="Break">break</FONT>;                       <FONT ID="SingleLineComment">// No more good rules generated
<FONT ID="LN">381 </FONT><A NAME="381"></A></FONT>        
<FONT ID="LN">382 </FONT><A NAME="382"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A> newData = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data); 
<FONT ID="LN">383 </FONT><A NAME="383"></A>    data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(newData, <FONT ID="IntegerLiteral">0</FONT>);<FONT ID="SingleLineComment">// Empty the data
<FONT ID="LN">384 </FONT><A NAME="384"></A></FONT>    classCount = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">385 </FONT><A NAME="385"></A>    <FONT ID="Double">double</FONT> cover = <FONT ID="IntegerLiteral">0</FONT>;                <FONT ID="SingleLineComment">// Coverage of this rule on whole data
<FONT ID="LN">386 </FONT><A NAME="386"></A></FONT>        
<FONT ID="LN">387 </FONT><A NAME="387"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> l=<FONT ID="IntegerLiteral">0</FONT>; l&lt;newData.numInstances(); l++){
<FONT ID="LN">388 </FONT><A NAME="388"></A>      <A HREF="../../../weka/core/Instance.java.html">Instance</A> datum = newData.instance(l);
<FONT ID="LN">389 </FONT><A NAME="389"></A>      <FONT ID="If">if</FONT>(!bestRule.isCover(datum)){<FONT ID="SingleLineComment">// Data not covered by the previous rule
<FONT ID="LN">390 </FONT><A NAME="390"></A></FONT>        data.add(datum);
<FONT ID="LN">391 </FONT><A NAME="391"></A>        <FONT ID="If">if</FONT>(Utils.eq(datum.classValue(), <FONT ID="IntegerLiteral">0</FONT>)) 
<FONT ID="LN">392 </FONT><A NAME="392"></A>          classCount += datum.weight(); <FONT ID="SingleLineComment">// The predicted class in the data
<FONT ID="LN">393 </FONT><A NAME="393"></A></FONT>      }
<FONT ID="LN">394 </FONT><A NAME="394"></A>      <FONT ID="Else">else</FONT> cover += datum.weight();
<FONT ID="LN">395 </FONT><A NAME="395"></A>    }           
<FONT ID="LN">396 </FONT><A NAME="396"></A>        
<FONT ID="LN">397 </FONT><A NAME="397"></A>    wAcRt += computeWeightedAcRt(bestWorthRate, cover, total);
<FONT ID="LN">398 </FONT><A NAME="398"></A>    ruleset.addElement(bestRule);           
<FONT ID="LN">399 </FONT><A NAME="399"></A>      }  
<FONT ID="LN">400 </FONT><A NAME="400"></A>        
<FONT ID="LN">401 </FONT><A NAME="401"></A>      <FONT ID="MultiLineComment">/* The weighted def. accuracy */</FONT>
<FONT ID="LN">402 </FONT><A NAME="402"></A>      <FONT ID="Double">double</FONT> wDefAcRt = (data.sumOfWeights()-classCount) / total;           
<FONT ID="LN">403 </FONT><A NAME="403"></A>      wAcRt += wDefAcRt;
<FONT ID="LN">404 </FONT><A NAME="404"></A>        
<FONT ID="LN">405 </FONT><A NAME="405"></A>      <FONT ID="Return">return</FONT> wAcRt;
<FONT ID="LN">406 </FONT><A NAME="406"></A>    }
<FONT ID="LN">407 </FONT><A NAME="407"></A>    
<FONT ID="LN">408 </FONT><A NAME="408"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">409 </FONT><A NAME="409"></A>     * Private function to combine two data
<FONT ID="LN">410 </FONT><A NAME="410"></A>     *
<FONT ID="LN">411 </FONT><A NAME="411"></A>     * @param data1 the data to which data2 is appended 
<FONT ID="LN">412 </FONT><A NAME="412"></A>     * @param data2 the data to be appended to data1
<FONT ID="LN">413 </FONT><A NAME="413"></A>     * @return the merged data
<FONT ID="LN">414 </FONT><A NAME="414"></A>     */</FONT>
<FONT ID="LN">415 </FONT><A NAME="415"></A>    <FONT ID="Private">private</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A> append(<A HREF="../../../weka/core/Instances.java.html">Instances</A> data1, <A HREF="../../../weka/core/Instances.java.html">Instances</A> data2){
<FONT ID="LN">416 </FONT><A NAME="416"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data1);
<FONT ID="LN">417 </FONT><A NAME="417"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;data2.numInstances(); i++)
<FONT ID="LN">418 </FONT><A NAME="418"></A>    data.add(data2.instance(i));
<FONT ID="LN">419 </FONT><A NAME="419"></A>        
<FONT ID="LN">420 </FONT><A NAME="420"></A>      <FONT ID="Return">return</FONT> data;
<FONT ID="LN">421 </FONT><A NAME="421"></A>    }
<FONT ID="LN">422 </FONT><A NAME="422"></A>    
<FONT ID="LN">423 </FONT><A NAME="423"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">424 </FONT><A NAME="424"></A>     * Compute the weighted average of accuracy rate of a certain rule
<FONT ID="LN">425 </FONT><A NAME="425"></A>     * Each rule is weighted by its coverage proportion in the whole data.  
<FONT ID="LN">426 </FONT><A NAME="426"></A>     * So the accuracy rate of one ruleset is actually 
<FONT ID="LN">427 </FONT><A NAME="427"></A>     * 
<FONT ID="LN">428 </FONT><A NAME="428"></A>     * (worth rate) * (coverage proportion)
<FONT ID="LN">429 </FONT><A NAME="429"></A>     *
<FONT ID="LN">430 </FONT><A NAME="430"></A>     *                               coverage of the rule on the whole data
<FONT ID="LN">431 </FONT><A NAME="431"></A>     * where coverage proportion = -----------------------------------------
<FONT ID="LN">432 </FONT><A NAME="432"></A>     *                              the whole data size fed into the ruleset
<FONT ID="LN">433 </FONT><A NAME="433"></A>     *
<FONT ID="LN">434 </FONT><A NAME="434"></A>     * @param worthRt the worth rate
<FONT ID="LN">435 </FONT><A NAME="435"></A>     * @param cover the coverage of the rule on the whole data
<FONT ID="LN">436 </FONT><A NAME="436"></A>     * @param total the total data size fed into the ruleset
<FONT ID="LN">437 </FONT><A NAME="437"></A>     * @return the weighted accuracy rate of this rule
<FONT ID="LN">438 </FONT><A NAME="438"></A>     */</FONT>
<FONT ID="LN">439 </FONT><A NAME="439"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> computeWeightedAcRt(<FONT ID="Double">double</FONT> worthRt, <FONT ID="Double">double</FONT> cover, <FONT ID="Double">double</FONT> total){
<FONT ID="LN">440 </FONT><A NAME="440"></A>      
<FONT ID="LN">441 </FONT><A NAME="441"></A>      <FONT ID="Return">return</FONT> (worthRt * (cover/total)); 
<FONT ID="LN">442 </FONT><A NAME="442"></A>    }
<FONT ID="LN">443 </FONT><A NAME="443"></A>    
<FONT ID="LN">444 </FONT><A NAME="444"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">445 </FONT><A NAME="445"></A>     * Builds an array of data according to their true class label
<FONT ID="LN">446 </FONT><A NAME="446"></A>     * Each bag of data is filtered through the rule specified and
<FONT ID="LN">447 </FONT><A NAME="447"></A>     * is totally covered by this rule.  
<FONT ID="LN">448 </FONT><A NAME="448"></A>     * Both the data covered and uncovered by the rule will be returned
<FONT ID="LN">449 </FONT><A NAME="449"></A>     * by the procedure.  
<FONT ID="LN">450 </FONT><A NAME="450"></A>     *
<FONT ID="LN">451 </FONT><A NAME="451"></A>     * @param rule the rule covering the data
<FONT ID="LN">452 </FONT><A NAME="452"></A>     * @param dataByClass the array of data to be covered by the rule
<FONT ID="LN">453 </FONT><A NAME="453"></A>     * @return the arrays of data both covered and not covered by the rule
<FONT ID="LN">454 </FONT><A NAME="454"></A>     */</FONT>
<FONT ID="LN">455 </FONT><A NAME="455"></A>    <FONT ID="Private">private</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[][] divide(RidorRule rule, <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] dataByClass){
<FONT ID="LN">456 </FONT><A NAME="456"></A>      <FONT ID="Int">int</FONT> len = dataByClass.length;
<FONT ID="LN">457 </FONT><A NAME="457"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[][] dataBags = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[<FONT ID="IntegerLiteral">2</FONT>][len];
<FONT ID="LN">458 </FONT><A NAME="458"></A>        
<FONT ID="LN">459 </FONT><A NAME="459"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; len; i++){
<FONT ID="LN">460 </FONT><A NAME="460"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] dvdData = rule.coveredByRule(dataByClass[i]);
<FONT ID="LN">461 </FONT><A NAME="461"></A>    dataBags[<FONT ID="IntegerLiteral">0</FONT>][i] = dvdData[<FONT ID="IntegerLiteral">0</FONT>];     <FONT ID="SingleLineComment">// Covered by the rule
<FONT ID="LN">462 </FONT><A NAME="462"></A></FONT>    dataBags[<FONT ID="IntegerLiteral">1</FONT>][i] = dvdData[<FONT ID="IntegerLiteral">1</FONT>];     <FONT ID="SingleLineComment">// Not covered by the rule
<FONT ID="LN">463 </FONT><A NAME="463"></A></FONT>      }
<FONT ID="LN">464 </FONT><A NAME="464"></A>        
<FONT ID="LN">465 </FONT><A NAME="465"></A>      <FONT ID="Return">return</FONT> dataBags;
<FONT ID="LN">466 </FONT><A NAME="466"></A>    }
<FONT ID="LN">467 </FONT><A NAME="467"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">468 </FONT><A NAME="468"></A>     * The size of the certain node of Ridor, i.e. the 
<FONT ID="LN">469 </FONT><A NAME="469"></A>     * number of rules generated within and below this node
<FONT ID="LN">470 </FONT><A NAME="470"></A>     *
<FONT ID="LN">471 </FONT><A NAME="471"></A>     * @return the size of this node
<FONT ID="LN">472 </FONT><A NAME="472"></A>     */</FONT>
<FONT ID="LN">473 </FONT><A NAME="473"></A>    <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> size(){
<FONT ID="LN">474 </FONT><A NAME="474"></A>      <FONT ID="Int">int</FONT> size = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">475 </FONT><A NAME="475"></A>      <FONT ID="If">if</FONT>(rules != <FONT ID="Null">null</FONT>){
<FONT ID="LN">476 </FONT><A NAME="476"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; rules.length; i++)
<FONT ID="LN">477 </FONT><A NAME="477"></A>      size += excepts[i].size(); <FONT ID="SingleLineComment">// The children's size
<FONT ID="LN">478 </FONT><A NAME="478"></A></FONT>    size += rules.length;          <FONT ID="SingleLineComment">// This node's size
<FONT ID="LN">479 </FONT><A NAME="479"></A></FONT>      }
<FONT ID="LN">480 </FONT><A NAME="480"></A>      <FONT ID="Return">return</FONT> size;
<FONT ID="LN">481 </FONT><A NAME="481"></A>    }
<FONT ID="LN">482 </FONT><A NAME="482"></A>    
<FONT ID="LN">483 </FONT><A NAME="483"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">484 </FONT><A NAME="484"></A>     * Prints the all the rules of one node of Ridor.
<FONT ID="LN">485 </FONT><A NAME="485"></A>     *
<FONT ID="LN">486 </FONT><A NAME="486"></A>     * @return a textual description of one node of Ridor
<FONT ID="LN">487 </FONT><A NAME="487"></A>     */</FONT>
<FONT ID="LN">488 </FONT><A NAME="488"></A>    <FONT ID="Public">public</FONT> String toString(){
<FONT ID="LN">489 </FONT><A NAME="489"></A>      StringBuffer text =  <FONT ID="New">new</FONT> StringBuffer();
<FONT ID="LN">490 </FONT><A NAME="490"></A>        
<FONT ID="LN">491 </FONT><A NAME="491"></A>      <FONT ID="If">if</FONT>(level == <FONT ID="IntegerLiteral">1</FONT>)
<FONT ID="LN">492 </FONT><A NAME="492"></A>    text.append(m_Class.name() + <FONT ID="StringLiteral">" = "</FONT> + m_Class.value((<FONT ID="Int">int</FONT>)getDefClass())+
<FONT ID="LN">493 </FONT><A NAME="493"></A>            <FONT ID="StringLiteral">"  ("</FONT>+m_Cover+<FONT ID="StringLiteral">"/"</FONT>+m_Err+<FONT ID="StringLiteral">")\n"</FONT>);
<FONT ID="LN">494 </FONT><A NAME="494"></A>      <FONT ID="If">if</FONT>(rules != <FONT ID="Null">null</FONT>){
<FONT ID="LN">495 </FONT><A NAME="495"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; rules.length; i++){
<FONT ID="LN">496 </FONT><A NAME="496"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j &lt; level; j++)
<FONT ID="LN">497 </FONT><A NAME="497"></A>        text.append(<FONT ID="StringLiteral">"         "</FONT>);
<FONT ID="LN">498 </FONT><A NAME="498"></A>      String cl = m_Class.value((<FONT ID="Int">int</FONT>)(excepts[i].getDefClass()));
<FONT ID="LN">499 </FONT><A NAME="499"></A>      text.append(<FONT ID="StringLiteral">"  Except "</FONT> + 
<FONT ID="LN">500 </FONT><A NAME="500"></A>              rules[i].toString(m_Class.name(), cl)+
<FONT ID="LN">501 </FONT><A NAME="501"></A>              <FONT ID="StringLiteral">"\n"</FONT> + excepts[i].toString());
<FONT ID="LN">502 </FONT><A NAME="502"></A>    }
<FONT ID="LN">503 </FONT><A NAME="503"></A>      }
<FONT ID="LN">504 </FONT><A NAME="504"></A>        
<FONT ID="LN">505 </FONT><A NAME="505"></A>      <FONT ID="Return">return</FONT> text.toString();
<FONT ID="LN">506 </FONT><A NAME="506"></A>    }
<FONT ID="LN">507 </FONT><A NAME="507"></A>    
<FONT ID="LN">508 </FONT><A NAME="508"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">509 </FONT><A NAME="509"></A>     * Returns the revision string.
<FONT ID="LN">510 </FONT><A NAME="510"></A>     * 
<FONT ID="LN">511 </FONT><A NAME="511"></A>     * @return      the revision
<FONT ID="LN">512 </FONT><A NAME="512"></A>     */</FONT>
<FONT ID="LN">513 </FONT><A NAME="513"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">514 </FONT><A NAME="514"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">515 </FONT><A NAME="515"></A>    }
<FONT ID="LN">516 </FONT><A NAME="516"></A>  }    
<FONT ID="LN">517 </FONT><A NAME="517"></A>
<FONT ID="LN">518 </FONT><A NAME="518"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">519 </FONT><A NAME="519"></A>   * This class implements a single rule that predicts the 2-class distribution.  
<FONT ID="LN">520 </FONT><A NAME="520"></A>   *
<FONT ID="LN">521 </FONT><A NAME="521"></A>   * A rule consists of antecedents "AND"ed together and the consequent (class value) 
<FONT ID="LN">522 </FONT><A NAME="522"></A>   * for the classification.  In this case, the consequent is the distribution of
<FONT ID="LN">523 </FONT><A NAME="523"></A>   * the available classes (always 2 classes) in the dataset.  
<FONT ID="LN">524 </FONT><A NAME="524"></A>   * In this class, the Information Gain (p*[log(p/t) - log(P/T)]) is used to select 
<FONT ID="LN">525 </FONT><A NAME="525"></A>   * an antecedent and Reduced Error Prunning (REP) is used to prune the rule. 
<FONT ID="LN">526 </FONT><A NAME="526"></A>   *
<FONT ID="LN">527 </FONT><A NAME="527"></A>   */</FONT>
<FONT ID="LN">528 </FONT><A NAME="528"></A>  <FONT ID="Private">private</FONT> <FONT ID="Class">class</FONT> RidorRule 
<FONT ID="LN">529 </FONT><A NAME="529"></A>    <FONT ID="Implements">implements</FONT> <A HREF="../../../weka/core/WeightedInstancesHandler.java.html">WeightedInstancesHandler</A>, Serializable, <A HREF="../../../weka/core/RevisionHandler.java.html">RevisionHandler</A> {
<FONT ID="LN">530 </FONT><A NAME="530"></A>    
<FONT ID="LN">531 </FONT><A NAME="531"></A>    <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">532 </FONT><A NAME="532"></A>    <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = <FONT ID="IntegerLiteral">4375199423973848157L</FONT>;
<FONT ID="LN">533 </FONT><A NAME="533"></A>    
<FONT ID="LN">534 </FONT><A NAME="534"></A>    <FONT ID="FormalComment">/** The internal representation of the class label to be predicted*/</FONT>
<FONT ID="LN">535 </FONT><A NAME="535"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_Class = -<FONT ID="IntegerLiteral">1</FONT>;    
<FONT ID="LN">536 </FONT><A NAME="536"></A>    
<FONT ID="LN">537 </FONT><A NAME="537"></A>    <FONT ID="FormalComment">/** The class attribute of the data*/</FONT>
<FONT ID="LN">538 </FONT><A NAME="538"></A>    <FONT ID="Private">private</FONT> <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> m_ClassAttribute;
<FONT ID="LN">539 </FONT><A NAME="539"></A>    
<FONT ID="LN">540 </FONT><A NAME="540"></A>    <FONT ID="FormalComment">/** The vector of antecedents of this rule*/</FONT>
<FONT ID="LN">541 </FONT><A NAME="541"></A>    <FONT ID="Protected">protected</FONT> <A HREF="../../../weka/core/FastVector.java.html">FastVector</A> m_Antds = <FONT ID="Null">null</FONT>;
<FONT ID="LN">542 </FONT><A NAME="542"></A>    
<FONT ID="LN">543 </FONT><A NAME="543"></A>    <FONT ID="FormalComment">/** The worth rate of this rule, in this case, accuracy rate in the pruning data*/</FONT>
<FONT ID="LN">544 </FONT><A NAME="544"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_WorthRate = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">545 </FONT><A NAME="545"></A>    
<FONT ID="LN">546 </FONT><A NAME="546"></A>    <FONT ID="FormalComment">/** The worth value of this rule, in this case, accurate # in pruning data*/</FONT>
<FONT ID="LN">547 </FONT><A NAME="547"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_Worth = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">548 </FONT><A NAME="548"></A>    
<FONT ID="LN">549 </FONT><A NAME="549"></A>    <FONT ID="FormalComment">/** The sum of weights of the data covered by this rule in the pruning data */</FONT>
<FONT ID="LN">550 </FONT><A NAME="550"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_CoverP = <FONT ID="IntegerLiteral">0</FONT>;   
<FONT ID="LN">551 </FONT><A NAME="551"></A>    
<FONT ID="LN">552 </FONT><A NAME="552"></A>    <FONT ID="FormalComment">/** The accurate and covered data of this rule in the growing data */</FONT>
<FONT ID="LN">553 </FONT><A NAME="553"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> m_CoverG = <FONT ID="IntegerLiteral">0</FONT>, m_AccuG = <FONT ID="IntegerLiteral">0</FONT>;       
<FONT ID="LN">554 </FONT><A NAME="554"></A>  
<FONT ID="LN">555 </FONT><A NAME="555"></A>    <FONT ID="FormalComment">/** The access functions for parameters */</FONT>
<FONT ID="LN">556 </FONT><A NAME="556"></A>    <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setPredictedClass(<FONT ID="Double">double</FONT> cl){  m_Class = cl; }
<FONT ID="LN">557 </FONT><A NAME="557"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getPredictedClass(){ <FONT ID="Return">return</FONT> m_Class; }
<FONT ID="LN">558 </FONT><A NAME="558"></A>    
<FONT ID="LN">559 </FONT><A NAME="559"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">560 </FONT><A NAME="560"></A>     * Builds a single rule learner with REP dealing with 2 classes.
<FONT ID="LN">561 </FONT><A NAME="561"></A>     * This rule learner always tries to predict the class with label 
<FONT ID="LN">562 </FONT><A NAME="562"></A>     * m_Class.
<FONT ID="LN">563 </FONT><A NAME="563"></A>     *
<FONT ID="LN">564 </FONT><A NAME="564"></A>     * @param instances the training data
<FONT ID="LN">565 </FONT><A NAME="565"></A>     * @throws Exception if classifier can't be built successfully
<FONT ID="LN">566 </FONT><A NAME="566"></A>     */</FONT>
<FONT ID="LN">567 </FONT><A NAME="567"></A>    <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> buildClassifier(<A HREF="../../../weka/core/Instances.java.html">Instances</A> instances) <FONT ID="Throws">throws</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A> {
<FONT ID="LN">568 </FONT><A NAME="568"></A>      m_ClassAttribute = instances.classAttribute();
<FONT ID="LN">569 </FONT><A NAME="569"></A>      <FONT ID="If">if</FONT> (!m_ClassAttribute.isNominal()) 
<FONT ID="LN">570 </FONT><A NAME="570"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">UnsupportedClassTypeException</A>(<FONT ID="StringLiteral">" Only nominal class, please."</FONT>);
<FONT ID="LN">571 </FONT><A NAME="571"></A>      <FONT ID="If">if</FONT>(instances.numClasses() != <FONT ID="IntegerLiteral">2</FONT>)
<FONT ID="LN">572 </FONT><A NAME="572"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A>(<FONT ID="StringLiteral">" Only 2 classes, please."</FONT>);
<FONT ID="LN">573 </FONT><A NAME="573"></A>        
<FONT ID="LN">574 </FONT><A NAME="574"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(instances);
<FONT ID="LN">575 </FONT><A NAME="575"></A>      <FONT ID="If">if</FONT>(Utils.eq(data.sumOfWeights(),<FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">576 </FONT><A NAME="576"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A>(<FONT ID="StringLiteral">" No training data."</FONT>);
<FONT ID="LN">577 </FONT><A NAME="577"></A>        
<FONT ID="LN">578 </FONT><A NAME="578"></A>      data.deleteWithMissingClass();
<FONT ID="LN">579 </FONT><A NAME="579"></A>      <FONT ID="If">if</FONT>(Utils.eq(data.sumOfWeights(),<FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">580 </FONT><A NAME="580"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A>(<FONT ID="StringLiteral">" The class labels of all the training data are missing."</FONT>); 
<FONT ID="LN">581 </FONT><A NAME="581"></A>        
<FONT ID="LN">582 </FONT><A NAME="582"></A>      <FONT ID="If">if</FONT>(data.numInstances() &lt; m_Folds)
<FONT ID="LN">583 </FONT><A NAME="583"></A>    <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A>(<FONT ID="StringLiteral">" Not enough data for REP."</FONT>);
<FONT ID="LN">584 </FONT><A NAME="584"></A>        
<FONT ID="LN">585 </FONT><A NAME="585"></A>      m_Antds = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">FastVector</A>();   
<FONT ID="LN">586 </FONT><A NAME="586"></A>        
<FONT ID="LN">587 </FONT><A NAME="587"></A>      <FONT ID="MultiLineComment">/* Split data into Grow and Prune*/</FONT>
<FONT ID="LN">588 </FONT><A NAME="588"></A>      m_Random = <FONT ID="New">new</FONT> Random(m_Seed);
<FONT ID="LN">589 </FONT><A NAME="589"></A>      data.randomize(m_Random);
<FONT ID="LN">590 </FONT><A NAME="590"></A>      data.stratify(m_Folds);
<FONT ID="LN">591 </FONT><A NAME="591"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> growData=data.trainCV(m_Folds, m_Folds-<FONT ID="IntegerLiteral">1</FONT>, m_Random);
<FONT ID="LN">592 </FONT><A NAME="592"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> pruneData=data.testCV(m_Folds, m_Folds-<FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">593 </FONT><A NAME="593"></A>        
<FONT ID="LN">594 </FONT><A NAME="594"></A>      grow(growData);      <FONT ID="SingleLineComment">// Build this rule
<FONT ID="LN">595 </FONT><A NAME="595"></A></FONT>        
<FONT ID="LN">596 </FONT><A NAME="596"></A>      prune(pruneData);    <FONT ID="SingleLineComment">// Prune this rule
<FONT ID="LN">597 </FONT><A NAME="597"></A></FONT>    }
<FONT ID="LN">598 </FONT><A NAME="598"></A>    
<FONT ID="LN">599 </FONT><A NAME="599"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">600 </FONT><A NAME="600"></A>     * Find all the instances in the dataset covered by this rule.
<FONT ID="LN">601 </FONT><A NAME="601"></A>     * The instances not covered will also be deducted from the the original data
<FONT ID="LN">602 </FONT><A NAME="602"></A>     * and returned by this procedure.
<FONT ID="LN">603 </FONT><A NAME="603"></A>     * 
<FONT ID="LN">604 </FONT><A NAME="604"></A>     * @param insts the dataset to be covered by this rule.
<FONT ID="LN">605 </FONT><A NAME="605"></A>     * @return the instances covered and not covered by this rule
<FONT ID="LN">606 </FONT><A NAME="606"></A>     */</FONT>
<FONT ID="LN">607 </FONT><A NAME="607"></A>    <FONT ID="Public">public</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] coveredByRule(<A HREF="../../../weka/core/Instances.java.html">Instances</A> insts){
<FONT ID="LN">608 </FONT><A NAME="608"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[<FONT ID="IntegerLiteral">2</FONT>];
<FONT ID="LN">609 </FONT><A NAME="609"></A>      data[<FONT ID="IntegerLiteral">0</FONT>] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(insts, insts.numInstances());
<FONT ID="LN">610 </FONT><A NAME="610"></A>      data[<FONT ID="IntegerLiteral">1</FONT>] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(insts, insts.numInstances());
<FONT ID="LN">611 </FONT><A NAME="611"></A>        
<FONT ID="LN">612 </FONT><A NAME="612"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;insts.numInstances(); i++){
<FONT ID="LN">613 </FONT><A NAME="613"></A>    <A HREF="../../../weka/core/Instance.java.html">Instance</A> datum = insts.instance(i);
<FONT ID="LN">614 </FONT><A NAME="614"></A>    <FONT ID="If">if</FONT>(isCover(datum))
<FONT ID="LN">615 </FONT><A NAME="615"></A>      data[<FONT ID="IntegerLiteral">0</FONT>].add(datum);        <FONT ID="SingleLineComment">// Covered by this rule
<FONT ID="LN">616 </FONT><A NAME="616"></A></FONT>    <FONT ID="Else">else</FONT>
<FONT ID="LN">617 </FONT><A NAME="617"></A>      data[<FONT ID="IntegerLiteral">1</FONT>].add(datum);        <FONT ID="SingleLineComment">// Not covered by this rule
<FONT ID="LN">618 </FONT><A NAME="618"></A></FONT>      }
<FONT ID="LN">619 </FONT><A NAME="619"></A>        
<FONT ID="LN">620 </FONT><A NAME="620"></A>      <FONT ID="Return">return</FONT> data;
<FONT ID="LN">621 </FONT><A NAME="621"></A>    }
<FONT ID="LN">622 </FONT><A NAME="622"></A>    
<FONT ID="LN">623 </FONT><A NAME="623"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">624 </FONT><A NAME="624"></A>     * Whether the instance covered by this rule
<FONT ID="LN">625 </FONT><A NAME="625"></A>     * 
<FONT ID="LN">626 </FONT><A NAME="626"></A>     * @param inst the instance in question
<FONT ID="LN">627 </FONT><A NAME="627"></A>     * @return the boolean value indicating whether the instance is covered by this rule
<FONT ID="LN">628 </FONT><A NAME="628"></A>     */</FONT>
<FONT ID="LN">629 </FONT><A NAME="629"></A>    <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> isCover(<A HREF="../../../weka/core/Instance.java.html">Instance</A> datum){
<FONT ID="LN">630 </FONT><A NAME="630"></A>      <FONT ID="Boolean">boolean</FONT> isCover=<FONT ID="True">true</FONT>;
<FONT ID="LN">631 </FONT><A NAME="631"></A>        
<FONT ID="LN">632 </FONT><A NAME="632"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;m_Antds.size(); i++){
<FONT ID="LN">633 </FONT><A NAME="633"></A>    Antd antd = (Antd)m_Antds.elementAt(i);
<FONT ID="LN">634 </FONT><A NAME="634"></A>    <FONT ID="If">if</FONT>(!antd.isCover(datum)){
<FONT ID="LN">635 </FONT><A NAME="635"></A>      isCover = <FONT ID="False">false</FONT>;
<FONT ID="LN">636 </FONT><A NAME="636"></A>      <FONT ID="Break">break</FONT>;
<FONT ID="LN">637 </FONT><A NAME="637"></A>    }
<FONT ID="LN">638 </FONT><A NAME="638"></A>      }
<FONT ID="LN">639 </FONT><A NAME="639"></A>        
<FONT ID="LN">640 </FONT><A NAME="640"></A>      <FONT ID="Return">return</FONT> isCover;
<FONT ID="LN">641 </FONT><A NAME="641"></A>    }        
<FONT ID="LN">642 </FONT><A NAME="642"></A>    
<FONT ID="LN">643 </FONT><A NAME="643"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">644 </FONT><A NAME="644"></A>     * Whether this rule has antecedents, i.e. whether it is a default rule
<FONT ID="LN">645 </FONT><A NAME="645"></A>     * 
<FONT ID="LN">646 </FONT><A NAME="646"></A>     * @return the boolean value indicating whether the rule has antecedents
<FONT ID="LN">647 </FONT><A NAME="647"></A>     */</FONT>
<FONT ID="LN">648 </FONT><A NAME="648"></A>    <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> hasAntds(){
<FONT ID="LN">649 </FONT><A NAME="649"></A>      <FONT ID="If">if</FONT> (m_Antds == <FONT ID="Null">null</FONT>)
<FONT ID="LN">650 </FONT><A NAME="650"></A>    <FONT ID="Return">return</FONT> <FONT ID="False">false</FONT>;
<FONT ID="LN">651 </FONT><A NAME="651"></A>      <FONT ID="Else">else</FONT>
<FONT ID="LN">652 </FONT><A NAME="652"></A>    <FONT ID="Return">return</FONT> (m_Antds.size() &gt; <FONT ID="IntegerLiteral">0</FONT>);
<FONT ID="LN">653 </FONT><A NAME="653"></A>    }      
<FONT ID="LN">654 </FONT><A NAME="654"></A>    
<FONT ID="LN">655 </FONT><A NAME="655"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">656 </FONT><A NAME="656"></A>     * Build one rule using the growing data
<FONT ID="LN">657 </FONT><A NAME="657"></A>     *
<FONT ID="LN">658 </FONT><A NAME="658"></A>     * @param data the growing data used to build the rule
<FONT ID="LN">659 </FONT><A NAME="659"></A>     */</FONT>    
<FONT ID="LN">660 </FONT><A NAME="660"></A>    <FONT ID="Private">private</FONT> <FONT ID="Void">void</FONT> grow(<A HREF="../../../weka/core/Instances.java.html">Instances</A> data){
<FONT ID="LN">661 </FONT><A NAME="661"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> growData = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data);
<FONT ID="LN">662 </FONT><A NAME="662"></A>        
<FONT ID="LN">663 </FONT><A NAME="663"></A>      m_AccuG = computeDefAccu(growData);
<FONT ID="LN">664 </FONT><A NAME="664"></A>      m_CoverG = growData.sumOfWeights();
<FONT ID="LN">665 </FONT><A NAME="665"></A>      <FONT ID="MultiLineComment">/* Compute the default accurate rate of the growing data */</FONT>
<FONT ID="LN">666 </FONT><A NAME="666"></A>      <FONT ID="Double">double</FONT> defAcRt= m_AccuG / m_CoverG; 
<FONT ID="LN">667 </FONT><A NAME="667"></A>        
<FONT ID="LN">668 </FONT><A NAME="668"></A>      <FONT ID="MultiLineComment">/* Keep the record of which attributes have already been used*/</FONT>    
<FONT ID="LN">669 </FONT><A NAME="669"></A>      <FONT ID="Boolean">boolean</FONT>[] used=<FONT ID="New">new</FONT> <FONT ID="Boolean">boolean</FONT> [growData.numAttributes()];
<FONT ID="LN">670 </FONT><A NAME="670"></A>      <FONT ID="For">for</FONT> (<FONT ID="Int">int</FONT> k=<FONT ID="IntegerLiteral">0</FONT>; k&lt;used.length; k++)
<FONT ID="LN">671 </FONT><A NAME="671"></A>    used[k]=<FONT ID="False">false</FONT>;
<FONT ID="LN">672 </FONT><A NAME="672"></A>      <FONT ID="Int">int</FONT> numUnused=used.length;
<FONT ID="LN">673 </FONT><A NAME="673"></A>        
<FONT ID="LN">674 </FONT><A NAME="674"></A>      <FONT ID="Double">double</FONT> maxInfoGain;
<FONT ID="LN">675 </FONT><A NAME="675"></A>      <FONT ID="Boolean">boolean</FONT> isContinue = <FONT ID="True">true</FONT>; <FONT ID="SingleLineComment">// The stopping criterion of this rule
<FONT ID="LN">676 </FONT><A NAME="676"></A></FONT>        
<FONT ID="LN">677 </FONT><A NAME="677"></A>      <FONT ID="While">while</FONT> (isContinue){   
<FONT ID="LN">678 </FONT><A NAME="678"></A>    maxInfoGain = <FONT ID="IntegerLiteral">0</FONT>;       <FONT ID="SingleLineComment">// We require that infoGain be positive
<FONT ID="LN">679 </FONT><A NAME="679"></A></FONT>        
<FONT ID="LN">680 </FONT><A NAME="680"></A>    <FONT ID="MultiLineComment">/* Build a list of antecedents */</FONT>
<FONT ID="LN">681 </FONT><A NAME="681"></A>    Antd oneAntd=<FONT ID="Null">null</FONT>;
<FONT ID="LN">682 </FONT><A NAME="682"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A> coverData = <FONT ID="Null">null</FONT>;
<FONT ID="LN">683 </FONT><A NAME="683"></A>    Enumeration enumAttr=growData.enumerateAttributes();        
<FONT ID="LN">684 </FONT><A NAME="684"></A>    <FONT ID="Int">int</FONT> index=-<FONT ID="IntegerLiteral">1</FONT>;  
<FONT ID="LN">685 </FONT><A NAME="685"></A>        
<FONT ID="LN">686 </FONT><A NAME="686"></A>    <FONT ID="MultiLineComment">/* Build one condition based on all attributes not used yet*/</FONT>
<FONT ID="LN">687 </FONT><A NAME="687"></A>    <FONT ID="While">while</FONT> (enumAttr.hasMoreElements()){
<FONT ID="LN">688 </FONT><A NAME="688"></A>      <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> att= (<A HREF="../../../weka/core/Attribute.java.html">Attribute</A>)(enumAttr.nextElement());
<FONT ID="LN">689 </FONT><A NAME="689"></A>      index++;
<FONT ID="LN">690 </FONT><A NAME="690"></A>            
<FONT ID="LN">691 </FONT><A NAME="691"></A>      Antd antd =<FONT ID="Null">null</FONT>;  
<FONT ID="LN">692 </FONT><A NAME="692"></A>      <FONT ID="If">if</FONT>(att.isNumeric())
<FONT ID="LN">693 </FONT><A NAME="693"></A>        antd = <FONT ID="New">new</FONT> NumericAntd(att);
<FONT ID="LN">694 </FONT><A NAME="694"></A>      <FONT ID="Else">else</FONT>
<FONT ID="LN">695 </FONT><A NAME="695"></A>        antd = <FONT ID="New">new</FONT> NominalAntd(att);
<FONT ID="LN">696 </FONT><A NAME="696"></A>            
<FONT ID="LN">697 </FONT><A NAME="697"></A>      <FONT ID="If">if</FONT>(!used[index]){
<FONT ID="LN">698 </FONT><A NAME="698"></A>        <FONT ID="MultiLineComment">/* Compute the best information gain for each attribute,
<FONT ID="LN">699 </FONT><A NAME="699"></A>           it's stored in the antecedent formed by this attribute.
<FONT ID="LN">700 </FONT><A NAME="700"></A>           This procedure returns the data covered by the antecedent*/</FONT>
<FONT ID="LN">701 </FONT><A NAME="701"></A>        <A HREF="../../../weka/core/Instances.java.html">Instances</A> coveredData = computeInfoGain(growData, defAcRt, antd);
<FONT ID="LN">702 </FONT><A NAME="702"></A>        <FONT ID="If">if</FONT>(coveredData != <FONT ID="Null">null</FONT>){
<FONT ID="LN">703 </FONT><A NAME="703"></A>          <FONT ID="Double">double</FONT> infoGain = antd.getMaxInfoGain();          
<FONT ID="LN">704 </FONT><A NAME="704"></A>          <FONT ID="If">if</FONT>(Utils.gr(infoGain, maxInfoGain)){
<FONT ID="LN">705 </FONT><A NAME="705"></A>        oneAntd=antd;
<FONT ID="LN">706 </FONT><A NAME="706"></A>        coverData = coveredData;  
<FONT ID="LN">707 </FONT><A NAME="707"></A>        maxInfoGain = infoGain;
<FONT ID="LN">708 </FONT><A NAME="708"></A>          }         
<FONT ID="LN">709 </FONT><A NAME="709"></A>        }
<FONT ID="LN">710 </FONT><A NAME="710"></A>      }
<FONT ID="LN">711 </FONT><A NAME="711"></A>    }
<FONT ID="LN">712 </FONT><A NAME="712"></A>        
<FONT ID="LN">713 </FONT><A NAME="713"></A>    <FONT ID="If">if</FONT>(oneAntd == <FONT ID="Null">null</FONT>)  <FONT ID="Return">return</FONT>;
<FONT ID="LN">714 </FONT><A NAME="714"></A>        
<FONT ID="LN">715 </FONT><A NAME="715"></A>    <FONT ID="SingleLineComment">//Numeric attributes can be used more than once
<FONT ID="LN">716 </FONT><A NAME="716"></A></FONT>    <FONT ID="If">if</FONT>(!oneAntd.getAttr().isNumeric()){ 
<FONT ID="LN">717 </FONT><A NAME="717"></A>      used[oneAntd.getAttr().index()]=<FONT ID="True">true</FONT>;
<FONT ID="LN">718 </FONT><A NAME="718"></A>      numUnused--;
<FONT ID="LN">719 </FONT><A NAME="719"></A>    }
<FONT ID="LN">720 </FONT><A NAME="720"></A>        
<FONT ID="LN">721 </FONT><A NAME="721"></A>    m_Antds.addElement((Object)oneAntd);
<FONT ID="LN">722 </FONT><A NAME="722"></A>    growData = coverData;<FONT ID="SingleLineComment">// Grow data size is shrinking 
<FONT ID="LN">723 </FONT><A NAME="723"></A></FONT>        
<FONT ID="LN">724 </FONT><A NAME="724"></A>    defAcRt = oneAntd.getAccuRate();
<FONT ID="LN">725 </FONT><A NAME="725"></A>        
<FONT ID="LN">726 </FONT><A NAME="726"></A>    <FONT ID="MultiLineComment">/* Stop if no more data, rule perfect, no more attributes */</FONT>
<FONT ID="LN">727 </FONT><A NAME="727"></A>    <FONT ID="If">if</FONT>(Utils.eq(growData.sumOfWeights(), <FONT ID="FloatPointLiteral">0.0</FONT>) || Utils.eq(defAcRt, <FONT ID="FloatPointLiteral">1.0</FONT>) || (numUnused == <FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">728 </FONT><A NAME="728"></A>      isContinue = <FONT ID="False">false</FONT>;
<FONT ID="LN">729 </FONT><A NAME="729"></A>      }
<FONT ID="LN">730 </FONT><A NAME="730"></A>    }
<FONT ID="LN">731 </FONT><A NAME="731"></A>    
<FONT ID="LN">732 </FONT><A NAME="732"></A>    <FONT ID="FormalComment">/** 
<FONT ID="LN">733 </FONT><A NAME="733"></A>     * Compute the best information gain for the specified antecedent
<FONT ID="LN">734 </FONT><A NAME="734"></A>     *  
<FONT ID="LN">735 </FONT><A NAME="735"></A>     * @param data the data based on which the infoGain is computed
<FONT ID="LN">736 </FONT><A NAME="736"></A>     * @param defAcRt the default accuracy rate of data
<FONT ID="LN">737 </FONT><A NAME="737"></A>     * @param antd the specific antecedent
<FONT ID="LN">738 </FONT><A NAME="738"></A>     * @return the data covered by the antecedent
<FONT ID="LN">739 </FONT><A NAME="739"></A>     */</FONT>
<FONT ID="LN">740 </FONT><A NAME="740"></A>    <FONT ID="Private">private</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A> computeInfoGain(<A HREF="../../../weka/core/Instances.java.html">Instances</A> instances, <FONT ID="Double">double</FONT> defAcRt, Antd antd){
<FONT ID="LN">741 </FONT><A NAME="741"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(instances);
<FONT ID="LN">742 </FONT><A NAME="742"></A>        
<FONT ID="LN">743 </FONT><A NAME="743"></A>      <FONT ID="MultiLineComment">/* Split the data into bags.
<FONT ID="LN">744 </FONT><A NAME="744"></A>     The information gain of each bag is also calculated in this procedure */</FONT>
<FONT ID="LN">745 </FONT><A NAME="745"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData = antd.splitData(data, defAcRt, m_Class); 
<FONT ID="LN">746 </FONT><A NAME="746"></A>        
<FONT ID="LN">747 </FONT><A NAME="747"></A>      <FONT ID="MultiLineComment">/* Get the bag of data to be used for next antecedents */</FONT>
<FONT ID="LN">748 </FONT><A NAME="748"></A>      <FONT ID="If">if</FONT>(splitData != <FONT ID="Null">null</FONT>)
<FONT ID="LN">749 </FONT><A NAME="749"></A>    <FONT ID="Return">return</FONT> splitData[(<FONT ID="Int">int</FONT>)antd.getAttrValue()];
<FONT ID="LN">750 </FONT><A NAME="750"></A>      <FONT ID="Else">else</FONT> <FONT ID="Return">return</FONT> <FONT ID="Null">null</FONT>;
<FONT ID="LN">751 </FONT><A NAME="751"></A>    }
<FONT ID="LN">752 </FONT><A NAME="752"></A>    
<FONT ID="LN">753 </FONT><A NAME="753"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">754 </FONT><A NAME="754"></A>     * Prune the rule using the pruning data and update the worth parameters for this rule
<FONT ID="LN">755 </FONT><A NAME="755"></A>     * The accuracy rate is used to prune the rule.
<FONT ID="LN">756 </FONT><A NAME="756"></A>     *
<FONT ID="LN">757 </FONT><A NAME="757"></A>     * @param pruneData the pruning data used to prune the rule
<FONT ID="LN">758 </FONT><A NAME="758"></A>     */</FONT>    
<FONT ID="LN">759 </FONT><A NAME="759"></A>    <FONT ID="Private">private</FONT> <FONT ID="Void">void</FONT> prune(<A HREF="../../../weka/core/Instances.java.html">Instances</A> pruneData){
<FONT ID="LN">760 </FONT><A NAME="760"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data=<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(pruneData);
<FONT ID="LN">761 </FONT><A NAME="761"></A>        
<FONT ID="LN">762 </FONT><A NAME="762"></A>      <FONT ID="Double">double</FONT> total = data.sumOfWeights();
<FONT ID="LN">763 </FONT><A NAME="763"></A>        
<FONT ID="LN">764 </FONT><A NAME="764"></A>      <FONT ID="MultiLineComment">/* The default accurate# and the the accuracy rate on pruning data */</FONT>
<FONT ID="LN">765 </FONT><A NAME="765"></A>      <FONT ID="Double">double</FONT> defAccu=<FONT ID="IntegerLiteral">0</FONT>, defAccuRate=<FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">766 </FONT><A NAME="766"></A>        
<FONT ID="LN">767 </FONT><A NAME="767"></A>      <FONT ID="Int">int</FONT> size=m_Antds.size();
<FONT ID="LN">768 </FONT><A NAME="768"></A>      <FONT ID="If">if</FONT>(size == <FONT ID="IntegerLiteral">0</FONT>) <FONT ID="Return">return</FONT>; <FONT ID="SingleLineComment">// Default rule before pruning
<FONT ID="LN">769 </FONT><A NAME="769"></A></FONT>        
<FONT ID="LN">770 </FONT><A NAME="770"></A>      <FONT ID="Double">double</FONT>[] worthRt = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[size];
<FONT ID="LN">771 </FONT><A NAME="771"></A>      <FONT ID="Double">double</FONT>[] coverage = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[size];
<FONT ID="LN">772 </FONT><A NAME="772"></A>      <FONT ID="Double">double</FONT>[] worthValue = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[size];
<FONT ID="LN">773 </FONT><A NAME="773"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> w=<FONT ID="IntegerLiteral">0</FONT>; w&lt;size; w++){
<FONT ID="LN">774 </FONT><A NAME="774"></A>    worthRt[w]=coverage[w]=worthValue[w]=<FONT ID="FloatPointLiteral">0.0</FONT>;
<FONT ID="LN">775 </FONT><A NAME="775"></A>      }
<FONT ID="LN">776 </FONT><A NAME="776"></A>        
<FONT ID="LN">777 </FONT><A NAME="777"></A>      <FONT ID="MultiLineComment">/* Calculate accuracy parameters for all the antecedents in this rule */</FONT>
<FONT ID="LN">778 </FONT><A NAME="778"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> x=<FONT ID="IntegerLiteral">0</FONT>; x&lt;size; x++){
<FONT ID="LN">779 </FONT><A NAME="779"></A>    Antd antd=(Antd)m_Antds.elementAt(x);
<FONT ID="LN">780 </FONT><A NAME="780"></A>    <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> attr= antd.getAttr();
<FONT ID="LN">781 </FONT><A NAME="781"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A> newData = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data);
<FONT ID="LN">782 </FONT><A NAME="782"></A>    data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(newData, newData.numInstances()); <FONT ID="SingleLineComment">// Make data empty
<FONT ID="LN">783 </FONT><A NAME="783"></A></FONT>        
<FONT ID="LN">784 </FONT><A NAME="784"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> y=<FONT ID="IntegerLiteral">0</FONT>; y&lt;newData.numInstances(); y++){
<FONT ID="LN">785 </FONT><A NAME="785"></A>      <A HREF="../../../weka/core/Instance.java.html">Instance</A> ins=newData.instance(y);
<FONT ID="LN">786 </FONT><A NAME="786"></A>      <FONT ID="If">if</FONT>(!ins.isMissing(attr)){              <FONT ID="SingleLineComment">// Attribute not missing
<FONT ID="LN">787 </FONT><A NAME="787"></A></FONT>        <FONT ID="If">if</FONT>(antd.isCover(ins)){             <FONT ID="SingleLineComment">// Covered by this antecedent
<FONT ID="LN">788 </FONT><A NAME="788"></A></FONT>          coverage[x] += ins.weight();
<FONT ID="LN">789 </FONT><A NAME="789"></A>          data.add(ins);                 <FONT ID="SingleLineComment">// Add to data for further pruning
<FONT ID="LN">790 </FONT><A NAME="790"></A></FONT>          <FONT ID="If">if</FONT>(Utils.eq(ins.classValue(), m_Class)) <FONT ID="SingleLineComment">// Accurate prediction
<FONT ID="LN">791 </FONT><A NAME="791"></A></FONT>        worthValue[x] += ins.weight();
<FONT ID="LN">792 </FONT><A NAME="792"></A>        }
<FONT ID="LN">793 </FONT><A NAME="793"></A>      }
<FONT ID="LN">794 </FONT><A NAME="794"></A>    }
<FONT ID="LN">795 </FONT><A NAME="795"></A>        
<FONT ID="LN">796 </FONT><A NAME="796"></A>    <FONT ID="If">if</FONT>(coverage[x] != <FONT ID="IntegerLiteral">0</FONT>)  
<FONT ID="LN">797 </FONT><A NAME="797"></A>      worthRt[x] = worthValue[x]/coverage[x];
<FONT ID="LN">798 </FONT><A NAME="798"></A>      }
<FONT ID="LN">799 </FONT><A NAME="799"></A>        
<FONT ID="LN">800 </FONT><A NAME="800"></A>      <FONT ID="MultiLineComment">/* Prune the antecedents according to the accuracy parameters */</FONT>
<FONT ID="LN">801 </FONT><A NAME="801"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> z=(size-<FONT ID="IntegerLiteral">1</FONT>); z &gt; <FONT ID="IntegerLiteral">0</FONT>; z--)
<FONT ID="LN">802 </FONT><A NAME="802"></A>    <FONT ID="If">if</FONT>(Utils.sm(worthRt[z], worthRt[z-<FONT ID="IntegerLiteral">1</FONT>]))
<FONT ID="LN">803 </FONT><A NAME="803"></A>      m_Antds.removeElementAt(z);
<FONT ID="LN">804 </FONT><A NAME="804"></A>    <FONT ID="Else">else</FONT>  <FONT ID="Break">break</FONT>;
<FONT ID="LN">805 </FONT><A NAME="805"></A>        
<FONT ID="LN">806 </FONT><A NAME="806"></A>      <FONT ID="MultiLineComment">/* Check whether this rule is a default rule */</FONT>
<FONT ID="LN">807 </FONT><A NAME="807"></A>      <FONT ID="If">if</FONT>(m_Antds.size() == <FONT ID="IntegerLiteral">1</FONT>){
<FONT ID="LN">808 </FONT><A NAME="808"></A>    defAccu = computeDefAccu(pruneData);
<FONT ID="LN">809 </FONT><A NAME="809"></A>    defAccuRate = defAccu/total;                <FONT ID="SingleLineComment">// Compute def. accuracy
<FONT ID="LN">810 </FONT><A NAME="810"></A></FONT>    <FONT ID="If">if</FONT>(Utils.sm(worthRt[<FONT ID="IntegerLiteral">0</FONT>], defAccuRate)){      <FONT ID="SingleLineComment">// Becomes a default rule
<FONT ID="LN">811 </FONT><A NAME="811"></A></FONT>      m_Antds.removeAllElements();
<FONT ID="LN">812 </FONT><A NAME="812"></A>    }
<FONT ID="LN">813 </FONT><A NAME="813"></A>      }   
<FONT ID="LN">814 </FONT><A NAME="814"></A>        
<FONT ID="LN">815 </FONT><A NAME="815"></A>      <FONT ID="MultiLineComment">/* Update the worth parameters of this rule*/</FONT>
<FONT ID="LN">816 </FONT><A NAME="816"></A>      <FONT ID="Int">int</FONT> antdsSize = m_Antds.size();
<FONT ID="LN">817 </FONT><A NAME="817"></A>      <FONT ID="If">if</FONT>(antdsSize != <FONT ID="IntegerLiteral">0</FONT>){                          <FONT ID="SingleLineComment">// Not a default rule
<FONT ID="LN">818 </FONT><A NAME="818"></A></FONT>    m_Worth = worthValue[antdsSize-<FONT ID="IntegerLiteral">1</FONT>];       <FONT ID="SingleLineComment">// WorthValues of the last antecedent
<FONT ID="LN">819 </FONT><A NAME="819"></A></FONT>    m_WorthRate = worthRt[antdsSize-<FONT ID="IntegerLiteral">1</FONT>];
<FONT ID="LN">820 </FONT><A NAME="820"></A>    m_CoverP = coverage[antdsSize-<FONT ID="IntegerLiteral">1</FONT>];
<FONT ID="LN">821 </FONT><A NAME="821"></A>    Antd last = (Antd)m_Antds.lastElement();
<FONT ID="LN">822 </FONT><A NAME="822"></A>    m_CoverG = last.getCover();
<FONT ID="LN">823 </FONT><A NAME="823"></A>    m_AccuG = last.getAccu();
<FONT ID="LN">824 </FONT><A NAME="824"></A>      }
<FONT ID="LN">825 </FONT><A NAME="825"></A>      <FONT ID="Else">else</FONT>{                                        <FONT ID="SingleLineComment">// Default rule    
<FONT ID="LN">826 </FONT><A NAME="826"></A></FONT>    m_Worth = defAccu;                       <FONT ID="SingleLineComment">// Default WorthValues
<FONT ID="LN">827 </FONT><A NAME="827"></A></FONT>    m_WorthRate = defAccuRate;
<FONT ID="LN">828 </FONT><A NAME="828"></A>    m_CoverP = total;
<FONT ID="LN">829 </FONT><A NAME="829"></A>      }
<FONT ID="LN">830 </FONT><A NAME="830"></A>    }
<FONT ID="LN">831 </FONT><A NAME="831"></A>    
<FONT ID="LN">832 </FONT><A NAME="832"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">833 </FONT><A NAME="833"></A>     * Private function to compute default number of accurate instances
<FONT ID="LN">834 </FONT><A NAME="834"></A>     * in the specified data for m_Class
<FONT ID="LN">835 </FONT><A NAME="835"></A>     * 
<FONT ID="LN">836 </FONT><A NAME="836"></A>     * @param data the data in question
<FONT ID="LN">837 </FONT><A NAME="837"></A>     * @return the default accuracy number
<FONT ID="LN">838 </FONT><A NAME="838"></A>     */</FONT>
<FONT ID="LN">839 </FONT><A NAME="839"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> computeDefAccu(<A HREF="../../../weka/core/Instances.java.html">Instances</A> data){ 
<FONT ID="LN">840 </FONT><A NAME="840"></A>      <FONT ID="Double">double</FONT> defAccu=<FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">841 </FONT><A NAME="841"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i&lt;data.numInstances(); i++){
<FONT ID="LN">842 </FONT><A NAME="842"></A>    <A HREF="../../../weka/core/Instance.java.html">Instance</A> inst = data.instance(i);
<FONT ID="LN">843 </FONT><A NAME="843"></A>    <FONT ID="If">if</FONT>(Utils.eq(inst.classValue(), m_Class))
<FONT ID="LN">844 </FONT><A NAME="844"></A>      defAccu += inst.weight();
<FONT ID="LN">845 </FONT><A NAME="845"></A>      }
<FONT ID="LN">846 </FONT><A NAME="846"></A>      <FONT ID="Return">return</FONT> defAccu;
<FONT ID="LN">847 </FONT><A NAME="847"></A>    }
<FONT ID="LN">848 </FONT><A NAME="848"></A>    
<FONT ID="LN">849 </FONT><A NAME="849"></A>    <FONT ID="FormalComment">/** The following are get functions after prune() has set the value of worthRate and worth*/</FONT>
<FONT ID="LN">850 </FONT><A NAME="850"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getWorthRate(){ <FONT ID="Return">return</FONT> m_WorthRate; }
<FONT ID="LN">851 </FONT><A NAME="851"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getWorth(){ <FONT ID="Return">return</FONT> m_Worth; }
<FONT ID="LN">852 </FONT><A NAME="852"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getCoverP(){ <FONT ID="Return">return</FONT> m_CoverP; }
<FONT ID="LN">853 </FONT><A NAME="853"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getCoverG(){ <FONT ID="Return">return</FONT> m_CoverG; }
<FONT ID="LN">854 </FONT><A NAME="854"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getAccuG(){ <FONT ID="Return">return</FONT> m_AccuG; }
<FONT ID="LN">855 </FONT><A NAME="855"></A>
<FONT ID="LN">856 </FONT><A NAME="856"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">857 </FONT><A NAME="857"></A>     * Prints this rule with the specified class label
<FONT ID="LN">858 </FONT><A NAME="858"></A>     *
<FONT ID="LN">859 </FONT><A NAME="859"></A>     * @param att the string standing for attribute in the consequent of this rule
<FONT ID="LN">860 </FONT><A NAME="860"></A>     * @param cl the string standing for value in the consequent of this rule
<FONT ID="LN">861 </FONT><A NAME="861"></A>     * @return a textual description of this rule with the specified class label
<FONT ID="LN">862 </FONT><A NAME="862"></A>     */</FONT>
<FONT ID="LN">863 </FONT><A NAME="863"></A>    <FONT ID="Public">public</FONT> String toString(String att, String cl) {
<FONT ID="LN">864 </FONT><A NAME="864"></A>      StringBuffer text =  <FONT ID="New">new</FONT> StringBuffer();
<FONT ID="LN">865 </FONT><A NAME="865"></A>      <FONT ID="If">if</FONT>(m_Antds.size() &gt; <FONT ID="IntegerLiteral">0</FONT>){
<FONT ID="LN">866 </FONT><A NAME="866"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> j=<FONT ID="IntegerLiteral">0</FONT>; j&lt; (m_Antds.size()-<FONT ID="IntegerLiteral">1</FONT>); j++)
<FONT ID="LN">867 </FONT><A NAME="867"></A>      text.append(<FONT ID="StringLiteral">"("</FONT> + ((Antd)(m_Antds.elementAt(j))).toString()+ <FONT ID="StringLiteral">") and "</FONT>);
<FONT ID="LN">868 </FONT><A NAME="868"></A>    text.append(<FONT ID="StringLiteral">"("</FONT>+((Antd)(m_Antds.lastElement())).toString() + <FONT ID="StringLiteral">")"</FONT>);
<FONT ID="LN">869 </FONT><A NAME="869"></A>      }
<FONT ID="LN">870 </FONT><A NAME="870"></A>      text.append(<FONT ID="StringLiteral">" =&gt; "</FONT> + att + <FONT ID="StringLiteral">" = "</FONT> + cl);
<FONT ID="LN">871 </FONT><A NAME="871"></A>      text.append(<FONT ID="StringLiteral">"  ("</FONT>+m_CoverG+<FONT ID="StringLiteral">"/"</FONT>+(m_CoverG - m_AccuG)+<FONT ID="StringLiteral">") ["</FONT>+
<FONT ID="LN">872 </FONT><A NAME="872"></A>          m_CoverP+<FONT ID="StringLiteral">"/"</FONT>+(m_CoverP - m_Worth)+<FONT ID="StringLiteral">"]"</FONT>);
<FONT ID="LN">873 </FONT><A NAME="873"></A>      <FONT ID="Return">return</FONT> text.toString();
<FONT ID="LN">874 </FONT><A NAME="874"></A>    }
<FONT ID="LN">875 </FONT><A NAME="875"></A>    
<FONT ID="LN">876 </FONT><A NAME="876"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">877 </FONT><A NAME="877"></A>     * Prints this rule
<FONT ID="LN">878 </FONT><A NAME="878"></A>     *
<FONT ID="LN">879 </FONT><A NAME="879"></A>     * @return a textual description of this rule
<FONT ID="LN">880 </FONT><A NAME="880"></A>     */</FONT>
<FONT ID="LN">881 </FONT><A NAME="881"></A>    <FONT ID="Public">public</FONT> String toString() {
<FONT ID="LN">882 </FONT><A NAME="882"></A>      <FONT ID="Return">return</FONT> toString(m_ClassAttribute.name(), m_ClassAttribute.value((<FONT ID="Int">int</FONT>)m_Class));
<FONT ID="LN">883 </FONT><A NAME="883"></A>    }        
<FONT ID="LN">884 </FONT><A NAME="884"></A>    
<FONT ID="LN">885 </FONT><A NAME="885"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">886 </FONT><A NAME="886"></A>     * Returns the revision string.
<FONT ID="LN">887 </FONT><A NAME="887"></A>     * 
<FONT ID="LN">888 </FONT><A NAME="888"></A>     * @return      the revision
<FONT ID="LN">889 </FONT><A NAME="889"></A>     */</FONT>
<FONT ID="LN">890 </FONT><A NAME="890"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">891 </FONT><A NAME="891"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">892 </FONT><A NAME="892"></A>    }
<FONT ID="LN">893 </FONT><A NAME="893"></A>  }
<FONT ID="LN">894 </FONT><A NAME="894"></A>    
<FONT ID="LN">895 </FONT><A NAME="895"></A>    
<FONT ID="LN">896 </FONT><A NAME="896"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">897 </FONT><A NAME="897"></A>   * The single antecedent in the rule, which is composed of an attribute and 
<FONT ID="LN">898 </FONT><A NAME="898"></A>   * the corresponding value.  There are two inherited classes, namely NumericAntd
<FONT ID="LN">899 </FONT><A NAME="899"></A>   * and NominalAntd in which the attributes are numeric and nominal respectively.
<FONT ID="LN">900 </FONT><A NAME="900"></A>   */</FONT>
<FONT ID="LN">901 </FONT><A NAME="901"></A>  <FONT ID="Private">private</FONT> <FONT ID="Abstract">abstract</FONT> <FONT ID="Class">class</FONT> Antd 
<FONT ID="LN">902 </FONT><A NAME="902"></A>    <FONT ID="Implements">implements</FONT> Serializable, <A HREF="../../../weka/core/RevisionHandler.java.html">RevisionHandler</A> {
<FONT ID="LN">903 </FONT><A NAME="903"></A>
<FONT ID="LN">904 </FONT><A NAME="904"></A>    <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">905 </FONT><A NAME="905"></A>    <FONT ID="Private">private</FONT> <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = <FONT ID="IntegerLiteral">5317379013858933369L</FONT>;
<FONT ID="LN">906 </FONT><A NAME="906"></A>    
<FONT ID="LN">907 </FONT><A NAME="907"></A>    <FONT ID="FormalComment">/** The attribute of the antecedent */</FONT>
<FONT ID="LN">908 </FONT><A NAME="908"></A>    <FONT ID="Protected">protected</FONT> <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> att;
<FONT ID="LN">909 </FONT><A NAME="909"></A>    
<FONT ID="LN">910 </FONT><A NAME="910"></A>    <FONT ID="FormalComment">/** The attribute value of the antecedent.  
<FONT ID="LN">911 </FONT><A NAME="911"></A>       For numeric attribute, value is either 0(1st bag) or 1(2nd bag) */</FONT>
<FONT ID="LN">912 </FONT><A NAME="912"></A>    <FONT ID="Protected">protected</FONT> <FONT ID="Double">double</FONT> value; 
<FONT ID="LN">913 </FONT><A NAME="913"></A>    
<FONT ID="LN">914 </FONT><A NAME="914"></A>    <FONT ID="FormalComment">/** The maximum infoGain achieved by this antecedent test */</FONT>
<FONT ID="LN">915 </FONT><A NAME="915"></A>    <FONT ID="Protected">protected</FONT> <FONT ID="Double">double</FONT> maxInfoGain;
<FONT ID="LN">916 </FONT><A NAME="916"></A>    
<FONT ID="LN">917 </FONT><A NAME="917"></A>    <FONT ID="FormalComment">/** The accurate rate of this antecedent test on the growing data */</FONT>
<FONT ID="LN">918 </FONT><A NAME="918"></A>    <FONT ID="Protected">protected</FONT> <FONT ID="Double">double</FONT> accuRate;
<FONT ID="LN">919 </FONT><A NAME="919"></A>    
<FONT ID="LN">920 </FONT><A NAME="920"></A>    <FONT ID="FormalComment">/** The coverage of this antecedent */</FONT>
<FONT ID="LN">921 </FONT><A NAME="921"></A>    <FONT ID="Protected">protected</FONT> <FONT ID="Double">double</FONT> cover;
<FONT ID="LN">922 </FONT><A NAME="922"></A>    
<FONT ID="LN">923 </FONT><A NAME="923"></A>    <FONT ID="FormalComment">/** The accurate data for this antecedent */</FONT>
<FONT ID="LN">924 </FONT><A NAME="924"></A>    <FONT ID="Protected">protected</FONT> <FONT ID="Double">double</FONT> accu;
<FONT ID="LN">925 </FONT><A NAME="925"></A>    
<FONT ID="LN">926 </FONT><A NAME="926"></A>    <FONT ID="FormalComment">/** Constructor*/</FONT>
<FONT ID="LN">927 </FONT><A NAME="927"></A>    <FONT ID="Public">public</FONT> Antd(<A HREF="../../../weka/core/Attribute.java.html">Attribute</A> a){
<FONT ID="LN">928 </FONT><A NAME="928"></A>      att=a;
<FONT ID="LN">929 </FONT><A NAME="929"></A>      value=Double.NaN; 
<FONT ID="LN">930 </FONT><A NAME="930"></A>      maxInfoGain = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">931 </FONT><A NAME="931"></A>      accuRate = Double.NaN;
<FONT ID="LN">932 </FONT><A NAME="932"></A>      cover = Double.NaN;
<FONT ID="LN">933 </FONT><A NAME="933"></A>      accu = Double.NaN;
<FONT ID="LN">934 </FONT><A NAME="934"></A>    }
<FONT ID="LN">935 </FONT><A NAME="935"></A>    
<FONT ID="LN">936 </FONT><A NAME="936"></A>    <FONT ID="MultiLineComment">/* The abstract members for inheritance */</FONT>
<FONT ID="LN">937 </FONT><A NAME="937"></A>    <FONT ID="Public">public</FONT> <FONT ID="Abstract">abstract</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData(<A HREF="../../../weka/core/Instances.java.html">Instances</A> data, <FONT ID="Double">double</FONT> defAcRt, <FONT ID="Double">double</FONT> cla);
<FONT ID="LN">938 </FONT><A NAME="938"></A>    <FONT ID="Public">public</FONT> <FONT ID="Abstract">abstract</FONT> <FONT ID="Boolean">boolean</FONT> isCover(<A HREF="../../../weka/core/Instance.java.html">Instance</A> inst);
<FONT ID="LN">939 </FONT><A NAME="939"></A>    <FONT ID="Public">public</FONT> <FONT ID="Abstract">abstract</FONT> String toString();
<FONT ID="LN">940 </FONT><A NAME="940"></A>    
<FONT ID="LN">941 </FONT><A NAME="941"></A>    <FONT ID="MultiLineComment">/* Get functions of this antecedent */</FONT>
<FONT ID="LN">942 </FONT><A NAME="942"></A>    <FONT ID="Public">public</FONT> <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> getAttr(){ <FONT ID="Return">return</FONT> att; }
<FONT ID="LN">943 </FONT><A NAME="943"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getAttrValue(){ <FONT ID="Return">return</FONT> value; }
<FONT ID="LN">944 </FONT><A NAME="944"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getMaxInfoGain(){ <FONT ID="Return">return</FONT> maxInfoGain; }
<FONT ID="LN">945 </FONT><A NAME="945"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getAccuRate(){ <FONT ID="Return">return</FONT> accuRate; } 
<FONT ID="LN">946 </FONT><A NAME="946"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getAccu(){ <FONT ID="Return">return</FONT> accu; } 
<FONT ID="LN">947 </FONT><A NAME="947"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getCover(){ <FONT ID="Return">return</FONT> cover; } 
<FONT ID="LN">948 </FONT><A NAME="948"></A>    
<FONT ID="LN">949 </FONT><A NAME="949"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">950 </FONT><A NAME="950"></A>     * Returns the revision string.
<FONT ID="LN">951 </FONT><A NAME="951"></A>     * 
<FONT ID="LN">952 </FONT><A NAME="952"></A>     * @return      the revision
<FONT ID="LN">953 </FONT><A NAME="953"></A>     */</FONT>
<FONT ID="LN">954 </FONT><A NAME="954"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">955 </FONT><A NAME="955"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">956 </FONT><A NAME="956"></A>    }
<FONT ID="LN">957 </FONT><A NAME="957"></A>  }
<FONT ID="LN">958 </FONT><A NAME="958"></A>    
<FONT ID="LN">959 </FONT><A NAME="959"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">960 </FONT><A NAME="960"></A>   * The antecedent with numeric attribute
<FONT ID="LN">961 </FONT><A NAME="961"></A>   */</FONT>
<FONT ID="LN">962 </FONT><A NAME="962"></A>  <FONT ID="Private">private</FONT> <FONT ID="Class">class</FONT> NumericAntd 
<FONT ID="LN">963 </FONT><A NAME="963"></A>    <FONT ID="Extends">extends</FONT> Antd {
<FONT ID="LN">964 </FONT><A NAME="964"></A>    
<FONT ID="LN">965 </FONT><A NAME="965"></A>    <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">966 </FONT><A NAME="966"></A>    <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = <FONT ID="IntegerLiteral">1968761518014492214L</FONT>;
<FONT ID="LN">967 </FONT><A NAME="967"></A>    
<FONT ID="LN">968 </FONT><A NAME="968"></A>    <FONT ID="FormalComment">/** The split point for this numeric antecedent */</FONT>
<FONT ID="LN">969 </FONT><A NAME="969"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> splitPoint;
<FONT ID="LN">970 </FONT><A NAME="970"></A>    
<FONT ID="LN">971 </FONT><A NAME="971"></A>    <FONT ID="FormalComment">/** Constructor*/</FONT>
<FONT ID="LN">972 </FONT><A NAME="972"></A>    <FONT ID="Public">public</FONT> NumericAntd(<A HREF="../../../weka/core/Attribute.java.html">Attribute</A> a){ 
<FONT ID="LN">973 </FONT><A NAME="973"></A>      <FONT ID="Super">super</FONT>(a);
<FONT ID="LN">974 </FONT><A NAME="974"></A>      splitPoint = Double.NaN;
<FONT ID="LN">975 </FONT><A NAME="975"></A>    }    
<FONT ID="LN">976 </FONT><A NAME="976"></A>    
<FONT ID="LN">977 </FONT><A NAME="977"></A>    <FONT ID="FormalComment">/** Get split point of this numeric antecedent */</FONT>
<FONT ID="LN">978 </FONT><A NAME="978"></A>    <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getSplitPoint(){ <FONT ID="Return">return</FONT> splitPoint; }
<FONT ID="LN">979 </FONT><A NAME="979"></A>    
<FONT ID="LN">980 </FONT><A NAME="980"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">981 </FONT><A NAME="981"></A>     * Implements the splitData function.  
<FONT ID="LN">982 </FONT><A NAME="982"></A>     * This procedure is to split the data into two bags according 
<FONT ID="LN">983 </FONT><A NAME="983"></A>     * to the information gain of the numeric attribute value
<FONT ID="LN">984 </FONT><A NAME="984"></A>     * The maximum infoGain is also calculated.  
<FONT ID="LN">985 </FONT><A NAME="985"></A>     * 
<FONT ID="LN">986 </FONT><A NAME="986"></A>     * @param insts the data to be split
<FONT ID="LN">987 </FONT><A NAME="987"></A>     * @param defAcRt the default accuracy rate for data
<FONT ID="LN">988 </FONT><A NAME="988"></A>     * @param cl the class label to be predicted
<FONT ID="LN">989 </FONT><A NAME="989"></A>     * @return the array of data after split
<FONT ID="LN">990 </FONT><A NAME="990"></A>     */</FONT>
<FONT ID="LN">991 </FONT><A NAME="991"></A>    <FONT ID="Public">public</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData(<A HREF="../../../weka/core/Instances.java.html">Instances</A> insts, <FONT ID="Double">double</FONT> defAcRt, <FONT ID="Double">double</FONT> cl){
<FONT ID="LN">992 </FONT><A NAME="992"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(insts);
<FONT ID="LN">993 </FONT><A NAME="993"></A>      data.sort(att);
<FONT ID="LN">994 </FONT><A NAME="994"></A>      <FONT ID="Int">int</FONT> total=data.numInstances();<FONT ID="SingleLineComment">// Total number of instances without 
<FONT ID="LN">995 </FONT><A NAME="995"></A></FONT>      <FONT ID="SingleLineComment">// missing value for att
<FONT ID="LN">996 </FONT><A NAME="996"></A></FONT>        
<FONT ID="LN">997 </FONT><A NAME="997"></A>      <FONT ID="Int">int</FONT> split=<FONT ID="IntegerLiteral">1</FONT>;                  <FONT ID="SingleLineComment">// Current split position
<FONT ID="LN">998 </FONT><A NAME="998"></A></FONT>      <FONT ID="Int">int</FONT> prev=<FONT ID="IntegerLiteral">0</FONT>;                   <FONT ID="SingleLineComment">// Previous split position
<FONT ID="LN">999 </FONT><A NAME="999"></A></FONT>      <FONT ID="Int">int</FONT> finalSplit=split;         <FONT ID="SingleLineComment">// Final split position
<FONT ID="LN">1000</FONT><A NAME="1000"></A></FONT>      maxInfoGain = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1001</FONT><A NAME="1001"></A>      value = <FONT ID="IntegerLiteral">0</FONT>;    
<FONT ID="LN">1002</FONT><A NAME="1002"></A>
<FONT ID="LN">1003</FONT><A NAME="1003"></A>      <FONT ID="SingleLineComment">// Compute minimum number of Instances required in each split
<FONT ID="LN">1004</FONT><A NAME="1004"></A></FONT>      <FONT ID="Double">double</FONT> minSplit =  <FONT ID="FloatPointLiteral">0.1</FONT> * (data.sumOfWeights()) / <FONT ID="FloatPointLiteral">2.0</FONT>;
<FONT ID="LN">1005</FONT><A NAME="1005"></A>      <FONT ID="If">if</FONT> (Utils.smOrEq(minSplit,m_MinNo)) 
<FONT ID="LN">1006</FONT><A NAME="1006"></A>    minSplit = m_MinNo;
<FONT ID="LN">1007</FONT><A NAME="1007"></A>      <FONT ID="Else">else</FONT> <FONT ID="If">if</FONT> (Utils.gr(minSplit,<FONT ID="IntegerLiteral">25</FONT>)) 
<FONT ID="LN">1008</FONT><A NAME="1008"></A>    minSplit = <FONT ID="IntegerLiteral">25</FONT>;      
<FONT ID="LN">1009</FONT><A NAME="1009"></A>        
<FONT ID="LN">1010</FONT><A NAME="1010"></A>      <FONT ID="Double">double</FONT> fstCover=<FONT ID="IntegerLiteral">0</FONT>, sndCover=<FONT ID="IntegerLiteral">0</FONT>, fstAccu=<FONT ID="IntegerLiteral">0</FONT>, sndAccu=<FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1011</FONT><A NAME="1011"></A>        
<FONT ID="LN">1012</FONT><A NAME="1012"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> x=<FONT ID="IntegerLiteral">0</FONT>; x&lt;data.numInstances(); x++){
<FONT ID="LN">1013</FONT><A NAME="1013"></A>    <A HREF="../../../weka/core/Instance.java.html">Instance</A> inst = data.instance(x);
<FONT ID="LN">1014</FONT><A NAME="1014"></A>    <FONT ID="If">if</FONT>(inst.isMissing(att)){
<FONT ID="LN">1015</FONT><A NAME="1015"></A>      total = x;
<FONT ID="LN">1016</FONT><A NAME="1016"></A>      <FONT ID="Break">break</FONT>;
<FONT ID="LN">1017</FONT><A NAME="1017"></A>    }
<FONT ID="LN">1018</FONT><A NAME="1018"></A>        
<FONT ID="LN">1019</FONT><A NAME="1019"></A>    sndCover += inst.weight();
<FONT ID="LN">1020</FONT><A NAME="1020"></A>    <FONT ID="If">if</FONT>(Utils.eq(inst.classValue(), cl))
<FONT ID="LN">1021</FONT><A NAME="1021"></A>      sndAccu += inst.weight();
<FONT ID="LN">1022</FONT><A NAME="1022"></A>      }
<FONT ID="LN">1023</FONT><A NAME="1023"></A>        
<FONT ID="LN">1024</FONT><A NAME="1024"></A>      <FONT ID="SingleLineComment">// Enough Instances with known values?
<FONT ID="LN">1025</FONT><A NAME="1025"></A></FONT>      <FONT ID="If">if</FONT> (Utils.sm(sndCover,(<FONT ID="IntegerLiteral">2</FONT>*minSplit)))
<FONT ID="LN">1026</FONT><A NAME="1026"></A>    <FONT ID="Return">return</FONT> <FONT ID="Null">null</FONT>;
<FONT ID="LN">1027</FONT><A NAME="1027"></A>        
<FONT ID="LN">1028</FONT><A NAME="1028"></A>      <FONT ID="If">if</FONT>(total == <FONT ID="IntegerLiteral">0</FONT>) <FONT ID="Return">return</FONT> <FONT ID="Null">null</FONT>; <FONT ID="SingleLineComment">// Data all missing for the attribute     
<FONT ID="LN">1029</FONT><A NAME="1029"></A></FONT>      splitPoint = data.instance(total-<FONT ID="IntegerLiteral">1</FONT>).value(att);   
<FONT ID="LN">1030</FONT><A NAME="1030"></A>        
<FONT ID="LN">1031</FONT><A NAME="1031"></A>      <FONT ID="For">for</FONT>(; split &lt; total; split++){
<FONT ID="LN">1032</FONT><A NAME="1032"></A>    <FONT ID="If">if</FONT>(!Utils.eq(data.instance(split).value(att), 
<FONT ID="LN">1033</FONT><A NAME="1033"></A>             data.instance(prev).value(att))){ <FONT ID="SingleLineComment">// Can't split within same value
<FONT ID="LN">1034</FONT><A NAME="1034"></A></FONT>            
<FONT ID="LN">1035</FONT><A NAME="1035"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> y=prev; y&lt;split; y++){
<FONT ID="LN">1036</FONT><A NAME="1036"></A>        <A HREF="../../../weka/core/Instance.java.html">Instance</A> inst = data.instance(y);
<FONT ID="LN">1037</FONT><A NAME="1037"></A>        fstCover += inst.weight(); sndCover -= inst.weight(); 
<FONT ID="LN">1038</FONT><A NAME="1038"></A>        <FONT ID="If">if</FONT>(Utils.eq(data.instance(y).classValue(), cl)){
<FONT ID="LN">1039</FONT><A NAME="1039"></A>          fstAccu += inst.weight();  <FONT ID="SingleLineComment">// First bag positive# ++
<FONT ID="LN">1040</FONT><A NAME="1040"></A></FONT>          sndAccu -= inst.weight();  <FONT ID="SingleLineComment">// Second bag positive# --
<FONT ID="LN">1041</FONT><A NAME="1041"></A></FONT>        }                  
<FONT ID="LN">1042</FONT><A NAME="1042"></A>      }
<FONT ID="LN">1043</FONT><A NAME="1043"></A>            
<FONT ID="LN">1044</FONT><A NAME="1044"></A>      <FONT ID="If">if</FONT>(Utils.sm(fstCover, minSplit) || Utils.sm(sndCover, minSplit)){
<FONT ID="LN">1045</FONT><A NAME="1045"></A>        prev=split;  <FONT ID="SingleLineComment">// Cannot split because either
<FONT ID="LN">1046</FONT><A NAME="1046"></A></FONT>        <FONT ID="Continue">continue</FONT>;    <FONT ID="SingleLineComment">// split has not enough data
<FONT ID="LN">1047</FONT><A NAME="1047"></A></FONT>      }
<FONT ID="LN">1048</FONT><A NAME="1048"></A>            
<FONT ID="LN">1049</FONT><A NAME="1049"></A>      <FONT ID="Double">double</FONT> fstAccuRate = <FONT ID="IntegerLiteral">0</FONT>, sndAccuRate = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1050</FONT><A NAME="1050"></A>      <FONT ID="If">if</FONT>(!Utils.eq(fstCover,<FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">1051</FONT><A NAME="1051"></A>        fstAccuRate = fstAccu/fstCover;     
<FONT ID="LN">1052</FONT><A NAME="1052"></A>      <FONT ID="If">if</FONT>(!Utils.eq(sndCover,<FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">1053</FONT><A NAME="1053"></A>        sndAccuRate = sndAccu/sndCover;
<FONT ID="LN">1054</FONT><A NAME="1054"></A>            
<FONT ID="LN">1055</FONT><A NAME="1055"></A>      <FONT ID="MultiLineComment">/* Which bag has higher information gain? */</FONT>
<FONT ID="LN">1056</FONT><A NAME="1056"></A>      <FONT ID="Boolean">boolean</FONT> isFirst; 
<FONT ID="LN">1057</FONT><A NAME="1057"></A>      <FONT ID="Double">double</FONT> fstInfoGain, sndInfoGain;
<FONT ID="LN">1058</FONT><A NAME="1058"></A>      <FONT ID="Double">double</FONT> accRate, infoGain, coverage, accurate;
<FONT ID="LN">1059</FONT><A NAME="1059"></A>            
<FONT ID="LN">1060</FONT><A NAME="1060"></A>      fstInfoGain = Utils.eq(fstAccuRate, <FONT ID="IntegerLiteral">0</FONT>) ? 
<FONT ID="LN">1061</FONT><A NAME="1061"></A>        <FONT ID="IntegerLiteral">0</FONT> : (fstAccu*(Utils.log2(fstAccuRate) - Utils.log2(defAcRt)));
<FONT ID="LN">1062</FONT><A NAME="1062"></A>      sndInfoGain = Utils.eq(sndAccuRate, <FONT ID="IntegerLiteral">0</FONT>) ? 
<FONT ID="LN">1063</FONT><A NAME="1063"></A>        <FONT ID="IntegerLiteral">0</FONT> : (sndAccu*(Utils.log2(sndAccuRate) - Utils.log2(defAcRt)));
<FONT ID="LN">1064</FONT><A NAME="1064"></A>      <FONT ID="If">if</FONT>(Utils.gr(fstInfoGain,sndInfoGain) || 
<FONT ID="LN">1065</FONT><A NAME="1065"></A>         (Utils.eq(fstInfoGain,sndInfoGain)&amp;&amp;(Utils.grOrEq(fstAccuRate,sndAccuRate)))){
<FONT ID="LN">1066</FONT><A NAME="1066"></A>        isFirst = <FONT ID="True">true</FONT>;
<FONT ID="LN">1067</FONT><A NAME="1067"></A>        infoGain = fstInfoGain;
<FONT ID="LN">1068</FONT><A NAME="1068"></A>        accRate = fstAccuRate;
<FONT ID="LN">1069</FONT><A NAME="1069"></A>        accurate = fstAccu;
<FONT ID="LN">1070</FONT><A NAME="1070"></A>        coverage = fstCover;
<FONT ID="LN">1071</FONT><A NAME="1071"></A>      }
<FONT ID="LN">1072</FONT><A NAME="1072"></A>      <FONT ID="Else">else</FONT>{
<FONT ID="LN">1073</FONT><A NAME="1073"></A>        isFirst = <FONT ID="False">false</FONT>;
<FONT ID="LN">1074</FONT><A NAME="1074"></A>        infoGain = sndInfoGain;
<FONT ID="LN">1075</FONT><A NAME="1075"></A>        accRate = sndAccuRate;
<FONT ID="LN">1076</FONT><A NAME="1076"></A>        accurate = sndAccu;
<FONT ID="LN">1077</FONT><A NAME="1077"></A>        coverage = sndCover;
<FONT ID="LN">1078</FONT><A NAME="1078"></A>      }
<FONT ID="LN">1079</FONT><A NAME="1079"></A>            
<FONT ID="LN">1080</FONT><A NAME="1080"></A>      <FONT ID="Boolean">boolean</FONT> isUpdate = Utils.gr(infoGain, maxInfoGain);
<FONT ID="LN">1081</FONT><A NAME="1081"></A>            
<FONT ID="LN">1082</FONT><A NAME="1082"></A>      <FONT ID="MultiLineComment">/* Check whether so far the max infoGain */</FONT>
<FONT ID="LN">1083</FONT><A NAME="1083"></A>      <FONT ID="If">if</FONT>(isUpdate){
<FONT ID="LN">1084</FONT><A NAME="1084"></A>        splitPoint = (data.instance(split).value(att) + 
<FONT ID="LN">1085</FONT><A NAME="1085"></A>              data.instance(prev).value(att))/<FONT ID="IntegerLiteral">2</FONT>;
<FONT ID="LN">1086</FONT><A NAME="1086"></A>        value = ((isFirst) ? <FONT ID="IntegerLiteral">0</FONT> : <FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">1087</FONT><A NAME="1087"></A>        accuRate = accRate;
<FONT ID="LN">1088</FONT><A NAME="1088"></A>        accu = accurate;
<FONT ID="LN">1089</FONT><A NAME="1089"></A>        cover = coverage;
<FONT ID="LN">1090</FONT><A NAME="1090"></A>        maxInfoGain = infoGain;
<FONT ID="LN">1091</FONT><A NAME="1091"></A>        finalSplit = split;
<FONT ID="LN">1092</FONT><A NAME="1092"></A>      }
<FONT ID="LN">1093</FONT><A NAME="1093"></A>      prev=split;
<FONT ID="LN">1094</FONT><A NAME="1094"></A>    }
<FONT ID="LN">1095</FONT><A NAME="1095"></A>      }
<FONT ID="LN">1096</FONT><A NAME="1096"></A>        
<FONT ID="LN">1097</FONT><A NAME="1097"></A>      <FONT ID="MultiLineComment">/* Split the data */</FONT>
<FONT ID="LN">1098</FONT><A NAME="1098"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[<FONT ID="IntegerLiteral">2</FONT>];
<FONT ID="LN">1099</FONT><A NAME="1099"></A>      splitData[<FONT ID="IntegerLiteral">0</FONT>] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data, <FONT ID="IntegerLiteral">0</FONT>, finalSplit);
<FONT ID="LN">1100</FONT><A NAME="1100"></A>      splitData[<FONT ID="IntegerLiteral">1</FONT>] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data, finalSplit, total-finalSplit);
<FONT ID="LN">1101</FONT><A NAME="1101"></A>        
<FONT ID="LN">1102</FONT><A NAME="1102"></A>      <FONT ID="Return">return</FONT> splitData;
<FONT ID="LN">1103</FONT><A NAME="1103"></A>    }
<FONT ID="LN">1104</FONT><A NAME="1104"></A>    
<FONT ID="LN">1105</FONT><A NAME="1105"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1106</FONT><A NAME="1106"></A>     * Whether the instance is covered by this antecedent
<FONT ID="LN">1107</FONT><A NAME="1107"></A>     * 
<FONT ID="LN">1108</FONT><A NAME="1108"></A>     * @param inst the instance in question
<FONT ID="LN">1109</FONT><A NAME="1109"></A>     * @return the boolean value indicating whether the instance is covered 
<FONT ID="LN">1110</FONT><A NAME="1110"></A>     *         by this antecedent
<FONT ID="LN">1111</FONT><A NAME="1111"></A>     */</FONT>
<FONT ID="LN">1112</FONT><A NAME="1112"></A>    <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> isCover(<A HREF="../../../weka/core/Instance.java.html">Instance</A> inst){
<FONT ID="LN">1113</FONT><A NAME="1113"></A>      <FONT ID="Boolean">boolean</FONT> isCover=<FONT ID="False">false</FONT>;
<FONT ID="LN">1114</FONT><A NAME="1114"></A>      <FONT ID="If">if</FONT>(!inst.isMissing(att)){
<FONT ID="LN">1115</FONT><A NAME="1115"></A>    <FONT ID="If">if</FONT>(Utils.eq(value, <FONT ID="IntegerLiteral">0</FONT>)){
<FONT ID="LN">1116</FONT><A NAME="1116"></A>      <FONT ID="If">if</FONT>(Utils.smOrEq(inst.value(att), splitPoint))
<FONT ID="LN">1117</FONT><A NAME="1117"></A>        isCover=<FONT ID="True">true</FONT>;
<FONT ID="LN">1118</FONT><A NAME="1118"></A>    }
<FONT ID="LN">1119</FONT><A NAME="1119"></A>    <FONT ID="Else">else</FONT> <FONT ID="If">if</FONT>(Utils.gr(inst.value(att), splitPoint))
<FONT ID="LN">1120</FONT><A NAME="1120"></A>      isCover=<FONT ID="True">true</FONT>;
<FONT ID="LN">1121</FONT><A NAME="1121"></A>      }
<FONT ID="LN">1122</FONT><A NAME="1122"></A>      <FONT ID="Return">return</FONT> isCover;
<FONT ID="LN">1123</FONT><A NAME="1123"></A>    }
<FONT ID="LN">1124</FONT><A NAME="1124"></A>    
<FONT ID="LN">1125</FONT><A NAME="1125"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1126</FONT><A NAME="1126"></A>     * Prints this antecedent
<FONT ID="LN">1127</FONT><A NAME="1127"></A>     *
<FONT ID="LN">1128</FONT><A NAME="1128"></A>     * @return a textual description of this antecedent
<FONT ID="LN">1129</FONT><A NAME="1129"></A>     */</FONT>
<FONT ID="LN">1130</FONT><A NAME="1130"></A>    <FONT ID="Public">public</FONT> String toString() {
<FONT ID="LN">1131</FONT><A NAME="1131"></A>      String symbol = Utils.eq(value, <FONT ID="FloatPointLiteral">0.0</FONT>) ? <FONT ID="StringLiteral">" &lt;= "</FONT> : <FONT ID="StringLiteral">" &gt; "</FONT>;
<FONT ID="LN">1132</FONT><A NAME="1132"></A>      <FONT ID="Return">return</FONT> (att.name() + symbol + Utils.doubleToString(splitPoint, <FONT ID="IntegerLiteral">6</FONT>));
<FONT ID="LN">1133</FONT><A NAME="1133"></A>    }   
<FONT ID="LN">1134</FONT><A NAME="1134"></A>    
<FONT ID="LN">1135</FONT><A NAME="1135"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1136</FONT><A NAME="1136"></A>     * Returns the revision string.
<FONT ID="LN">1137</FONT><A NAME="1137"></A>     * 
<FONT ID="LN">1138</FONT><A NAME="1138"></A>     * @return      the revision
<FONT ID="LN">1139</FONT><A NAME="1139"></A>     */</FONT>
<FONT ID="LN">1140</FONT><A NAME="1140"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">1141</FONT><A NAME="1141"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">1142</FONT><A NAME="1142"></A>    }
<FONT ID="LN">1143</FONT><A NAME="1143"></A>  }
<FONT ID="LN">1144</FONT><A NAME="1144"></A>    
<FONT ID="LN">1145</FONT><A NAME="1145"></A>    
<FONT ID="LN">1146</FONT><A NAME="1146"></A>  <FONT ID="FormalComment">/** 
<FONT ID="LN">1147</FONT><A NAME="1147"></A>   * The antecedent with nominal attribute
<FONT ID="LN">1148</FONT><A NAME="1148"></A>   */</FONT>
<FONT ID="LN">1149</FONT><A NAME="1149"></A>  <FONT ID="Private">private</FONT> <FONT ID="Class">class</FONT> NominalAntd 
<FONT ID="LN">1150</FONT><A NAME="1150"></A>    <FONT ID="Extends">extends</FONT> Antd {
<FONT ID="LN">1151</FONT><A NAME="1151"></A>    
<FONT ID="LN">1152</FONT><A NAME="1152"></A>    <FONT ID="FormalComment">/** for serialization */</FONT>
<FONT ID="LN">1153</FONT><A NAME="1153"></A>    <FONT ID="Static">static</FONT> <FONT ID="Final">final</FONT> <FONT ID="Long">long</FONT> serialVersionUID = -<FONT ID="IntegerLiteral">256386137196078004L</FONT>;
<FONT ID="LN">1154</FONT><A NAME="1154"></A>    
<FONT ID="LN">1155</FONT><A NAME="1155"></A>    <FONT ID="MultiLineComment">/* The parameters of infoGain calculated for each attribute value */</FONT>
<FONT ID="LN">1156</FONT><A NAME="1156"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT>[] accurate;
<FONT ID="LN">1157</FONT><A NAME="1157"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT>[] coverage;
<FONT ID="LN">1158</FONT><A NAME="1158"></A>    <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT>[] infoGain;
<FONT ID="LN">1159</FONT><A NAME="1159"></A>    
<FONT ID="LN">1160</FONT><A NAME="1160"></A>    <FONT ID="FormalComment">/** Constructor*/</FONT>
<FONT ID="LN">1161</FONT><A NAME="1161"></A>    <FONT ID="Public">public</FONT> NominalAntd(<A HREF="../../../weka/core/Attribute.java.html">Attribute</A> a){ 
<FONT ID="LN">1162</FONT><A NAME="1162"></A>      <FONT ID="Super">super</FONT>(a);
<FONT ID="LN">1163</FONT><A NAME="1163"></A>      <FONT ID="Int">int</FONT> bag = att.numValues();
<FONT ID="LN">1164</FONT><A NAME="1164"></A>      accurate = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[bag];
<FONT ID="LN">1165</FONT><A NAME="1165"></A>      coverage = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[bag];
<FONT ID="LN">1166</FONT><A NAME="1166"></A>      infoGain = <FONT ID="New">new</FONT> <FONT ID="Double">double</FONT>[bag];
<FONT ID="LN">1167</FONT><A NAME="1167"></A>    }   
<FONT ID="LN">1168</FONT><A NAME="1168"></A>    
<FONT ID="LN">1169</FONT><A NAME="1169"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1170</FONT><A NAME="1170"></A>     * Implements the splitData function.  
<FONT ID="LN">1171</FONT><A NAME="1171"></A>     * This procedure is to split the data into bags according 
<FONT ID="LN">1172</FONT><A NAME="1172"></A>     * to the nominal attribute value
<FONT ID="LN">1173</FONT><A NAME="1173"></A>     * The infoGain for each bag is also calculated.  
<FONT ID="LN">1174</FONT><A NAME="1174"></A>     * 
<FONT ID="LN">1175</FONT><A NAME="1175"></A>     * @param data the data to be split
<FONT ID="LN">1176</FONT><A NAME="1176"></A>     * @param defAcRt the default accuracy rate for data
<FONT ID="LN">1177</FONT><A NAME="1177"></A>     * @param cl the class label to be predicted
<FONT ID="LN">1178</FONT><A NAME="1178"></A>     * @return the array of data after split
<FONT ID="LN">1179</FONT><A NAME="1179"></A>     */</FONT>
<FONT ID="LN">1180</FONT><A NAME="1180"></A>    <FONT ID="Public">public</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData(<A HREF="../../../weka/core/Instances.java.html">Instances</A> data, <FONT ID="Double">double</FONT> defAcRt, <FONT ID="Double">double</FONT> cl){
<FONT ID="LN">1181</FONT><A NAME="1181"></A>      <FONT ID="Int">int</FONT> bag = att.numValues();
<FONT ID="LN">1182</FONT><A NAME="1182"></A>      <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] splitData = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[bag];
<FONT ID="LN">1183</FONT><A NAME="1183"></A>        
<FONT ID="LN">1184</FONT><A NAME="1184"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> x=<FONT ID="IntegerLiteral">0</FONT>; x&lt;bag; x++){
<FONT ID="LN">1185</FONT><A NAME="1185"></A>    accurate[x] = coverage[x] = infoGain[x] = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1186</FONT><A NAME="1186"></A>    splitData[x] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data, data.numInstances());
<FONT ID="LN">1187</FONT><A NAME="1187"></A>      }
<FONT ID="LN">1188</FONT><A NAME="1188"></A>        
<FONT ID="LN">1189</FONT><A NAME="1189"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> x=<FONT ID="IntegerLiteral">0</FONT>; x&lt;data.numInstances(); x++){
<FONT ID="LN">1190</FONT><A NAME="1190"></A>    <A HREF="../../../weka/core/Instance.java.html">Instance</A> inst=data.instance(x);
<FONT ID="LN">1191</FONT><A NAME="1191"></A>    <FONT ID="If">if</FONT>(!inst.isMissing(att)){
<FONT ID="LN">1192</FONT><A NAME="1192"></A>      <FONT ID="Int">int</FONT> v = (<FONT ID="Int">int</FONT>)inst.value(att);
<FONT ID="LN">1193</FONT><A NAME="1193"></A>      splitData[v].add(inst);
<FONT ID="LN">1194</FONT><A NAME="1194"></A>      coverage[v] += inst.weight();
<FONT ID="LN">1195</FONT><A NAME="1195"></A>      <FONT ID="If">if</FONT>(Utils.eq(inst.classValue(), cl))
<FONT ID="LN">1196</FONT><A NAME="1196"></A>        accurate[v] += inst.weight();
<FONT ID="LN">1197</FONT><A NAME="1197"></A>    }
<FONT ID="LN">1198</FONT><A NAME="1198"></A>      }
<FONT ID="LN">1199</FONT><A NAME="1199"></A>        
<FONT ID="LN">1200</FONT><A NAME="1200"></A>      <FONT ID="SingleLineComment">// Check if &gt;=2 splits have more than the minimal data
<FONT ID="LN">1201</FONT><A NAME="1201"></A></FONT>      <FONT ID="Int">int</FONT> count=<FONT ID="IntegerLiteral">0</FONT>; 
<FONT ID="LN">1202</FONT><A NAME="1202"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> x=<FONT ID="IntegerLiteral">0</FONT>; x&lt;bag; x++){
<FONT ID="LN">1203</FONT><A NAME="1203"></A>    <FONT ID="Double">double</FONT> t = coverage[x];
<FONT ID="LN">1204</FONT><A NAME="1204"></A>    <FONT ID="If">if</FONT>(Utils.grOrEq(t, m_MinNo)){
<FONT ID="LN">1205</FONT><A NAME="1205"></A>      <FONT ID="Double">double</FONT> p = accurate[x];       
<FONT ID="LN">1206</FONT><A NAME="1206"></A>            
<FONT ID="LN">1207</FONT><A NAME="1207"></A>      <FONT ID="If">if</FONT>(!Utils.eq(t, <FONT ID="FloatPointLiteral">0.0</FONT>))
<FONT ID="LN">1208</FONT><A NAME="1208"></A>        infoGain[x] = p *((Utils.log2(p/t)) - (Utils.log2(defAcRt)));
<FONT ID="LN">1209</FONT><A NAME="1209"></A>      ++count;
<FONT ID="LN">1210</FONT><A NAME="1210"></A>    }
<FONT ID="LN">1211</FONT><A NAME="1211"></A>      }
<FONT ID="LN">1212</FONT><A NAME="1212"></A>            
<FONT ID="LN">1213</FONT><A NAME="1213"></A>      <FONT ID="If">if</FONT>(count &lt; <FONT ID="IntegerLiteral">2</FONT>) <FONT ID="SingleLineComment">// Don't split
<FONT ID="LN">1214</FONT><A NAME="1214"></A></FONT>    <FONT ID="Return">return</FONT> <FONT ID="Null">null</FONT>;
<FONT ID="LN">1215</FONT><A NAME="1215"></A>        
<FONT ID="LN">1216</FONT><A NAME="1216"></A>      value = (<FONT ID="Double">double</FONT>)Utils.maxIndex(infoGain);
<FONT ID="LN">1217</FONT><A NAME="1217"></A>        
<FONT ID="LN">1218</FONT><A NAME="1218"></A>      cover = coverage[(<FONT ID="Int">int</FONT>)value];
<FONT ID="LN">1219</FONT><A NAME="1219"></A>      accu = accurate[(<FONT ID="Int">int</FONT>)value];
<FONT ID="LN">1220</FONT><A NAME="1220"></A>        
<FONT ID="LN">1221</FONT><A NAME="1221"></A>      <FONT ID="If">if</FONT>(!Utils.eq(cover,<FONT ID="IntegerLiteral">0</FONT>))
<FONT ID="LN">1222</FONT><A NAME="1222"></A>    accuRate = accu / cover;
<FONT ID="LN">1223</FONT><A NAME="1223"></A>      <FONT ID="Else">else</FONT> accuRate = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1224</FONT><A NAME="1224"></A>        
<FONT ID="LN">1225</FONT><A NAME="1225"></A>      maxInfoGain = infoGain [(<FONT ID="Int">int</FONT>)value];
<FONT ID="LN">1226</FONT><A NAME="1226"></A>        
<FONT ID="LN">1227</FONT><A NAME="1227"></A>      <FONT ID="Return">return</FONT> splitData;
<FONT ID="LN">1228</FONT><A NAME="1228"></A>    }
<FONT ID="LN">1229</FONT><A NAME="1229"></A>    
<FONT ID="LN">1230</FONT><A NAME="1230"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1231</FONT><A NAME="1231"></A>     * Whether the instance is covered by this antecedent
<FONT ID="LN">1232</FONT><A NAME="1232"></A>     * 
<FONT ID="LN">1233</FONT><A NAME="1233"></A>     * @param inst the instance in question
<FONT ID="LN">1234</FONT><A NAME="1234"></A>     * @return the boolean value indicating whether the instance is covered 
<FONT ID="LN">1235</FONT><A NAME="1235"></A>     *         by this antecedent
<FONT ID="LN">1236</FONT><A NAME="1236"></A>     */</FONT>
<FONT ID="LN">1237</FONT><A NAME="1237"></A>    <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> isCover(<A HREF="../../../weka/core/Instance.java.html">Instance</A> inst){
<FONT ID="LN">1238</FONT><A NAME="1238"></A>      <FONT ID="Boolean">boolean</FONT> isCover=<FONT ID="False">false</FONT>;
<FONT ID="LN">1239</FONT><A NAME="1239"></A>      <FONT ID="If">if</FONT>(!inst.isMissing(att)){
<FONT ID="LN">1240</FONT><A NAME="1240"></A>    <FONT ID="If">if</FONT>(Utils.eq(inst.value(att), value))
<FONT ID="LN">1241</FONT><A NAME="1241"></A>      isCover=<FONT ID="True">true</FONT>;     
<FONT ID="LN">1242</FONT><A NAME="1242"></A>      }
<FONT ID="LN">1243</FONT><A NAME="1243"></A>      <FONT ID="Return">return</FONT> isCover;
<FONT ID="LN">1244</FONT><A NAME="1244"></A>    }
<FONT ID="LN">1245</FONT><A NAME="1245"></A>    
<FONT ID="LN">1246</FONT><A NAME="1246"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1247</FONT><A NAME="1247"></A>     * Prints this antecedent
<FONT ID="LN">1248</FONT><A NAME="1248"></A>     *
<FONT ID="LN">1249</FONT><A NAME="1249"></A>     * @return a textual description of this antecedent
<FONT ID="LN">1250</FONT><A NAME="1250"></A>     */</FONT>
<FONT ID="LN">1251</FONT><A NAME="1251"></A>    <FONT ID="Public">public</FONT> String toString() {
<FONT ID="LN">1252</FONT><A NAME="1252"></A>      <FONT ID="Return">return</FONT> (att.name() + <FONT ID="StringLiteral">" = "</FONT> +att.value((<FONT ID="Int">int</FONT>)value));
<FONT ID="LN">1253</FONT><A NAME="1253"></A>    } 
<FONT ID="LN">1254</FONT><A NAME="1254"></A>    
<FONT ID="LN">1255</FONT><A NAME="1255"></A>    <FONT ID="FormalComment">/**
<FONT ID="LN">1256</FONT><A NAME="1256"></A>     * Returns the revision string.
<FONT ID="LN">1257</FONT><A NAME="1257"></A>     * 
<FONT ID="LN">1258</FONT><A NAME="1258"></A>     * @return      the revision
<FONT ID="LN">1259</FONT><A NAME="1259"></A>     */</FONT>
<FONT ID="LN">1260</FONT><A NAME="1260"></A>    <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">1261</FONT><A NAME="1261"></A>      <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">1262</FONT><A NAME="1262"></A>    }
<FONT ID="LN">1263</FONT><A NAME="1263"></A>  }
<FONT ID="LN">1264</FONT><A NAME="1264"></A>
<FONT ID="LN">1265</FONT><A NAME="1265"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1266</FONT><A NAME="1266"></A>   * Returns default capabilities of the classifier.
<FONT ID="LN">1267</FONT><A NAME="1267"></A>   *
<FONT ID="LN">1268</FONT><A NAME="1268"></A>   * @return      the capabilities of this classifier
<FONT ID="LN">1269</FONT><A NAME="1269"></A>   */</FONT>
<FONT ID="LN">1270</FONT><A NAME="1270"></A>  <FONT ID="Public">public</FONT> <A HREF="../../../weka/core/Capabilities.java.html">Capabilities</A> getCapabilities() {
<FONT ID="LN">1271</FONT><A NAME="1271"></A>    <A HREF="../../../weka/core/Capabilities.java.html">Capabilities</A> result = <FONT ID="Super">super</FONT>.getCapabilities();
<FONT ID="LN">1272</FONT><A NAME="1272"></A>    result.disableAll();
<FONT ID="LN">1273</FONT><A NAME="1273"></A>
<FONT ID="LN">1274</FONT><A NAME="1274"></A>    <FONT ID="SingleLineComment">// attributes
<FONT ID="LN">1275</FONT><A NAME="1275"></A></FONT>    result.enable(Capability.NOMINAL_ATTRIBUTES);
<FONT ID="LN">1276</FONT><A NAME="1276"></A>    result.enable(Capability.NUMERIC_ATTRIBUTES);
<FONT ID="LN">1277</FONT><A NAME="1277"></A>    result.enable(Capability.DATE_ATTRIBUTES);
<FONT ID="LN">1278</FONT><A NAME="1278"></A>    result.enable(Capability.MISSING_VALUES);
<FONT ID="LN">1279</FONT><A NAME="1279"></A>
<FONT ID="LN">1280</FONT><A NAME="1280"></A>    <FONT ID="SingleLineComment">// class
<FONT ID="LN">1281</FONT><A NAME="1281"></A></FONT>    result.enable(Capability.NOMINAL_CLASS);
<FONT ID="LN">1282</FONT><A NAME="1282"></A>    result.enable(Capability.MISSING_CLASS_VALUES);
<FONT ID="LN">1283</FONT><A NAME="1283"></A>    
<FONT ID="LN">1284</FONT><A NAME="1284"></A>    <FONT ID="Return">return</FONT> result;
<FONT ID="LN">1285</FONT><A NAME="1285"></A>  }
<FONT ID="LN">1286</FONT><A NAME="1286"></A>
<FONT ID="LN">1287</FONT><A NAME="1287"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1288</FONT><A NAME="1288"></A>   * Builds a ripple-down manner rule learner.
<FONT ID="LN">1289</FONT><A NAME="1289"></A>   *
<FONT ID="LN">1290</FONT><A NAME="1290"></A>   * @param instances the training data
<FONT ID="LN">1291</FONT><A NAME="1291"></A>   * @throws Exception if classifier can't be built successfully
<FONT ID="LN">1292</FONT><A NAME="1292"></A>   */</FONT>
<FONT ID="LN">1293</FONT><A NAME="1293"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> buildClassifier(<A HREF="../../../weka/core/Instances.java.html">Instances</A> instances) <FONT ID="Throws">throws</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A> {
<FONT ID="LN">1294</FONT><A NAME="1294"></A>
<FONT ID="LN">1295</FONT><A NAME="1295"></A>    <FONT ID="SingleLineComment">// can classifier handle the data?
<FONT ID="LN">1296</FONT><A NAME="1296"></A></FONT>    getCapabilities().testWithFail(instances);
<FONT ID="LN">1297</FONT><A NAME="1297"></A>
<FONT ID="LN">1298</FONT><A NAME="1298"></A>    <FONT ID="SingleLineComment">// remove instances with missing class
<FONT ID="LN">1299</FONT><A NAME="1299"></A></FONT>    <A HREF="../../../weka/core/Instances.java.html">Instances</A> data = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(instances);
<FONT ID="LN">1300</FONT><A NAME="1300"></A>    data.deleteWithMissingClass();
<FONT ID="LN">1301</FONT><A NAME="1301"></A>    
<FONT ID="LN">1302</FONT><A NAME="1302"></A>    <FONT ID="Int">int</FONT> numCl = data.numClasses();
<FONT ID="LN">1303</FONT><A NAME="1303"></A>    m_Root = <FONT ID="New">new</FONT> Ridor_node();
<FONT ID="LN">1304</FONT><A NAME="1304"></A>    m_Class = instances.classAttribute();     <FONT ID="SingleLineComment">// The original class label
<FONT ID="LN">1305</FONT><A NAME="1305"></A></FONT>    
<FONT ID="LN">1306</FONT><A NAME="1306"></A>    <FONT ID="Int">int</FONT> index = data.classIndex();
<FONT ID="LN">1307</FONT><A NAME="1307"></A>    m_Cover = data.sumOfWeights();
<FONT ID="LN">1308</FONT><A NAME="1308"></A>    
<FONT ID="LN">1309</FONT><A NAME="1309"></A>    m_Random = <FONT ID="New">new</FONT> Random(m_Seed);
<FONT ID="LN">1310</FONT><A NAME="1310"></A>    
<FONT ID="LN">1311</FONT><A NAME="1311"></A>    <FONT ID="MultiLineComment">/* Create a binary attribute */</FONT>
<FONT ID="LN">1312</FONT><A NAME="1312"></A>    <A HREF="../../../weka/core/FastVector.java.html">FastVector</A> binary_values = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">FastVector</A>(<FONT ID="IntegerLiteral">2</FONT>);
<FONT ID="LN">1313</FONT><A NAME="1313"></A>    binary_values.addElement(<FONT ID="StringLiteral">"otherClasses"</FONT>);
<FONT ID="LN">1314</FONT><A NAME="1314"></A>    binary_values.addElement(<FONT ID="StringLiteral">"defClass"</FONT>);
<FONT ID="LN">1315</FONT><A NAME="1315"></A>    <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> attr = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Attribute.java.html">Attribute</A> (<FONT ID="StringLiteral">"newClass"</FONT>, binary_values);
<FONT ID="LN">1316</FONT><A NAME="1316"></A>    data.insertAttributeAt(attr, index);    
<FONT ID="LN">1317</FONT><A NAME="1317"></A>    data.setClassIndex(index);                 <FONT ID="SingleLineComment">// The new class label
<FONT ID="LN">1318</FONT><A NAME="1318"></A></FONT>
<FONT ID="LN">1319</FONT><A NAME="1319"></A>    <FONT ID="MultiLineComment">/* Partition the data into bags according to their original class values */</FONT>
<FONT ID="LN">1320</FONT><A NAME="1320"></A>    <A HREF="../../../weka/core/Instances.java.html">Instances</A>[] dataByClass = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>[numCl];
<FONT ID="LN">1321</FONT><A NAME="1321"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; numCl; i++)
<FONT ID="LN">1322</FONT><A NAME="1322"></A>      dataByClass[i] = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/Instances.java.html">Instances</A>(data, data.numInstances()); <FONT ID="SingleLineComment">// Empty bags
<FONT ID="LN">1323</FONT><A NAME="1323"></A></FONT>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; data.numInstances(); i++){ <FONT ID="SingleLineComment">// Partitioning
<FONT ID="LN">1324</FONT><A NAME="1324"></A></FONT>      <A HREF="../../../weka/core/Instance.java.html">Instance</A> inst = data.instance(i);
<FONT ID="LN">1325</FONT><A NAME="1325"></A>      inst.setClassValue(<FONT ID="IntegerLiteral">0</FONT>);           <FONT ID="SingleLineComment">// Set new class vaue to be 0
<FONT ID="LN">1326</FONT><A NAME="1326"></A></FONT>      dataByClass[(<FONT ID="Int">int</FONT>)inst.value(index+<FONT ID="IntegerLiteral">1</FONT>)].add(inst); 
<FONT ID="LN">1327</FONT><A NAME="1327"></A>    }   
<FONT ID="LN">1328</FONT><A NAME="1328"></A>    
<FONT ID="LN">1329</FONT><A NAME="1329"></A>    <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; numCl; i++)    
<FONT ID="LN">1330</FONT><A NAME="1330"></A>      dataByClass[i].deleteAttributeAt(index+<FONT ID="IntegerLiteral">1</FONT>);   <FONT ID="SingleLineComment">// Delete original class
<FONT ID="LN">1331</FONT><A NAME="1331"></A></FONT>    
<FONT ID="LN">1332</FONT><A NAME="1332"></A>    m_Root.findRules(dataByClass, <FONT ID="IntegerLiteral">0</FONT>);
<FONT ID="LN">1333</FONT><A NAME="1333"></A>    
<FONT ID="LN">1334</FONT><A NAME="1334"></A>  }
<FONT ID="LN">1335</FONT><A NAME="1335"></A>    
<FONT ID="LN">1336</FONT><A NAME="1336"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1337</FONT><A NAME="1337"></A>   * Classify the test instance with the rule learner 
<FONT ID="LN">1338</FONT><A NAME="1338"></A>   *
<FONT ID="LN">1339</FONT><A NAME="1339"></A>   * @param datum the instance to be classified
<FONT ID="LN">1340</FONT><A NAME="1340"></A>   * @return the classification
<FONT ID="LN">1341</FONT><A NAME="1341"></A>   */</FONT>
<FONT ID="LN">1342</FONT><A NAME="1342"></A>  <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> classifyInstance(<A HREF="../../../weka/core/Instance.java.html">Instance</A> datum){
<FONT ID="LN">1343</FONT><A NAME="1343"></A>    <FONT ID="Return">return</FONT> classify(m_Root, datum);
<FONT ID="LN">1344</FONT><A NAME="1344"></A>  }
<FONT ID="LN">1345</FONT><A NAME="1345"></A>    
<FONT ID="LN">1346</FONT><A NAME="1346"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1347</FONT><A NAME="1347"></A>   * Classify the test instance with one node of Ridor 
<FONT ID="LN">1348</FONT><A NAME="1348"></A>   *
<FONT ID="LN">1349</FONT><A NAME="1349"></A>   * @param node the node of Ridor to classify the test instance
<FONT ID="LN">1350</FONT><A NAME="1350"></A>   * @param datum the instance to be classified
<FONT ID="LN">1351</FONT><A NAME="1351"></A>   * @return the classification
<FONT ID="LN">1352</FONT><A NAME="1352"></A>   */</FONT>
<FONT ID="LN">1353</FONT><A NAME="1353"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> classify(Ridor_node node, <A HREF="../../../weka/core/Instance.java.html">Instance</A> datum){
<FONT ID="LN">1354</FONT><A NAME="1354"></A>    <FONT ID="Double">double</FONT> classValue = node.getDefClass();
<FONT ID="LN">1355</FONT><A NAME="1355"></A>    RidorRule[] rules = node.getRules();
<FONT ID="LN">1356</FONT><A NAME="1356"></A>
<FONT ID="LN">1357</FONT><A NAME="1357"></A>    <FONT ID="If">if</FONT>(rules != <FONT ID="Null">null</FONT>){
<FONT ID="LN">1358</FONT><A NAME="1358"></A>      Ridor_node[] excepts = node.getExcepts(); 
<FONT ID="LN">1359</FONT><A NAME="1359"></A>      <FONT ID="For">for</FONT>(<FONT ID="Int">int</FONT> i=<FONT ID="IntegerLiteral">0</FONT>; i &lt; excepts.length; i++){
<FONT ID="LN">1360</FONT><A NAME="1360"></A>    <FONT ID="If">if</FONT>(rules[i].isCover(datum)){
<FONT ID="LN">1361</FONT><A NAME="1361"></A>      classValue = classify(excepts[i], datum);
<FONT ID="LN">1362</FONT><A NAME="1362"></A>      <FONT ID="Break">break</FONT>;
<FONT ID="LN">1363</FONT><A NAME="1363"></A>    }
<FONT ID="LN">1364</FONT><A NAME="1364"></A>      }
<FONT ID="LN">1365</FONT><A NAME="1365"></A>    }
<FONT ID="LN">1366</FONT><A NAME="1366"></A>    
<FONT ID="LN">1367</FONT><A NAME="1367"></A>    <FONT ID="Return">return</FONT> classValue;
<FONT ID="LN">1368</FONT><A NAME="1368"></A>  }
<FONT ID="LN">1369</FONT><A NAME="1369"></A>
<FONT ID="LN">1370</FONT><A NAME="1370"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1371</FONT><A NAME="1371"></A>   * Returns an enumeration describing the available options
<FONT ID="LN">1372</FONT><A NAME="1372"></A>   * Valid options are: &lt;p&gt;
<FONT ID="LN">1373</FONT><A NAME="1373"></A>   *
<FONT ID="LN">1374</FONT><A NAME="1374"></A>   * -F number &lt;br&gt;
<FONT ID="LN">1375</FONT><A NAME="1375"></A>   * Set number of folds for reduced error pruning. One fold is
<FONT ID="LN">1376</FONT><A NAME="1376"></A>   * used as the pruning set. (Default: 3) &lt;p&gt;
<FONT ID="LN">1377</FONT><A NAME="1377"></A>   *
<FONT ID="LN">1378</FONT><A NAME="1378"></A>   * -S number &lt;br&gt;
<FONT ID="LN">1379</FONT><A NAME="1379"></A>   * Set number of shuffles for randomization. (Default: 10) &lt;p&gt;
<FONT ID="LN">1380</FONT><A NAME="1380"></A>   * 
<FONT ID="LN">1381</FONT><A NAME="1381"></A>   * -A &lt;br&gt;
<FONT ID="LN">1382</FONT><A NAME="1382"></A>   * Set flag of whether use the error rate of all the data to select
<FONT ID="LN">1383</FONT><A NAME="1383"></A>   * the default class in each step. If not set, the learner will only use
<FONT ID="LN">1384</FONT><A NAME="1384"></A>   * the error rate in the pruning data &lt;p&gt;
<FONT ID="LN">1385</FONT><A NAME="1385"></A>   *
<FONT ID="LN">1386</FONT><A NAME="1386"></A>   * -M &lt;br&gt;
<FONT ID="LN">1387</FONT><A NAME="1387"></A>   * Set flag of whether use the majority class as the default class
<FONT ID="LN">1388</FONT><A NAME="1388"></A>   * in each step instead of choosing default class based on the error rate
<FONT ID="LN">1389</FONT><A NAME="1389"></A>   * (if the flag is not set) &lt;p&gt;  
<FONT ID="LN">1390</FONT><A NAME="1390"></A>   * 
<FONT ID="LN">1391</FONT><A NAME="1391"></A>   * -N number &lt;br&gt;
<FONT ID="LN">1392</FONT><A NAME="1392"></A>   * Set the minimal weights of instances within a split.
<FONT ID="LN">1393</FONT><A NAME="1393"></A>   * (Default: 2) &lt;p&gt;
<FONT ID="LN">1394</FONT><A NAME="1394"></A>   *    
<FONT ID="LN">1395</FONT><A NAME="1395"></A>   * @return an enumeration of all the available options
<FONT ID="LN">1396</FONT><A NAME="1396"></A>   */</FONT>
<FONT ID="LN">1397</FONT><A NAME="1397"></A>  <FONT ID="Public">public</FONT> Enumeration listOptions() {
<FONT ID="LN">1398</FONT><A NAME="1398"></A>    <A HREF="../../../weka/core/FastVector.java.html">Vector</A> newVector = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">Vector</A>(<FONT ID="IntegerLiteral">5</FONT>);
<FONT ID="LN">1399</FONT><A NAME="1399"></A>    
<FONT ID="LN">1400</FONT><A NAME="1400"></A>    newVector.addElement(<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Option.java.html">Option</A>(<FONT ID="StringLiteral">"\tSet number of folds for IREP\n"</FONT> +
<FONT ID="LN">1401</FONT><A NAME="1401"></A>                    <FONT ID="StringLiteral">"\tOne fold is used as pruning set.\n"</FONT> +
<FONT ID="LN">1402</FONT><A NAME="1402"></A>                    <FONT ID="StringLiteral">"\t(default 3)"</FONT>,<FONT ID="StringLiteral">"F"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-F &lt;number of folds&gt;"</FONT>));
<FONT ID="LN">1403</FONT><A NAME="1403"></A>    newVector.addElement(<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Option.java.html">Option</A>(<FONT ID="StringLiteral">"\tSet number of shuffles to randomize\n"</FONT> +
<FONT ID="LN">1404</FONT><A NAME="1404"></A>                    <FONT ID="StringLiteral">"\tthe data in order to get better rule.\n"</FONT> +
<FONT ID="LN">1405</FONT><A NAME="1405"></A>                    <FONT ID="StringLiteral">"\t(default 1)"</FONT>,<FONT ID="StringLiteral">"S"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-S &lt;number of shuffles&gt;"</FONT>));
<FONT ID="LN">1406</FONT><A NAME="1406"></A>    newVector.addElement(<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Option.java.html">Option</A>(<FONT ID="StringLiteral">"\tSet flag of whether use the error rate \n"</FONT>+
<FONT ID="LN">1407</FONT><A NAME="1407"></A>                    <FONT ID="StringLiteral">"\tof all the data to select the default class\n"</FONT>+
<FONT ID="LN">1408</FONT><A NAME="1408"></A>                    <FONT ID="StringLiteral">"\tin each step. If not set, the learner will only use"</FONT>+
<FONT ID="LN">1409</FONT><A NAME="1409"></A>                    <FONT ID="StringLiteral">"\tthe error rate in the pruning data"</FONT>,<FONT ID="StringLiteral">"A"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-A"</FONT>));
<FONT ID="LN">1410</FONT><A NAME="1410"></A>    newVector.addElement(<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Option.java.html">Option</A>(<FONT ID="StringLiteral">"\t Set flag of whether use the majority class as\n"</FONT>+
<FONT ID="LN">1411</FONT><A NAME="1411"></A>                    <FONT ID="StringLiteral">"\tthe default class in each step instead of \n"</FONT>+
<FONT ID="LN">1412</FONT><A NAME="1412"></A>                    <FONT ID="StringLiteral">"\tchoosing default class based on the error rate\n"</FONT>+
<FONT ID="LN">1413</FONT><A NAME="1413"></A>                    <FONT ID="StringLiteral">"\t(if the flag is not set)"</FONT>,<FONT ID="StringLiteral">"M"</FONT>, <FONT ID="IntegerLiteral">0</FONT>, <FONT ID="StringLiteral">"-M"</FONT>));
<FONT ID="LN">1414</FONT><A NAME="1414"></A>    newVector.addElement(<FONT ID="New">new</FONT> <A HREF="../../../weka/core/Option.java.html">Option</A>(<FONT ID="StringLiteral">"\tSet the minimal weights of instances\n"</FONT> +
<FONT ID="LN">1415</FONT><A NAME="1415"></A>                    <FONT ID="StringLiteral">"\twithin a split.\n"</FONT> +
<FONT ID="LN">1416</FONT><A NAME="1416"></A>                    <FONT ID="StringLiteral">"\t(default 2.0)"</FONT>,<FONT ID="StringLiteral">"N"</FONT>, <FONT ID="IntegerLiteral">1</FONT>, <FONT ID="StringLiteral">"-N &lt;min. weights&gt;"</FONT>));        
<FONT ID="LN">1417</FONT><A NAME="1417"></A>    <FONT ID="Return">return</FONT> newVector.elements();
<FONT ID="LN">1418</FONT><A NAME="1418"></A>  }
<FONT ID="LN">1419</FONT><A NAME="1419"></A>    
<FONT ID="LN">1420</FONT><A NAME="1420"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1421</FONT><A NAME="1421"></A>   * Parses a given list of options. &lt;p/&gt;
<FONT ID="LN">1422</FONT><A NAME="1422"></A>   * 
<FONT ID="LN">1423</FONT><A NAME="1423"></A>   &lt;!-- options-start --&gt;
<FONT ID="LN">1424</FONT><A NAME="1424"></A>   * Valid options are: &lt;p/&gt;
<FONT ID="LN">1425</FONT><A NAME="1425"></A>   * 
<FONT ID="LN">1426</FONT><A NAME="1426"></A>   * &lt;pre&gt; -F &amp;lt;number of folds&amp;gt;
<FONT ID="LN">1427</FONT><A NAME="1427"></A>   *  Set number of folds for IREP
<FONT ID="LN">1428</FONT><A NAME="1428"></A>   *  One fold is used as pruning set.
<FONT ID="LN">1429</FONT><A NAME="1429"></A>   *  (default 3)&lt;/pre&gt;
<FONT ID="LN">1430</FONT><A NAME="1430"></A>   * 
<FONT ID="LN">1431</FONT><A NAME="1431"></A>   * &lt;pre&gt; -S &amp;lt;number of shuffles&amp;gt;
<FONT ID="LN">1432</FONT><A NAME="1432"></A>   *  Set number of shuffles to randomize
<FONT ID="LN">1433</FONT><A NAME="1433"></A>   *  the data in order to get better rule.
<FONT ID="LN">1434</FONT><A NAME="1434"></A>   *  (default 10)&lt;/pre&gt;
<FONT ID="LN">1435</FONT><A NAME="1435"></A>   * 
<FONT ID="LN">1436</FONT><A NAME="1436"></A>   * &lt;pre&gt; -A
<FONT ID="LN">1437</FONT><A NAME="1437"></A>   *  Set flag of whether use the error rate 
<FONT ID="LN">1438</FONT><A NAME="1438"></A>   *  of all the data to select the default class
<FONT ID="LN">1439</FONT><A NAME="1439"></A>   *  in each step. If not set, the learner will only use the error rate in the pruning data&lt;/pre&gt;
<FONT ID="LN">1440</FONT><A NAME="1440"></A>   * 
<FONT ID="LN">1441</FONT><A NAME="1441"></A>   * &lt;pre&gt; -M
<FONT ID="LN">1442</FONT><A NAME="1442"></A>   *   Set flag of whether use the majority class as
<FONT ID="LN">1443</FONT><A NAME="1443"></A>   *  the default class in each step instead of 
<FONT ID="LN">1444</FONT><A NAME="1444"></A>   *  choosing default class based on the error rate
<FONT ID="LN">1445</FONT><A NAME="1445"></A>   *  (if the flag is not set)&lt;/pre&gt;
<FONT ID="LN">1446</FONT><A NAME="1446"></A>   * 
<FONT ID="LN">1447</FONT><A NAME="1447"></A>   * &lt;pre&gt; -N &amp;lt;min. weights&amp;gt;
<FONT ID="LN">1448</FONT><A NAME="1448"></A>   *  Set the minimal weights of instances
<FONT ID="LN">1449</FONT><A NAME="1449"></A>   *  within a split.
<FONT ID="LN">1450</FONT><A NAME="1450"></A>   *  (default 2.0)&lt;/pre&gt;
<FONT ID="LN">1451</FONT><A NAME="1451"></A>   * 
<FONT ID="LN">1452</FONT><A NAME="1452"></A>   &lt;!-- options-end --&gt;
<FONT ID="LN">1453</FONT><A NAME="1453"></A>   *
<FONT ID="LN">1454</FONT><A NAME="1454"></A>   * @param options the list of options as an array of strings
<FONT ID="LN">1455</FONT><A NAME="1455"></A>   * @throws Exception if an option is not supported
<FONT ID="LN">1456</FONT><A NAME="1456"></A>   */</FONT>
<FONT ID="LN">1457</FONT><A NAME="1457"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setOptions(String[] options) <FONT ID="Throws">throws</FONT> <A HREF="../../../weka/core/UnsupportedClassTypeException.java.html">Exception</A> {
<FONT ID="LN">1458</FONT><A NAME="1458"></A>    
<FONT ID="LN">1459</FONT><A NAME="1459"></A>    String numFoldsString = Utils.getOption(<FONT ID="CharacerLiteral">'F'</FONT>, options);
<FONT ID="LN">1460</FONT><A NAME="1460"></A>    <FONT ID="If">if</FONT> (numFoldsString.length() != <FONT ID="IntegerLiteral">0</FONT>) 
<FONT ID="LN">1461</FONT><A NAME="1461"></A>      m_Folds = Integer.parseInt(numFoldsString);
<FONT ID="LN">1462</FONT><A NAME="1462"></A>    <FONT ID="Else">else</FONT> 
<FONT ID="LN">1463</FONT><A NAME="1463"></A>      m_Folds = <FONT ID="IntegerLiteral">3</FONT>;
<FONT ID="LN">1464</FONT><A NAME="1464"></A>    
<FONT ID="LN">1465</FONT><A NAME="1465"></A>    String numShuffleString = Utils.getOption(<FONT ID="CharacerLiteral">'S'</FONT>, options);
<FONT ID="LN">1466</FONT><A NAME="1466"></A>    <FONT ID="If">if</FONT> (numShuffleString.length() != <FONT ID="IntegerLiteral">0</FONT>) 
<FONT ID="LN">1467</FONT><A NAME="1467"></A>      m_Shuffle = Integer.parseInt(numShuffleString);
<FONT ID="LN">1468</FONT><A NAME="1468"></A>    <FONT ID="Else">else</FONT> 
<FONT ID="LN">1469</FONT><A NAME="1469"></A>      m_Shuffle = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">1470</FONT><A NAME="1470"></A>
<FONT ID="LN">1471</FONT><A NAME="1471"></A>    String seedString = Utils.getOption(<FONT ID="CharacerLiteral">'s'</FONT>, options);
<FONT ID="LN">1472</FONT><A NAME="1472"></A>    <FONT ID="If">if</FONT> (seedString.length() != <FONT ID="IntegerLiteral">0</FONT>) 
<FONT ID="LN">1473</FONT><A NAME="1473"></A>      m_Seed = Integer.parseInt(seedString);
<FONT ID="LN">1474</FONT><A NAME="1474"></A>    <FONT ID="Else">else</FONT> 
<FONT ID="LN">1475</FONT><A NAME="1475"></A>      m_Seed = <FONT ID="IntegerLiteral">1</FONT>;
<FONT ID="LN">1476</FONT><A NAME="1476"></A>    
<FONT ID="LN">1477</FONT><A NAME="1477"></A>    String minNoString = Utils.getOption(<FONT ID="CharacerLiteral">'N'</FONT>, options);
<FONT ID="LN">1478</FONT><A NAME="1478"></A>    <FONT ID="If">if</FONT> (minNoString.length() != <FONT ID="IntegerLiteral">0</FONT>) 
<FONT ID="LN">1479</FONT><A NAME="1479"></A>      m_MinNo = Double.parseDouble(minNoString);
<FONT ID="LN">1480</FONT><A NAME="1480"></A>    <FONT ID="Else">else</FONT> 
<FONT ID="LN">1481</FONT><A NAME="1481"></A>      m_MinNo = <FONT ID="FloatPointLiteral">2.0</FONT>;
<FONT ID="LN">1482</FONT><A NAME="1482"></A>    
<FONT ID="LN">1483</FONT><A NAME="1483"></A>    m_IsAllErr = Utils.getFlag(<FONT ID="CharacerLiteral">'A'</FONT>, options);
<FONT ID="LN">1484</FONT><A NAME="1484"></A>    m_IsMajority = Utils.getFlag(<FONT ID="CharacerLiteral">'M'</FONT>, options);
<FONT ID="LN">1485</FONT><A NAME="1485"></A>  }
<FONT ID="LN">1486</FONT><A NAME="1486"></A>    
<FONT ID="LN">1487</FONT><A NAME="1487"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1488</FONT><A NAME="1488"></A>   * Gets the current settings of the Classifier.
<FONT ID="LN">1489</FONT><A NAME="1489"></A>   *
<FONT ID="LN">1490</FONT><A NAME="1490"></A>   * @return an array of strings suitable for passing to setOptions
<FONT ID="LN">1491</FONT><A NAME="1491"></A>   */</FONT>
<FONT ID="LN">1492</FONT><A NAME="1492"></A>  <FONT ID="Public">public</FONT> String [] getOptions() {
<FONT ID="LN">1493</FONT><A NAME="1493"></A>    
<FONT ID="LN">1494</FONT><A NAME="1494"></A>    String [] options = <FONT ID="New">new</FONT> String [<FONT ID="IntegerLiteral">8</FONT>];
<FONT ID="LN">1495</FONT><A NAME="1495"></A>    <FONT ID="Int">int</FONT> current = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1496</FONT><A NAME="1496"></A>    options[current++] = <FONT ID="StringLiteral">"-F"</FONT>; options[current++] = <FONT ID="StringLiteral">""</FONT> + m_Folds;
<FONT ID="LN">1497</FONT><A NAME="1497"></A>    options[current++] = <FONT ID="StringLiteral">"-S"</FONT>; options[current++] = <FONT ID="StringLiteral">""</FONT> + m_Shuffle;
<FONT ID="LN">1498</FONT><A NAME="1498"></A>    options[current++] = <FONT ID="StringLiteral">"-N"</FONT>; options[current++] = <FONT ID="StringLiteral">""</FONT> + m_MinNo;
<FONT ID="LN">1499</FONT><A NAME="1499"></A>    
<FONT ID="LN">1500</FONT><A NAME="1500"></A>    <FONT ID="If">if</FONT>(m_IsAllErr)
<FONT ID="LN">1501</FONT><A NAME="1501"></A>      options[current++] = <FONT ID="StringLiteral">"-A"</FONT>;
<FONT ID="LN">1502</FONT><A NAME="1502"></A>    <FONT ID="If">if</FONT>(m_IsMajority)
<FONT ID="LN">1503</FONT><A NAME="1503"></A>      options[current++] = <FONT ID="StringLiteral">"-M"</FONT>;    
<FONT ID="LN">1504</FONT><A NAME="1504"></A>    <FONT ID="While">while</FONT> (current &lt; options.length) 
<FONT ID="LN">1505</FONT><A NAME="1505"></A>      options[current++] = <FONT ID="StringLiteral">""</FONT>;
<FONT ID="LN">1506</FONT><A NAME="1506"></A>    <FONT ID="Return">return</FONT> options;
<FONT ID="LN">1507</FONT><A NAME="1507"></A>  }
<FONT ID="LN">1508</FONT><A NAME="1508"></A>    
<FONT ID="LN">1509</FONT><A NAME="1509"></A>  <FONT ID="FormalComment">/** Set and get members for parameters */</FONT>
<FONT ID="LN">1510</FONT><A NAME="1510"></A>
<FONT ID="LN">1511</FONT><A NAME="1511"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1512</FONT><A NAME="1512"></A>   * Returns the tip text for this property
<FONT ID="LN">1513</FONT><A NAME="1513"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1514</FONT><A NAME="1514"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1515</FONT><A NAME="1515"></A>   */</FONT>
<FONT ID="LN">1516</FONT><A NAME="1516"></A>  <FONT ID="Public">public</FONT> String foldsTipText() {
<FONT ID="LN">1517</FONT><A NAME="1517"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Determines the amount of data used for pruning. One fold is used for "</FONT>
<FONT ID="LN">1518</FONT><A NAME="1518"></A>      + <FONT ID="StringLiteral">"pruning, the rest for growing the rules."</FONT>;
<FONT ID="LN">1519</FONT><A NAME="1519"></A>  }
<FONT ID="LN">1520</FONT><A NAME="1520"></A>
<FONT ID="LN">1521</FONT><A NAME="1521"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setFolds(<FONT ID="Int">int</FONT> fold){ m_Folds = fold; }
<FONT ID="LN">1522</FONT><A NAME="1522"></A>  <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> getFolds(){ <FONT ID="Return">return</FONT> m_Folds; }
<FONT ID="LN">1523</FONT><A NAME="1523"></A>
<FONT ID="LN">1524</FONT><A NAME="1524"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1525</FONT><A NAME="1525"></A>   * Returns the tip text for this property
<FONT ID="LN">1526</FONT><A NAME="1526"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1527</FONT><A NAME="1527"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1528</FONT><A NAME="1528"></A>   */</FONT>
<FONT ID="LN">1529</FONT><A NAME="1529"></A>  <FONT ID="Public">public</FONT> String shuffleTipText() {
<FONT ID="LN">1530</FONT><A NAME="1530"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Determines how often the data is shuffled before a rule "</FONT>
<FONT ID="LN">1531</FONT><A NAME="1531"></A>      + <FONT ID="StringLiteral">"is chosen. If &gt; 1, a rule is learned multiple times and the "</FONT>
<FONT ID="LN">1532</FONT><A NAME="1532"></A>      + <FONT ID="StringLiteral">"most accurate rule is chosen."</FONT>;
<FONT ID="LN">1533</FONT><A NAME="1533"></A>  }
<FONT ID="LN">1534</FONT><A NAME="1534"></A>
<FONT ID="LN">1535</FONT><A NAME="1535"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setShuffle(<FONT ID="Int">int</FONT> sh){ m_Shuffle = sh; }
<FONT ID="LN">1536</FONT><A NAME="1536"></A>  <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> getShuffle(){ <FONT ID="Return">return</FONT> m_Shuffle; }
<FONT ID="LN">1537</FONT><A NAME="1537"></A>
<FONT ID="LN">1538</FONT><A NAME="1538"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1539</FONT><A NAME="1539"></A>   * Returns the tip text for this property
<FONT ID="LN">1540</FONT><A NAME="1540"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1541</FONT><A NAME="1541"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1542</FONT><A NAME="1542"></A>   */</FONT>
<FONT ID="LN">1543</FONT><A NAME="1543"></A>  <FONT ID="Public">public</FONT> String seedTipText() {
<FONT ID="LN">1544</FONT><A NAME="1544"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The seed used for randomizing the data."</FONT>;
<FONT ID="LN">1545</FONT><A NAME="1545"></A>  }
<FONT ID="LN">1546</FONT><A NAME="1546"></A>
<FONT ID="LN">1547</FONT><A NAME="1547"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setSeed(<FONT ID="Int">int</FONT> s){ m_Seed = s; }
<FONT ID="LN">1548</FONT><A NAME="1548"></A>  <FONT ID="Public">public</FONT> <FONT ID="Int">int</FONT> getSeed(){ <FONT ID="Return">return</FONT> m_Seed; }
<FONT ID="LN">1549</FONT><A NAME="1549"></A>
<FONT ID="LN">1550</FONT><A NAME="1550"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1551</FONT><A NAME="1551"></A>   * Returns the tip text for this property
<FONT ID="LN">1552</FONT><A NAME="1552"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1553</FONT><A NAME="1553"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1554</FONT><A NAME="1554"></A>   */</FONT>
<FONT ID="LN">1555</FONT><A NAME="1555"></A>  <FONT ID="Public">public</FONT> String wholeDataErrTipText() {
<FONT ID="LN">1556</FONT><A NAME="1556"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Whether worth of rule is computed based on all the data "</FONT>
<FONT ID="LN">1557</FONT><A NAME="1557"></A>      + <FONT ID="StringLiteral">"or just based on data covered by rule."</FONT>;
<FONT ID="LN">1558</FONT><A NAME="1558"></A>  }
<FONT ID="LN">1559</FONT><A NAME="1559"></A>
<FONT ID="LN">1560</FONT><A NAME="1560"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setWholeDataErr(<FONT ID="Boolean">boolean</FONT> a){ m_IsAllErr = a; }
<FONT ID="LN">1561</FONT><A NAME="1561"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getWholeDataErr(){ <FONT ID="Return">return</FONT> m_IsAllErr; }
<FONT ID="LN">1562</FONT><A NAME="1562"></A>
<FONT ID="LN">1563</FONT><A NAME="1563"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1564</FONT><A NAME="1564"></A>   * Returns the tip text for this property
<FONT ID="LN">1565</FONT><A NAME="1565"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1566</FONT><A NAME="1566"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1567</FONT><A NAME="1567"></A>   */</FONT>
<FONT ID="LN">1568</FONT><A NAME="1568"></A>  <FONT ID="Public">public</FONT> String majorityClassTipText() {
<FONT ID="LN">1569</FONT><A NAME="1569"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"Whether the majority class is used as default."</FONT>;
<FONT ID="LN">1570</FONT><A NAME="1570"></A>  }
<FONT ID="LN">1571</FONT><A NAME="1571"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setMajorityClass(<FONT ID="Boolean">boolean</FONT> m){ m_IsMajority = m; }
<FONT ID="LN">1572</FONT><A NAME="1572"></A>  <FONT ID="Public">public</FONT> <FONT ID="Boolean">boolean</FONT> getMajorityClass(){ <FONT ID="Return">return</FONT> m_IsMajority; }
<FONT ID="LN">1573</FONT><A NAME="1573"></A>
<FONT ID="LN">1574</FONT><A NAME="1574"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1575</FONT><A NAME="1575"></A>   * Returns the tip text for this property
<FONT ID="LN">1576</FONT><A NAME="1576"></A>   * @return tip text for this property suitable for
<FONT ID="LN">1577</FONT><A NAME="1577"></A>   * displaying in the explorer/experimenter gui
<FONT ID="LN">1578</FONT><A NAME="1578"></A>   */</FONT>
<FONT ID="LN">1579</FONT><A NAME="1579"></A>  <FONT ID="Public">public</FONT> String minNoTipText() {
<FONT ID="LN">1580</FONT><A NAME="1580"></A>    <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"The minimum total weight of the instances in a rule."</FONT>;
<FONT ID="LN">1581</FONT><A NAME="1581"></A>  }
<FONT ID="LN">1582</FONT><A NAME="1582"></A>
<FONT ID="LN">1583</FONT><A NAME="1583"></A>  <FONT ID="Public">public</FONT> <FONT ID="Void">void</FONT> setMinNo(<FONT ID="Double">double</FONT> m){  m_MinNo = m; }
<FONT ID="LN">1584</FONT><A NAME="1584"></A>  <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getMinNo(){ <FONT ID="Return">return</FONT> m_MinNo; }
<FONT ID="LN">1585</FONT><A NAME="1585"></A>    
<FONT ID="LN">1586</FONT><A NAME="1586"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1587</FONT><A NAME="1587"></A>   * Returns an enumeration of the additional measure names
<FONT ID="LN">1588</FONT><A NAME="1588"></A>   * @return an enumeration of the measure names
<FONT ID="LN">1589</FONT><A NAME="1589"></A>   */</FONT>
<FONT ID="LN">1590</FONT><A NAME="1590"></A>  <FONT ID="Public">public</FONT> Enumeration enumerateMeasures() {
<FONT ID="LN">1591</FONT><A NAME="1591"></A>    <A HREF="../../../weka/core/FastVector.java.html">Vector</A> newVector = <FONT ID="New">new</FONT> <A HREF="../../../weka/core/FastVector.java.html">Vector</A>(<FONT ID="IntegerLiteral">1</FONT>);
<FONT ID="LN">1592</FONT><A NAME="1592"></A>    newVector.addElement(<FONT ID="StringLiteral">"measureNumRules"</FONT>);
<FONT ID="LN">1593</FONT><A NAME="1593"></A>    <FONT ID="Return">return</FONT> newVector.elements();
<FONT ID="LN">1594</FONT><A NAME="1594"></A>  }
<FONT ID="LN">1595</FONT><A NAME="1595"></A>    
<FONT ID="LN">1596</FONT><A NAME="1596"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1597</FONT><A NAME="1597"></A>   * Returns the value of the named measure
<FONT ID="LN">1598</FONT><A NAME="1598"></A>   * @param additionalMeasureName the name of the measure to query for its value
<FONT ID="LN">1599</FONT><A NAME="1599"></A>   * @return the value of the named measure
<FONT ID="LN">1600</FONT><A NAME="1600"></A>   * @throws IllegalArgumentException if the named measure is not supported
<FONT ID="LN">1601</FONT><A NAME="1601"></A>   */</FONT>
<FONT ID="LN">1602</FONT><A NAME="1602"></A>  <FONT ID="Public">public</FONT> <FONT ID="Double">double</FONT> getMeasure(String additionalMeasureName) {
<FONT ID="LN">1603</FONT><A NAME="1603"></A>    <FONT ID="If">if</FONT> (additionalMeasureName.compareToIgnoreCase(<FONT ID="StringLiteral">"measureNumRules"</FONT>) == <FONT ID="IntegerLiteral">0</FONT>) 
<FONT ID="LN">1604</FONT><A NAME="1604"></A>      <FONT ID="Return">return</FONT> numRules();
<FONT ID="LN">1605</FONT><A NAME="1605"></A>    <FONT ID="Else">else</FONT> 
<FONT ID="LN">1606</FONT><A NAME="1606"></A>      <FONT ID="Throw">throw</FONT> <FONT ID="New">new</FONT> IllegalArgumentException(additionalMeasureName+<FONT ID="StringLiteral">" not supported (Ripple down rule learner)"</FONT>);
<FONT ID="LN">1607</FONT><A NAME="1607"></A>  }  
<FONT ID="LN">1608</FONT><A NAME="1608"></A>    
<FONT ID="LN">1609</FONT><A NAME="1609"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1610</FONT><A NAME="1610"></A>   * Measure the number of rules in total in the model
<FONT ID="LN">1611</FONT><A NAME="1611"></A>   *
<FONT ID="LN">1612</FONT><A NAME="1612"></A>   * @return the number of rules
<FONT ID="LN">1613</FONT><A NAME="1613"></A>   */</FONT>  
<FONT ID="LN">1614</FONT><A NAME="1614"></A>  <FONT ID="Private">private</FONT> <FONT ID="Double">double</FONT> numRules(){
<FONT ID="LN">1615</FONT><A NAME="1615"></A>    <FONT ID="Int">int</FONT> size = <FONT ID="IntegerLiteral">0</FONT>;
<FONT ID="LN">1616</FONT><A NAME="1616"></A>    <FONT ID="If">if</FONT>(m_Root != <FONT ID="Null">null</FONT>)
<FONT ID="LN">1617</FONT><A NAME="1617"></A>      size = m_Root.size();
<FONT ID="LN">1618</FONT><A NAME="1618"></A>    
<FONT ID="LN">1619</FONT><A NAME="1619"></A>    <FONT ID="Return">return</FONT> (<FONT ID="Double">double</FONT>)(size+<FONT ID="IntegerLiteral">1</FONT>); <FONT ID="SingleLineComment">// Add the default rule
<FONT ID="LN">1620</FONT><A NAME="1620"></A></FONT>  }
<FONT ID="LN">1621</FONT><A NAME="1621"></A>   
<FONT ID="LN">1622</FONT><A NAME="1622"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1623</FONT><A NAME="1623"></A>   * Prints the all the rules of the rule learner.
<FONT ID="LN">1624</FONT><A NAME="1624"></A>   *
<FONT ID="LN">1625</FONT><A NAME="1625"></A>   * @return a textual description of the classifier
<FONT ID="LN">1626</FONT><A NAME="1626"></A>   */</FONT>
<FONT ID="LN">1627</FONT><A NAME="1627"></A>  <FONT ID="Public">public</FONT> String toString() {
<FONT ID="LN">1628</FONT><A NAME="1628"></A>    <FONT ID="If">if</FONT> (m_Root == <FONT ID="Null">null</FONT>) 
<FONT ID="LN">1629</FONT><A NAME="1629"></A>      <FONT ID="Return">return</FONT> <FONT ID="StringLiteral">"RIpple DOwn Rule Learner(Ridor): No model built yet."</FONT>;
<FONT ID="LN">1630</FONT><A NAME="1630"></A>    
<FONT ID="LN">1631</FONT><A NAME="1631"></A>    <FONT ID="Return">return</FONT> (<FONT ID="StringLiteral">"RIpple DOwn Rule Learner(Ridor) rules\n"</FONT>+
<FONT ID="LN">1632</FONT><A NAME="1632"></A>        <FONT ID="StringLiteral">"--------------------------------------\n\n"</FONT> + 
<FONT ID="LN">1633</FONT><A NAME="1633"></A>        m_Root.toString() +
<FONT ID="LN">1634</FONT><A NAME="1634"></A>        <FONT ID="StringLiteral">"\nTotal number of rules (incl. the default rule): "</FONT> + (<FONT ID="Int">int</FONT>)numRules());
<FONT ID="LN">1635</FONT><A NAME="1635"></A>  }
<FONT ID="LN">1636</FONT><A NAME="1636"></A>  
<FONT ID="LN">1637</FONT><A NAME="1637"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1638</FONT><A NAME="1638"></A>   * Returns the revision string.
<FONT ID="LN">1639</FONT><A NAME="1639"></A>   * 
<FONT ID="LN">1640</FONT><A NAME="1640"></A>   * @return        the revision
<FONT ID="LN">1641</FONT><A NAME="1641"></A>   */</FONT>
<FONT ID="LN">1642</FONT><A NAME="1642"></A>  <FONT ID="Public">public</FONT> String getRevision() {
<FONT ID="LN">1643</FONT><A NAME="1643"></A>    <FONT ID="Return">return</FONT> RevisionUtils.extract(<FONT ID="StringLiteral">"$Revision: 5928 $"</FONT>);
<FONT ID="LN">1644</FONT><A NAME="1644"></A>  }
<FONT ID="LN">1645</FONT><A NAME="1645"></A>    
<FONT ID="LN">1646</FONT><A NAME="1646"></A>  <FONT ID="FormalComment">/**
<FONT ID="LN">1647</FONT><A NAME="1647"></A>   * Main method.
<FONT ID="LN">1648</FONT><A NAME="1648"></A>   *
<FONT ID="LN">1649</FONT><A NAME="1649"></A>   * @param args the options for the classifier
<FONT ID="LN">1650</FONT><A NAME="1650"></A>   */</FONT>
<FONT ID="LN">1651</FONT><A NAME="1651"></A>  <FONT ID="Public">public</FONT> <FONT ID="Static">static</FONT> <FONT ID="Void">void</FONT> main(String[] args) {  
<FONT ID="LN">1652</FONT><A NAME="1652"></A>    runClassifier(<FONT ID="New">new</FONT> <A HREF="../../../weka/classifiers/rules/Ridor.java.html">Ridor</A>(), args);
<FONT ID="LN">1653</FONT><A NAME="1653"></A>  }
<FONT ID="LN">1654</FONT><A NAME="1654"></A>}
<FONT ID="LN">1655</FONT><A NAME="1655"></A></pre><TABLE id="Header" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td colspan="2" width="33%">&nbsp;</td>
<td align="center" colspan="2" width="33%">
<font size="4">Ridor.java</font>
</td>
<td align="right" colspan="2" width="33%">&nbsp;</td>
</tr>
</TABLE>

</BODY>
</HTML>